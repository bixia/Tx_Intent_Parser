{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 11, 'end_line': 17, 'offset_start': 168, 'offset_end': 383, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 18, 'end_line': 23, 'offset_start': 389, 'offset_end': 577, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 24, 'end_line': 31, 'offset_start': 583, 'offset_end': 845, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 32, 'end_line': 37, 'offset_start': 851, 'offset_end': 1040, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 38, 'end_line': 43, 'offset_start': 1046, 'offset_end': 1235, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 44, 'end_line': 46, 'offset_start': 1241, 'offset_end': 1344, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 47, 'end_line': 49, 'offset_start': 1350, 'offset_end': 1453, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 50, 'end_line': 52, 'offset_start': 1459, 'offset_end': 1574, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 53, 'end_line': 58, 'offset_start': 1580, 'offset_end': 1760, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 59, 'end_line': 96, 'offset_start': 1766, 'offset_end': 3233, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 97, 'end_line': 103, 'offset_start': 3239, 'offset_end': 3540, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 104, 'end_line': 119, 'offset_start': 3546, 'offset_end': 4126, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 120, 'end_line': 125, 'offset_start': 4132, 'offset_end': 4371, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 126, 'end_line': 162, 'offset_start': 4377, 'offset_end': 5359, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 163, 'end_line': 168, 'offset_start': 5365, 'offset_end': 5612, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 169, 'end_line': 201, 'offset_start': 5618, 'offset_end': 6533, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 202, 'end_line': 207, 'offset_start': 6539, 'offset_end': 6789, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 208, 'end_line': 232, 'offset_start': 6795, 'offset_end': 7457, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 233, 'end_line': 238, 'offset_start': 7463, 'offset_end': 7721, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 239, 'end_line': 241, 'offset_start': 7727, 'offset_end': 7848, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 247, 'end_line': 248, 'offset_start': 8093, 'offset_end': 8150, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 249, 'end_line': 250, 'offset_start': 8156, 'offset_end': 8223, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 251, 'end_line': 253, 'offset_start': 8229, 'offset_end': 8374, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._getEIP712Storage', 'start_line': 269, 'end_line': 273, 'offset_start': 9119, 'offset_end': 9274, 'content': 'function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init', 'start_line': 274, 'end_line': 276, 'offset_start': 9280, 'offset_end': 9426, 'content': 'function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init_unchained', 'start_line': 277, 'end_line': 283, 'offset_start': 9432, 'offset_end': 9706, 'content': 'function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._domainSeparatorV4', 'start_line': 284, 'end_line': 286, 'offset_start': 9712, 'offset_end': 9820, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._buildDomainSeparator', 'start_line': 287, 'end_line': 289, 'offset_start': 9826, 'offset_end': 10016, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._hashTypedDataV4', 'start_line': 290, 'end_line': 292, 'offset_start': 10022, 'offset_end': 10197, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.eip712Domain', 'start_line': 293, 'end_line': 318, 'offset_start': 10203, 'offset_end': 10893, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Name', 'start_line': 319, 'end_line': 322, 'offset_start': 10899, 'offset_end': 11053, 'content': 'function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Version', 'start_line': 323, 'end_line': 326, 'offset_start': 11059, 'offset_end': 11219, 'content': 'function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712NameHash', 'start_line': 327, 'end_line': 340, 'offset_start': 11225, 'offset_end': 11688, 'content': 'function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712VersionHash', 'start_line': 341, 'end_line': 354, 'offset_start': 11694, 'offset_end': 12184, 'content': 'function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 358, 'end_line': 360, 'offset_start': 12238, 'offset_end': 12338, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 361, 'end_line': 363, 'offset_start': 12344, 'offset_end': 12444, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 364, 'end_line': 367, 'offset_start': 12450, 'offset_end': 12627, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 368, 'end_line': 372, 'offset_start': 12633, 'offset_end': 12769, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getERC721Storage', 'start_line': 395, 'end_line': 399, 'offset_start': 14142, 'offset_end': 14297, 'content': 'function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 400, 'end_line': 402, 'offset_start': 14303, 'offset_end': 14451, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 403, 'end_line': 407, 'offset_start': 14457, 'offset_end': 14675, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 408, 'end_line': 413, 'offset_start': 14681, 'offset_end': 14991, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 414, 'end_line': 420, 'offset_start': 14997, 'offset_end': 15261, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 421, 'end_line': 423, 'offset_start': 15267, 'offset_end': 15384, 'content': 'function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 424, 'end_line': 427, 'offset_start': 15390, 'offset_end': 15535, 'content': 'function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 428, 'end_line': 431, 'offset_start': 15541, 'offset_end': 15690, 'content': 'function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 432, 'end_line': 436, 'offset_start': 15696, 'offset_end': 15949, 'content': 'function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 437, 'end_line': 439, 'offset_start': 15955, 'offset_end': 16046, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 440, 'end_line': 442, 'offset_start': 16052, 'offset_end': 16164, 'content': 'function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 443, 'end_line': 446, 'offset_start': 16170, 'offset_end': 16322, 'content': 'function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 447, 'end_line': 449, 'offset_start': 16328, 'offset_end': 16471, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 450, 'end_line': 453, 'offset_start': 16477, 'offset_end': 16686, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 454, 'end_line': 462, 'offset_start': 16692, 'offset_end': 17060, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 463, 'end_line': 465, 'offset_start': 17066, 'offset_end': 17197, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 466, 'end_line': 469, 'offset_start': 17203, 'offset_end': 17410, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 470, 'end_line': 473, 'offset_start': 17416, 'offset_end': 17587, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getApproved', 'start_line': 474, 'end_line': 477, 'offset_start': 17593, 'offset_end': 17776, 'content': 'function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isAuthorized', 'start_line': 478, 'end_line': 482, 'offset_start': 17782, 'offset_end': 18053, 'content': 'function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkAuthorized', 'start_line': 483, 'end_line': 491, 'offset_start': 18059, 'offset_end': 18426, 'content': 'function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._increaseBalance', 'start_line': 492, 'end_line': 497, 'offset_start': 18432, 'offset_end': 18641, 'content': 'function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._update', 'start_line': 498, 'end_line': 518, 'offset_start': 18647, 'offset_end': 19338, 'content': 'function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 519, 'end_line': 527, 'offset_start': 19344, 'offset_end': 19670, 'content': 'function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 528, 'end_line': 530, 'offset_start': 19676, 'offset_end': 19775, 'content': 'function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 531, 'end_line': 534, 'offset_start': 19781, 'offset_end': 19962, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 535, 'end_line': 540, 'offset_start': 19968, 'offset_end': 20194, 'content': 'function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 541, 'end_line': 551, 'offset_start': 20200, 'offset_end': 20659, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 552, 'end_line': 554, 'offset_start': 20665, 'offset_end': 20792, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 555, 'end_line': 558, 'offset_start': 20798, 'offset_end': 21001, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 559, 'end_line': 561, 'offset_start': 21007, 'offset_end': 21126, 'content': 'function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 562, 'end_line': 574, 'offset_start': 21132, 'offset_end': 21686, 'content': 'function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 575, 'end_line': 582, 'offset_start': 21692, 'offset_end': 22060, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireOwned', 'start_line': 583, 'end_line': 589, 'offset_start': 22066, 'offset_end': 22306, 'content': 'function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 590, 'end_line': 606, 'offset_start': 22312, 'offset_end': 23038, 'content': 'function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 619, 'end_line': 633, 'offset_start': 23353, 'offset_end': 23940, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 634, 'end_line': 638, 'offset_start': 23946, 'offset_end': 24200, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 639, 'end_line': 645, 'offset_start': 24206, 'offset_end': 24562, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 646, 'end_line': 650, 'offset_start': 24568, 'offset_end': 24817, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 651, 'end_line': 665, 'offset_start': 24823, 'offset_end': 25392, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 666, 'end_line': 670, 'offset_start': 25398, 'offset_end': 25657, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 671, 'end_line': 681, 'offset_start': 25663, 'offset_end': 26171, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 690, 'end_line': 708, 'offset_start': 26491, 'offset_end': 27090, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 709, 'end_line': 711, 'offset_start': 27096, 'offset_end': 27263, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 712, 'end_line': 716, 'offset_start': 27269, 'offset_end': 27442, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 717, 'end_line': 730, 'offset_start': 27448, 'offset_end': 27972, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 731, 'end_line': 733, 'offset_start': 27978, 'offset_end': 28125, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 734, 'end_line': 736, 'offset_start': 28131, 'offset_end': 28312, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 741, 'end_line': 742, 'offset_start': 28465, 'offset_end': 28523, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 743, 'end_line': 744, 'offset_start': 28529, 'offset_end': 28597, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 745, 'end_line': 747, 'offset_start': 28603, 'offset_end': 28698, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 748, 'end_line': 750, 'offset_start': 28704, 'offset_end': 28802, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 755, 'end_line': 761, 'offset_start': 28902, 'offset_end': 29175, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 762, 'end_line': 765, 'offset_start': 29181, 'offset_end': 29409, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 766, 'end_line': 768, 'offset_start': 29415, 'offset_end': 29605, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 769, 'end_line': 777, 'offset_start': 29611, 'offset_end': 29968, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.hasRole', 'start_line': 786, 'end_line': 786, 'offset_start': 30454, 'offset_end': 30530, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.getRoleAdmin', 'start_line': 787, 'end_line': 787, 'offset_start': 30536, 'offset_end': 30603, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.grantRole', 'start_line': 788, 'end_line': 788, 'offset_start': 30609, 'offset_end': 30667, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.revokeRole', 'start_line': 789, 'end_line': 789, 'offset_start': 30673, 'offset_end': 30732, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.renounceRole', 'start_line': 790, 'end_line': 790, 'offset_start': 30738, 'offset_end': 30810, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tor', 'start_line': 911, 'end_line': 913, 'offset_start': 35245, 'offset_end': 35297, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initialize', 'start_line': 914, 'end_line': 928, 'offset_start': 35303, 'offset_end': 35818, 'content': 'function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._authorizeUpgrade', 'start_line': 929, 'end_line': 933, 'offset_start': 35824, 'offset_end': 35949, 'content': 'function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tokenURI', 'start_line': 934, 'end_line': 936, 'offset_start': 35955, 'offset_end': 36090, 'content': 'function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCubes', 'start_line': 937, 'end_line': 964, 'offset_start': 36096, 'offset_end': 36909, 'content': 'function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._mintCube', 'start_line': 965, 'end_line': 1003, 'offset_start': 36915, 'offset_end': 38168, 'content': 'function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._validateSignature', 'start_line': 1004, 'end_line': 1013, 'offset_start': 38174, 'offset_end': 38544, 'content': 'function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._processPayouts', 'start_line': 1014, 'end_line': 1042, 'offset_start': 38550, 'offset_end': 39692, 'content': 'function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getSigner', 'start_line': 1043, 'end_line': 1050, 'offset_start': 39698, 'offset_end': 39911, 'content': 'function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._computeDigest', 'start_line': 1051, 'end_line': 1053, 'offset_start': 39917, 'offset_end': 40069, 'content': 'function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getStructHash', 'start_line': 1054, 'end_line': 1068, 'offset_start': 40075, 'offset_end': 40608, 'content': 'function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeString', 'start_line': 1069, 'end_line': 1071, 'offset_start': 40614, 'offset_end': 40742, 'content': 'function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeTx', 'start_line': 1072, 'end_line': 1078, 'offset_start': 40748, 'offset_end': 41013, 'content': 'function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeCompletedTxs', 'start_line': 1079, 'end_line': 1092, 'offset_start': 41019, 'offset_end': 41453, 'content': 'function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipient', 'start_line': 1093, 'end_line': 1095, 'offset_start': 41459, 'offset_end': 41630, 'content': 'function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipients', 'start_line': 1096, 'end_line': 1105, 'offset_start': 41636, 'offset_end': 42057, 'content': 'function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeReward', 'start_line': 1106, 'end_line': 1117, 'offset_start': 42063, 'offset_end': 42414, 'content': 'function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.setIsMintingActive', 'start_line': 1118, 'end_line': 1121, 'offset_start': 42420, 'offset_end': 42607, 'content': 'function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.withdraw', 'start_line': 1122, 'end_line': 1128, 'offset_start': 42613, 'offset_end': 42887, 'content': 'function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initializeQuest', 'start_line': 1129, 'end_line': 1138, 'offset_start': 42893, 'offset_end': 43228, 'content': 'function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.supportsInterface', 'start_line': 1139, 'end_line': 1146, 'offset_start': 43234, 'offset_end': 43457, 'content': 'function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155,\n        NATIVE\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 1150, 'end_line': 1155, 'offset_start': 43518, 'offset_end': 43677, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267.eip712Domain', 'start_line': 1160, 'end_line': 1171, 'offset_start': 43764, 'offset_end': 44073, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267', 'contract_code': '{\n    event EIP712DomainChanged();\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 1193, 'end_line': 1197, 'offset_start': 44443, 'offset_end': 44589, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 1198, 'end_line': 1202, 'offset_start': 44595, 'offset_end': 44741, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 1203, 'end_line': 1207, 'offset_start': 44747, 'offset_end': 44893, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 1208, 'end_line': 1212, 'offset_start': 44899, 'offset_end': 45045, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1213, 'end_line': 1217, 'offset_start': 45051, 'offset_end': 45195, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 1218, 'end_line': 1222, 'offset_start': 45201, 'offset_end': 45359, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1223, 'end_line': 1227, 'offset_start': 45365, 'offset_end': 45507, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 1228, 'end_line': 1232, 'offset_start': 45513, 'offset_end': 45668, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 1243, 'end_line': 1247, 'offset_start': 46114, 'offset_end': 46296, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1249, 'end_line': 1251, 'offset_start': 46344, 'offset_end': 46454, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1252, 'end_line': 1255, 'offset_start': 46460, 'offset_end': 46642, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1261, 'end_line': 1267, 'offset_start': 46756, 'offset_end': 47000, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1268, 'end_line': 1271, 'offset_start': 47006, 'offset_end': 47156, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1272, 'end_line': 1275, 'offset_start': 47162, 'offset_end': 47342, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 1283, 'end_line': 1283, 'offset_start': 47740, 'offset_end': 47813, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 1284, 'end_line': 1284, 'offset_start': 47819, 'offset_end': 47890, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 1285, 'end_line': 1285, 'offset_start': 47896, 'offset_end': 47994, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 1286, 'end_line': 1286, 'offset_start': 48000, 'offset_end': 48077, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 1287, 'end_line': 1287, 'offset_start': 48083, 'offset_end': 48156, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 1288, 'end_line': 1288, 'offset_start': 48162, 'offset_end': 48216, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 1289, 'end_line': 1289, 'offset_start': 48222, 'offset_end': 48290, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 1290, 'end_line': 1290, 'offset_start': 48296, 'offset_end': 48374, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 1291, 'end_line': 1291, 'offset_start': 48380, 'offset_end': 48467, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 1295, 'end_line': 1295, 'offset_start': 48530, 'offset_end': 48586, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 1299, 'end_line': 1299, 'offset_start': 48639, 'offset_end': 48696, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1334, 'end_line': 1342, 'offset_start': 50261, 'offset_end': 50590, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1343, 'end_line': 1345, 'offset_start': 50596, 'offset_end': 50746, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1346, 'end_line': 1352, 'offset_start': 50752, 'offset_end': 51143, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1353, 'end_line': 1356, 'offset_start': 51149, 'offset_end': 51402, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1357, 'end_line': 1360, 'offset_start': 51408, 'offset_end': 51660, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1361, 'end_line': 1374, 'offset_start': 51666, 'offset_end': 52077, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1375, 'end_line': 1381, 'offset_start': 52083, 'offset_end': 52306, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1382, 'end_line': 1391, 'offset_start': 52312, 'offset_end': 52630, 'content': 'function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 1437, 'end_line': 1441, 'offset_start': 54144, 'offset_end': 54284, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1442, 'end_line': 1451, 'offset_start': 54290, 'offset_end': 54654, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1452, 'end_line': 1454, 'offset_start': 54660, 'offset_end': 54787, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1455, 'end_line': 1457, 'offset_start': 54793, 'offset_end': 54912, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 1458, 'end_line': 1462, 'offset_start': 54918, 'offset_end': 55087, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 1481, 'end_line': 1482, 'offset_start': 55774, 'offset_end': 55840, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 1483, 'end_line': 1484, 'offset_start': 55846, 'offset_end': 55922, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 1485, 'end_line': 1487, 'offset_start': 55928, 'offset_end': 56061, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 1488, 'end_line': 1491, 'offset_start': 56067, 'offset_end': 56280, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 1492, 'end_line': 1499, 'offset_start': 56286, 'offset_end': 56518, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 1500, 'end_line': 1504, 'offset_start': 56524, 'offset_end': 56681, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 1505, 'end_line': 1505, 'offset_start': 56687, 'offset_end': 56757, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 1506, 'end_line': 1515, 'offset_start': 56763, 'offset_end': 57254, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 1520, 'end_line': 1520, 'offset_start': 57366, 'offset_end': 57419, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 1521, 'end_line': 1521, 'offset_start': 57425, 'offset_end': 57480, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 1522, 'end_line': 1522, 'offset_start': 57486, 'offset_end': 57558, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1526, 'end_line': 1526, 'offset_start': 57611, 'offset_end': 57686, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 1541, 'end_line': 1543, 'offset_start': 58371, 'offset_end': 58508, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 1544, 'end_line': 1549, 'offset_start': 58514, 'offset_end': 58794, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 1550, 'end_line': 1558, 'offset_start': 58800, 'offset_end': 59133, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 1560, 'end_line': 1562, 'offset_start': 59250, 'offset_end': 59369, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 1563, 'end_line': 1568, 'offset_start': 59375, 'offset_end': 59591, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 1569, 'end_line': 1572, 'offset_start': 59597, 'offset_end': 59729, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 1574, 'end_line': 1576, 'offset_start': 59847, 'offset_end': 59968, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 1577, 'end_line': 1586, 'offset_start': 59974, 'offset_end': 60408, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 1587, 'end_line': 1595, 'offset_start': 60414, 'offset_end': 60745, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 1596, 'end_line': 1600, 'offset_start': 60751, 'offset_end': 60872, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._getAccessControlStorage', 'start_line': 1617, 'end_line': 1621, 'offset_start': 61694, 'offset_end': 61870, 'content': 'function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 1626, 'end_line': 1627, 'offset_start': 61957, 'offset_end': 62021, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 1628, 'end_line': 1629, 'offset_start': 62027, 'offset_end': 62101, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 1630, 'end_line': 1632, 'offset_start': 62107, 'offset_end': 62308, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 1633, 'end_line': 1636, 'offset_start': 62314, 'offset_end': 62520, 'content': 'function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1637, 'end_line': 1639, 'offset_start': 62526, 'offset_end': 62628, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1640, 'end_line': 1644, 'offset_start': 62634, 'offset_end': 62830, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 1645, 'end_line': 1648, 'offset_start': 62836, 'offset_end': 63026, 'content': 'function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 1649, 'end_line': 1651, 'offset_start': 63032, 'offset_end': 63167, 'content': 'function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 1652, 'end_line': 1654, 'offset_start': 63173, 'offset_end': 63310, 'content': 'function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 1655, 'end_line': 1660, 'offset_start': 63316, 'offset_end': 63559, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 1661, 'end_line': 1666, 'offset_start': 63565, 'offset_end': 63882, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 1667, 'end_line': 1676, 'offset_start': 63888, 'offset_end': 64274, 'content': 'function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 1677, 'end_line': 1686, 'offset_start': 64280, 'offset_end': 64667, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
