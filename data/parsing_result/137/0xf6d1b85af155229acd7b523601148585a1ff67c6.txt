{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 4, 'end_line': 4, 'offset_start': 56, 'offset_end': 110, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 5, 'end_line': 5, 'offset_start': 116, 'offset_end': 183, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 6, 'end_line': 6, 'offset_start': 189, 'offset_end': 265, 'content': 'function transfer(address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 7, 'end_line': 7, 'offset_start': 271, 'offset_end': 353, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 8, 'end_line': 8, 'offset_start': 359, 'offset_end': 432, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 9, 'end_line': 9, 'offset_start': 438, 'offset_end': 534, 'content': 'function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryAdd', 'start_line': 15, 'end_line': 19, 'offset_start': 753, 'offset_end': 926, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.trySub', 'start_line': 20, 'end_line': 23, 'offset_start': 932, 'offset_end': 1082, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryMul', 'start_line': 24, 'end_line': 29, 'offset_start': 1088, 'offset_end': 1304, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryDiv', 'start_line': 30, 'end_line': 33, 'offset_start': 1310, 'offset_end': 1461, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryMod', 'start_line': 34, 'end_line': 37, 'offset_start': 1467, 'offset_end': 1618, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.add', 'start_line': 38, 'end_line': 42, 'offset_start': 1624, 'offset_end': 1798, 'content': 'function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 43, 'end_line': 46, 'offset_start': 1804, 'offset_end': 1958, 'content': 'function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mul', 'start_line': 47, 'end_line': 52, 'offset_start': 1964, 'offset_end': 2178, 'content': 'function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 53, 'end_line': 56, 'offset_start': 2184, 'offset_end': 2333, 'content': 'function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mod', 'start_line': 57, 'end_line': 60, 'offset_start': 2339, 'offset_end': 2486, 'content': 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 61, 'end_line': 64, 'offset_start': 2492, 'offset_end': 2654, 'content': 'function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 65, 'end_line': 68, 'offset_start': 2660, 'offset_end': 2821, 'content': 'function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mod', 'start_line': 69, 'end_line': 72, 'offset_start': 2827, 'offset_end': 2988, 'content': 'function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712.tor', 'start_line': 81, 'end_line': 90, 'offset_start': 3292, 'offset_end': 3842, 'content': 'constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._domainSeparatorV4', 'start_line': 91, 'end_line': 97, 'offset_start': 3848, 'offset_end': 4130, 'content': 'function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._buildDomainSeparator', 'start_line': 98, 'end_line': 108, 'offset_start': 4136, 'offset_end': 4462, 'content': 'function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._hashTypedDataV4', 'start_line': 109, 'end_line': 111, 'offset_start': 4468, 'offset_end': 4650, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._getChainId', 'start_line': 112, 'end_line': 117, 'offset_start': 4656, 'offset_end': 4801, 'content': 'function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 121, 'end_line': 134, 'offset_start': 4857, 'offset_end': 5320, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 135, 'end_line': 141, 'offset_start': 5326, 'offset_end': 5779, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 142, 'end_line': 144, 'offset_start': 5785, 'offset_end': 5955, 'content': 'function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 148, 'end_line': 152, 'offset_start': 6013, 'offset_end': 6182, 'content': 'function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 153, 'end_line': 157, 'offset_start': 6188, 'offset_end': 6500, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 158, 'end_line': 160, 'offset_start': 6506, 'offset_end': 6676, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 161, 'end_line': 163, 'offset_start': 6682, 'offset_end': 6874, 'content': 'function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 164, 'end_line': 166, 'offset_start': 6880, 'offset_end': 7103, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 167, 'end_line': 172, 'offset_start': 7109, 'offset_end': 7571, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 173, 'end_line': 175, 'offset_start': 7577, 'offset_end': 7773, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 176, 'end_line': 180, 'offset_start': 7779, 'offset_end': 8134, 'content': 'function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 181, 'end_line': 183, 'offset_start': 8140, 'offset_end': 8337, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 184, 'end_line': 188, 'offset_start': 8343, 'offset_end': 8699, 'content': 'function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._verifyCallResult', 'start_line': 189, 'end_line': 202, 'offset_start': 8705, 'offset_end': 9206, 'content': 'function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.isOwnerOf', 'start_line': 206, 'end_line': 206, 'offset_start': 9258, 'offset_end': 9323, 'content': 'function isOwnerOf(address, uint256) external view returns (bool);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.getNumMinted', 'start_line': 207, 'end_line': 207, 'offset_start': 9329, 'offset_end': 9384, 'content': 'function getNumMinted() external view returns (uint256);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.mint', 'start_line': 208, 'end_line': 208, 'offset_start': 9390, 'offset_end': 9462, 'content': 'function mint(address account, uint256 powah) external returns (uint256);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.mintBatch', 'start_line': 209, 'end_line': 209, 'offset_start': 9468, 'offset_end': 9584, 'content': 'function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.burn', 'start_line': 210, 'end_line': 210, 'offset_start': 9590, 'offset_end': 9641, 'content': 'function burn(address account, uint256 id) external;', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.burnBatch', 'start_line': 211, 'end_line': 211, 'offset_start': 9647, 'offset_end': 9715, 'content': 'function burnBatch(address account, uint256[] calldata ids) external;', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.tor', 'start_line': 292, 'end_line': 302, 'offset_start': 11795, 'offset_end': 12148, 'content': 'constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.activateCampaign', 'start_line': 303, 'end_line': 311, 'offset_start': 12154, 'offset_end': 12422, 'content': 'function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claim', 'start_line': 312, 'end_line': 332, 'offset_start': 12428, 'offset_end': 13074, 'content': 'function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claim', 'start_line': 333, 'end_line': 341, 'offset_start': 13080, 'offset_end': 13344, 'content': 'function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatch', 'start_line': 342, 'end_line': 376, 'offset_start': 13350, 'offset_end': 14485, 'content': 'function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatch', 'start_line': 377, 'end_line': 385, 'offset_start': 14491, 'offset_end': 14799, 'content': 'function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimCapped', 'start_line': 386, 'end_line': 410, 'offset_start': 14805, 'offset_end': 15662, 'content': 'function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimCapped', 'start_line': 411, 'end_line': 420, 'offset_start': 15668, 'offset_end': 15972, 'content': 'function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatchCapped', 'start_line': 421, 'end_line': 469, 'offset_start': 15978, 'offset_end': 17535, 'content': 'function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatchCapped', 'start_line': 470, 'end_line': 479, 'offset_start': 17541, 'offset_end': 17889, 'content': 'function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.forge', 'start_line': 480, 'end_line': 515, 'offset_start': 17895, 'offset_end': 18965, 'content': 'function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.forge', 'start_line': 516, 'end_line': 525, 'offset_start': 18971, 'offset_end': 19280, 'content': 'function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.', 'start_line': 526, 'end_line': 531, 'offset_start': 19286, 'offset_end': 19468, 'content': 'receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.', 'start_line': 532, 'end_line': 537, 'offset_start': 19474, 'offset_end': 19682, 'content': 'fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateGalaxySigner', 'start_line': 538, 'end_line': 544, 'offset_start': 19688, 'offset_end': 19926, 'content': 'function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateCampaignSetter', 'start_line': 545, 'end_line': 551, 'offset_start': 19932, 'offset_end': 20176, 'content': 'function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateManager', 'start_line': 552, 'end_line': 558, 'offset_start': 20182, 'offset_end': 20403, 'content': 'function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateTreasureManager', 'start_line': 559, 'end_line': 568, 'offset_start': 20409, 'offset_end': 20676, 'content': 'function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.setPause', 'start_line': 569, 'end_line': 571, 'offset_start': 20682, 'offset_end': 20767, 'content': 'function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hash', 'start_line': 572, 'end_line': 594, 'offset_start': 20773, 'offset_end': 21392, 'content': 'function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashCapped', 'start_line': 595, 'end_line': 619, 'offset_start': 21398, 'offset_end': 22083, 'content': 'function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashBatch', 'start_line': 620, 'end_line': 642, 'offset_start': 22089, 'offset_end': 22815, 'content': 'function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashBatchCapped', 'start_line': 643, 'end_line': 667, 'offset_start': 22821, 'offset_end': 23613, 'content': 'function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashForge', 'start_line': 668, 'end_line': 692, 'offset_start': 23619, 'offset_end': 24354, 'content': 'function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._verify', 'start_line': 693, 'end_line': 699, 'offset_start': 24360, 'offset_end': 24530, 'content': 'function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._setFees', 'start_line': 700, 'end_line': 716, 'offset_start': 24536, 'offset_end': 25002, 'content': 'function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._payFees', 'start_line': 717, 'end_line': 740, 'offset_start': 25008, 'offset_end': 25871, 'content': 'function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyCampaignSetter', 'start_line': 741, 'end_line': 743, 'offset_start': 25877, 'offset_end': 26016, 'content': 'function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyManager', 'start_line': 744, 'end_line': 746, 'offset_start': 26022, 'offset_end': 26139, 'content': 'function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyTreasuryManager', 'start_line': 747, 'end_line': 752, 'offset_start': 26145, 'offset_end': 26322, 'content': 'function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyNotPaused', 'start_line': 753, 'end_line': 755, 'offset_start': 26328, 'offset_end': 26427, 'content': 'function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0xf6d1b85af155229acd7b523601148585a1ff67c6/0xf6d1b85af155229acd7b523601148585a1ff67c6.sol'}
