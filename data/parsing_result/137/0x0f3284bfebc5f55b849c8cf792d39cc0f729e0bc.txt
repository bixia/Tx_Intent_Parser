{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 4, 'end_line': 6, 'offset_start': 58, 'offset_end': 170, 'content': 'function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 7, 'end_line': 11, 'offset_start': 176, 'offset_end': 486, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 12, 'end_line': 14, 'offset_start': 492, 'offset_end': 676, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 15, 'end_line': 21, 'offset_start': 682, 'offset_end': 904, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 22, 'end_line': 24, 'offset_start': 910, 'offset_end': 1133, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 25, 'end_line': 34, 'offset_start': 1139, 'offset_end': 1584, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 35, 'end_line': 37, 'offset_start': 1590, 'offset_end': 1786, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 38, 'end_line': 45, 'offset_start': 1792, 'offset_end': 2117, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 46, 'end_line': 48, 'offset_start': 2123, 'offset_end': 2320, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 49, 'end_line': 56, 'offset_start': 2326, 'offset_end': 2650, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 57, 'end_line': 71, 'offset_start': 2656, 'offset_end': 3118, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 72, 'end_line': 82, 'offset_start': 3124, 'offset_end': 3418, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 83, 'end_line': 92, 'offset_start': 3424, 'offset_end': 3766, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 127, 'end_line': 133, 'offset_start': 4873, 'offset_end': 5152, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 134, 'end_line': 136, 'offset_start': 5158, 'offset_end': 5257, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 137, 'end_line': 139, 'offset_start': 5263, 'offset_end': 5355, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 143, 'end_line': 144, 'offset_start': 5443, 'offset_end': 5501, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 145, 'end_line': 146, 'offset_start': 5507, 'offset_end': 5575, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 147, 'end_line': 149, 'offset_start': 5581, 'offset_end': 5676, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 150, 'end_line': 152, 'offset_start': 5682, 'offset_end': 5780, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 153, 'end_line': 155, 'offset_start': 5786, 'offset_end': 5882, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 162, 'end_line': 164, 'offset_start': 6138, 'offset_end': 6232, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 165, 'end_line': 167, 'offset_start': 6238, 'offset_end': 6348, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 172, 'end_line': 174, 'offset_start': 6421, 'offset_end': 6505, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 175, 'end_line': 177, 'offset_start': 6511, 'offset_end': 6640, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 178, 'end_line': 180, 'offset_start': 6646, 'offset_end': 6746, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 181, 'end_line': 184, 'offset_start': 6752, 'offset_end': 6949, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 185, 'end_line': 189, 'offset_start': 6955, 'offset_end': 7141, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822ProxiableUpgradeable.proxiableUUID', 'start_line': 194, 'end_line': 194, 'offset_start': 7245, 'offset_end': 7301, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822ProxiableUpgradeable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeaconUpgradeable.implementation', 'start_line': 204, 'end_line': 204, 'offset_start': 7589, 'offset_end': 7646, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeaconUpgradeable', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getAddressSlot', 'start_line': 226, 'end_line': 230, 'offset_start': 8026, 'offset_end': 8172, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBooleanSlot', 'start_line': 231, 'end_line': 235, 'offset_start': 8178, 'offset_end': 8324, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytes32Slot', 'start_line': 236, 'end_line': 240, 'offset_start': 8330, 'offset_end': 8476, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getUint256Slot', 'start_line': 241, 'end_line': 245, 'offset_start': 8482, 'offset_end': 8628, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 246, 'end_line': 250, 'offset_start': 8634, 'offset_end': 8778, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 251, 'end_line': 255, 'offset_start': 8784, 'offset_end': 8942, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 256, 'end_line': 260, 'offset_start': 8948, 'offset_end': 9090, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 261, 'end_line': 265, 'offset_start': 9096, 'offset_end': 9251, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init', 'start_line': 271, 'end_line': 272, 'offset_start': 9602, 'offset_end': 9667, 'content': 'function __ERC1967Upgrade_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init_unchained', 'start_line': 273, 'end_line': 274, 'offset_start': 9673, 'offset_end': 9748, 'content': 'function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getImplementation', 'start_line': 275, 'end_line': 277, 'offset_start': 9754, 'offset_end': 9904, 'content': 'function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setImplementation', 'start_line': 278, 'end_line': 281, 'offset_start': 9910, 'offset_end': 10190, 'content': 'function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeTo', 'start_line': 282, 'end_line': 285, 'offset_start': 10196, 'offset_end': 10347, 'content': 'function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCall', 'start_line': 286, 'end_line': 291, 'offset_start': 10353, 'offset_end': 10628, 'content': 'function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCallUUPS', 'start_line': 292, 'end_line': 303, 'offset_start': 10634, 'offset_end': 11277, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getAdmin', 'start_line': 305, 'end_line': 307, 'offset_start': 11395, 'offset_end': 11527, 'content': 'function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setAdmin', 'start_line': 308, 'end_line': 311, 'offset_start': 11533, 'offset_end': 11744, 'content': 'function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._changeAdmin', 'start_line': 312, 'end_line': 315, 'offset_start': 11750, 'offset_end': 11884, 'content': 'function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getBeacon', 'start_line': 317, 'end_line': 319, 'offset_start': 12003, 'offset_end': 12137, 'content': 'function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setBeacon', 'start_line': 320, 'end_line': 327, 'offset_start': 12143, 'offset_end': 12557, 'content': 'function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeBeaconToAndCall', 'start_line': 328, 'end_line': 334, 'offset_start': 12563, 'offset_end': 12897, 'content': 'function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 349, 'end_line': 350, 'offset_start': 13504, 'offset_end': 13570, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 351, 'end_line': 352, 'offset_start': 13576, 'offset_end': 13652, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 353, 'end_line': 355, 'offset_start': 13658, 'offset_end': 13788, 'content': 'function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeTo', 'start_line': 356, 'end_line': 359, 'offset_start': 13794, 'offset_end': 13988, 'content': 'function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 360, 'end_line': 363, 'offset_start': 13994, 'offset_end': 14213, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 364, 'end_line': 364, 'offset_start': 14219, 'offset_end': 14289, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165Upgradeable.supportsInterface', 'start_line': 369, 'end_line': 369, 'offset_start': 14383, 'offset_end': 14458, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165Upgradeable', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.balanceOf', 'start_line': 376, 'end_line': 376, 'offset_start': 14814, 'offset_end': 14887, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.ownerOf', 'start_line': 377, 'end_line': 377, 'offset_start': 14893, 'offset_end': 14964, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.safeTransferFrom', 'start_line': 378, 'end_line': 378, 'offset_start': 14970, 'offset_end': 15068, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.safeTransferFrom', 'start_line': 379, 'end_line': 379, 'offset_start': 15074, 'offset_end': 15151, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.transferFrom', 'start_line': 380, 'end_line': 380, 'offset_start': 15157, 'offset_end': 15230, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.approve', 'start_line': 381, 'end_line': 381, 'offset_start': 15236, 'offset_end': 15290, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.setApprovalForAll', 'start_line': 382, 'end_line': 382, 'offset_start': 15296, 'offset_end': 15364, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.getApproved', 'start_line': 383, 'end_line': 383, 'offset_start': 15370, 'offset_end': 15448, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.isApprovedForAll', 'start_line': 384, 'end_line': 384, 'offset_start': 15454, 'offset_end': 15541, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.name', 'start_line': 388, 'end_line': 388, 'offset_start': 15634, 'offset_end': 15687, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.symbol', 'start_line': 389, 'end_line': 389, 'offset_start': 15693, 'offset_end': 15748, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.tokenURI', 'start_line': 390, 'end_line': 390, 'offset_start': 15754, 'offset_end': 15826, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721ReceiverUpgradeable.onERC721Received', 'start_line': 394, 'end_line': 399, 'offset_start': 15897, 'offset_end': 16056, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721ReceiverUpgradeable', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 403, 'end_line': 404, 'offset_start': 16163, 'offset_end': 16220, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 405, 'end_line': 406, 'offset_start': 16226, 'offset_end': 16293, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 407, 'end_line': 409, 'offset_start': 16299, 'offset_end': 16464, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.max', 'start_line': 419, 'end_line': 421, 'offset_start': 16621, 'offset_end': 16724, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.min', 'start_line': 422, 'end_line': 424, 'offset_start': 16730, 'offset_end': 16833, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.average', 'start_line': 425, 'end_line': 427, 'offset_start': 16839, 'offset_end': 16954, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.ceilDiv', 'start_line': 428, 'end_line': 430, 'offset_start': 16960, 'offset_end': 17082, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 431, 'end_line': 467, 'offset_start': 17088, 'offset_end': 18549, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 468, 'end_line': 474, 'offset_start': 18555, 'offset_end': 18853, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 475, 'end_line': 490, 'offset_start': 18859, 'offset_end': 19439, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 491, 'end_line': 496, 'offset_start': 19445, 'offset_end': 19681, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 497, 'end_line': 533, 'offset_start': 19687, 'offset_end': 20669, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 534, 'end_line': 539, 'offset_start': 20675, 'offset_end': 20919, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 540, 'end_line': 572, 'offset_start': 20925, 'offset_end': 21840, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 573, 'end_line': 578, 'offset_start': 21846, 'offset_end': 22093, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 579, 'end_line': 603, 'offset_start': 22099, 'offset_end': 22761, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 604, 'end_line': 609, 'offset_start': 22767, 'offset_end': 23022, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.max', 'start_line': 613, 'end_line': 615, 'offset_start': 23086, 'offset_end': 23186, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.min', 'start_line': 616, 'end_line': 618, 'offset_start': 23192, 'offset_end': 23292, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.average', 'start_line': 619, 'end_line': 622, 'offset_start': 23298, 'offset_end': 23475, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.abs', 'start_line': 623, 'end_line': 627, 'offset_start': 23481, 'offset_end': 23617, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 633, 'end_line': 651, 'offset_start': 23787, 'offset_end': 24395, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 652, 'end_line': 654, 'offset_start': 24401, 'offset_end': 24584, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 655, 'end_line': 659, 'offset_start': 24590, 'offset_end': 24774, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 660, 'end_line': 670, 'offset_start': 24780, 'offset_end': 25216, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 671, 'end_line': 673, 'offset_start': 25222, 'offset_end': 25370, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.equal', 'start_line': 674, 'end_line': 676, 'offset_start': 25376, 'offset_end': 25519, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 688, 'end_line': 690, 'offset_start': 26056, 'offset_end': 26204, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 691, 'end_line': 694, 'offset_start': 26210, 'offset_end': 26369, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 695, 'end_line': 700, 'offset_start': 26375, 'offset_end': 26718, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 701, 'end_line': 704, 'offset_start': 26724, 'offset_end': 26927, 'content': 'function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 705, 'end_line': 709, 'offset_start': 26933, 'offset_end': 27151, 'content': 'function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 710, 'end_line': 712, 'offset_start': 27157, 'offset_end': 27254, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 713, 'end_line': 715, 'offset_start': 27260, 'offset_end': 27361, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 716, 'end_line': 720, 'offset_start': 27367, 'offset_end': 27641, 'content': 'function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 721, 'end_line': 723, 'offset_start': 27647, 'offset_end': 27738, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 724, 'end_line': 732, 'offset_start': 27744, 'offset_end': 28158, 'content': 'function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 733, 'end_line': 736, 'offset_start': 28164, 'offset_end': 28329, 'content': 'function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 737, 'end_line': 739, 'offset_start': 28335, 'offset_end': 28487, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 740, 'end_line': 742, 'offset_start': 28493, 'offset_end': 28654, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 743, 'end_line': 746, 'offset_start': 28660, 'offset_end': 28902, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 747, 'end_line': 749, 'offset_start': 28908, 'offset_end': 29056, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 750, 'end_line': 753, 'offset_start': 29062, 'offset_end': 29337, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 754, 'end_line': 757, 'offset_start': 29343, 'offset_end': 29609, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 758, 'end_line': 760, 'offset_start': 29615, 'offset_end': 29729, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._exists', 'start_line': 761, 'end_line': 763, 'offset_start': 29735, 'offset_end': 29860, 'content': 'function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isApprovedOrOwner', 'start_line': 764, 'end_line': 767, 'offset_start': 29866, 'offset_end': 30137, 'content': 'function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 768, 'end_line': 770, 'offset_start': 30143, 'offset_end': 30250, 'content': 'function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 771, 'end_line': 777, 'offset_start': 30256, 'offset_end': 30534, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 778, 'end_line': 789, 'offset_start': 30540, 'offset_end': 31070, 'content': 'function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 790, 'end_line': 801, 'offset_start': 31076, 'offset_end': 31554, 'content': 'function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 802, 'end_line': 815, 'offset_start': 31560, 'offset_end': 32237, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 816, 'end_line': 819, 'offset_start': 32243, 'offset_end': 32424, 'content': 'function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 820, 'end_line': 824, 'offset_start': 32430, 'offset_end': 32706, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireMinted', 'start_line': 825, 'end_line': 827, 'offset_start': 32712, 'offset_end': 32844, 'content': 'function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 828, 'end_line': 849, 'offset_start': 32850, 'offset_end': 33647, 'content': 'function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._beforeTokenTransfer', 'start_line': 850, 'end_line': 850, 'offset_start': 33653, 'offset_end': 33768, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._afterTokenTransfer', 'start_line': 851, 'end_line': 851, 'offset_start': 33774, 'offset_end': 33888, 'content': 'function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__unsafe_increaseBalance', 'start_line': 852, 'end_line': 854, 'offset_start': 33894, 'offset_end': 34014, 'content': 'function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.tor', 'start_line': 872, 'end_line': 874, 'offset_start': 34525, 'offset_end': 34577, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.initialize', 'start_line': 875, 'end_line': 880, 'offset_start': 34583, 'offset_end': 34774, 'content': 'function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge._authorizeUpgrade', 'start_line': 881, 'end_line': 881, 'offset_start': 34780, 'offset_end': 34863, 'content': 'function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.setURI', 'start_line': 882, 'end_line': 889, 'offset_start': 34869, 'offset_end': 35123, 'content': 'function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.tokenURI', 'start_line': 890, 'end_line': 896, 'offset_start': 35129, 'offset_end': 35334, 'content': 'function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.premiumMint', 'start_line': 897, 'end_line': 912, 'offset_start': 35340, 'offset_end': 35849, 'content': 'function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.basicMint', 'start_line': 913, 'end_line': 921, 'offset_start': 35855, 'offset_end': 36262, 'content': 'function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.claimKey', 'start_line': 922, 'end_line': 925, 'offset_start': 36268, 'offset_end': 36397, 'content': 'function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge._beforeTokenTransfer', 'start_line': 926, 'end_line': 932, 'offset_start': 36403, 'offset_end': 36728, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.burn', 'start_line': 933, 'end_line': 936, 'offset_start': 36734, 'offset_end': 36914, 'content': 'function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
{'type': 'FunctionDefinition', 'name': 'Matr1xPioneerBadge.totalSupply', 'start_line': 937, 'end_line': 939, 'offset_start': 36920, 'offset_end': 37020, 'content': 'function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }', 'contract_name': 'Matr1xPioneerBadge', 'contract_code': '{\n    uint256 private _nextTokenId;\n    string private _premiumUri;\n    string private _basicUri;\n    bool public status;\n    uint256 private _premiumMintNum;\n    uint256 public totalKeyNum;\n    mapping(address => bool) private _basicMinted;\n    event PioneerBadge(string eventId, uint256 tokenId, address by, uint256 eventTime);\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC721_init("Matr1x Pioneer Badge", "PIONEER");\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        _nextTokenId = 1;\n    }\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}\n    function setURI(uint256 badgeType, string memory uri) external onlyOwner {\n        require(bytes(uri).length > 0, "Wrong base uri");\n        if (badgeType == 1) {\n            _premiumUri = uri;\n        } else {\n            _basicUri = uri;\n        }\n    }\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenId <= 800) {\n            return _premiumUri;\n        } else {\n            return _basicUri;\n        }\n    }\n    function premiumMint(address to, uint256 num) external onlyOwner {\n        require(_premiumMintNum + num <= 800, "Max limit.");\n        uint256 _tmpTokenId = _nextTokenId;\n        for (uint256 i = 0; i < num;) {\n            uint256 tokenId = _tmpTokenId++;\n            _safeMint(to, tokenId);\n            unchecked {\n                ++i;\n            }\n        }\n        _nextTokenId = _tmpTokenId;\n        _premiumMintNum += num;\n        if (_premiumMintNum == 800) {\n            status = true;\n        }\n    }\n    function basicMint() external {\n        require(status, "Basic badge not open.");\n        address _msgSender = _msgSender();\n        require(_basicMinted[_msgSender] == false, "You have bean minted.");\n        _basicMinted[_msgSender] = true;\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(_msgSender, tokenId);\n        emit PioneerBadge("basicMint", tokenId, msg.sender, block.timestamp);\n    }\n    function claimKey() external {\n        totalKeyNum++;\n        emit PioneerBadge("claimKey", 0, msg.sender, block.timestamp);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override\n    {\n        require(!(from != address(0) && to != address(0) && tokenId > 800), "Only the Premium Badge can be transferred.");\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    function burn(uint256 tokenId) external {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved.");\n        _burn(tokenId);\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        return _nextTokenId - 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc/0x0f3284bfebc5f55b849c8cf792d39cc0f729e0bc.sol'}
