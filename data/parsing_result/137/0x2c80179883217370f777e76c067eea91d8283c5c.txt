{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 8, 'end_line': 26, 'offset_start': 214, 'offset_end': 811, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 27, 'end_line': 29, 'offset_start': 817, 'offset_end': 989, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 30, 'end_line': 34, 'offset_start': 995, 'offset_end': 1168, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 35, 'end_line': 45, 'offset_start': 1174, 'offset_end': 1610, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 46, 'end_line': 48, 'offset_start': 1616, 'offset_end': 1764, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 49, 'end_line': 51, 'offset_start': 1770, 'offset_end': 1913, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReadonCurateV3.getPickData', 'start_line': 82, 'end_line': 84, 'offset_start': 3134, 'offset_end': 3260, 'content': 'function getPickData(uint256 tokenId)external view returns (PickInfo memory pickInfo) {\n        return pickData[tokenId];\n    }', 'contract_name': 'ReadonCurateV3', 'contract_code': '{\n    event Curate(\n        address indexed curator,\n        uint64 indexed contentUrl\n    );\n    struct PickInfo {\n        uint256 contentId;\n        string points;\n        string rate;\n    }\n    using ECDSA for bytes32;\n    address private signer;\n    mapping(uint256 => PickInfo) private pickData;\n    function getPickData(uint256 tokenId)external view returns (PickInfo memory pickInfo) {\n        return pickData[tokenId];\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "https:\n    }\n    function initialize() public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function curate(uint64 contentUrl) public {\n        emit Curate(msg.sender, contentUrl);\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n    function safeMint(uint256 tokenId,uint256 contentId,string memory points,string memory rate,string memory p4, bytes memory signature)\n        public\n    {\n        require(verifySignature(p4,signature),"ReadON:invalid signature");\n        _safeMint(msg.sender, tokenId);\n        pickData[tokenId] = PickInfo(contentId,points,rate);\n    }\n    function verifySignature(string memory message, bytes memory signature) internal view returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(message));\n        bytes32 prefixedHash = messageHash.toEthSignedMessageHash();\n        address recoveredSigner = prefixedHash.recover(signature);\n        return (recoveredSigner == signer);\n    }\n    function getSigner() external view returns (address) {\n        return signer;\n    }\n    function setSigner(address _signer) public onlyOwner {\n        signer = _signer;\n    }\n    function name() public pure override returns (string memory) {\n        return "Pick";\n    }\n    function symbol() public pure override returns (string memory) {\n        return "Pick";\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReadonCurateV3._baseURI', 'start_line': 85, 'end_line': 128, 'offset_start': 3266, 'offset_end': 4826, 'content': 'function _baseURI() internal pure override returns (string memory) {\n        return "https:\n    }\n    function initialize() public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function curate(uint64 contentUrl) public {\n        emit Curate(msg.sender, contentUrl);\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n    function safeMint(uint256 tokenId,uint256 contentId,string memory points,string memory rate,string memory p4, bytes memory signature)\n        public\n    {\n        require(verifySignature(p4,signature),"ReadON:invalid signature");\n        _safeMint(msg.sender, tokenId);\n        pickData[tokenId] = PickInfo(contentId,points,rate);\n    }\n    function verifySignature(string memory message, bytes memory signature) internal view returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(message));\n        bytes32 prefixedHash = messageHash.toEthSignedMessageHash();\n        address recoveredSigner = prefixedHash.recover(signature);\n        return (recoveredSigner == signer);\n    }\n    function getSigner() external view returns (address) {\n        return signer;\n    }\n    function setSigner(address _signer) public onlyOwner {\n        signer = _signer;\n    }\n    function name() public pure override returns (string memory) {\n        return "Pick";\n    }\n    function symbol() public pure override returns (string memory) {\n        return "Pick";\n    }\n}', 'contract_name': 'ReadonCurateV3', 'contract_code': '{\n    event Curate(\n        address indexed curator,\n        uint64 indexed contentUrl\n    );\n    struct PickInfo {\n        uint256 contentId;\n        string points;\n        string rate;\n    }\n    using ECDSA for bytes32;\n    address private signer;\n    mapping(uint256 => PickInfo) private pickData;\n    function getPickData(uint256 tokenId)external view returns (PickInfo memory pickInfo) {\n        return pickData[tokenId];\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "https:\n    }\n    function initialize() public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function curate(uint64 contentUrl) public {\n        emit Curate(msg.sender, contentUrl);\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n    function safeMint(uint256 tokenId,uint256 contentId,string memory points,string memory rate,string memory p4, bytes memory signature)\n        public\n    {\n        require(verifySignature(p4,signature),"ReadON:invalid signature");\n        _safeMint(msg.sender, tokenId);\n        pickData[tokenId] = PickInfo(contentId,points,rate);\n    }\n    function verifySignature(string memory message, bytes memory signature) internal view returns (bool) {\n        bytes32 messageHash = keccak256(abi.encodePacked(message));\n        bytes32 prefixedHash = messageHash.toEthSignedMessageHash();\n        address recoveredSigner = prefixedHash.recover(signature);\n        return (recoveredSigner == signer);\n    }\n    function getSigner() external view returns (address) {\n        return signer;\n    }\n    function setSigner(address _signer) public onlyOwner {\n        signer = _signer;\n    }\n    function name() public pure override returns (string memory) {\n        return "Pick";\n    }\n    function symbol() public pure override returns (string memory) {\n        return "Pick";\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 131, 'end_line': 133, 'offset_start': 4877, 'offset_end': 4977, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 134, 'end_line': 136, 'offset_start': 4983, 'offset_end': 5083, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 137, 'end_line': 140, 'offset_start': 5089, 'offset_end': 5266, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 141, 'end_line': 145, 'offset_start': 5272, 'offset_end': 5408, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 157, 'end_line': 167, 'offset_start': 5640, 'offset_end': 6127, 'content': 'function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 168, 'end_line': 182, 'offset_start': 6133, 'offset_end': 6684, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 183, 'end_line': 187, 'offset_start': 6690, 'offset_end': 6916, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 188, 'end_line': 192, 'offset_start': 6922, 'offset_end': 7227, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 193, 'end_line': 197, 'offset_start': 7233, 'offset_end': 7454, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 198, 'end_line': 207, 'offset_start': 7460, 'offset_end': 7955, 'content': 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 208, 'end_line': 212, 'offset_start': 7961, 'offset_end': 8192, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 213, 'end_line': 219, 'offset_start': 8198, 'offset_end': 8456, 'content': 'function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 220, 'end_line': 222, 'offset_start': 8462, 'offset_end': 8657, 'content': 'function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toTypedDataHash', 'start_line': 223, 'end_line': 231, 'offset_start': 8663, 'offset_end': 9016, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toDataWithIntendedValidatorHash', 'start_line': 232, 'end_line': 234, 'offset_start': 9022, 'offset_end': 9212, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 270, 'end_line': 276, 'offset_start': 10364, 'offset_end': 10643, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 277, 'end_line': 279, 'offset_start': 10649, 'offset_end': 10748, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 280, 'end_line': 282, 'offset_start': 10754, 'offset_end': 10846, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.max', 'start_line': 291, 'end_line': 293, 'offset_start': 10972, 'offset_end': 11075, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.min', 'start_line': 294, 'end_line': 296, 'offset_start': 11081, 'offset_end': 11184, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.average', 'start_line': 297, 'end_line': 299, 'offset_start': 11190, 'offset_end': 11305, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.ceilDiv', 'start_line': 300, 'end_line': 302, 'offset_start': 11311, 'offset_end': 11433, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 303, 'end_line': 339, 'offset_start': 11439, 'offset_end': 12900, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 340, 'end_line': 346, 'offset_start': 12906, 'offset_end': 13204, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 347, 'end_line': 362, 'offset_start': 13210, 'offset_end': 13790, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 363, 'end_line': 368, 'offset_start': 13796, 'offset_end': 14032, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 369, 'end_line': 405, 'offset_start': 14038, 'offset_end': 15020, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 406, 'end_line': 411, 'offset_start': 15026, 'offset_end': 15270, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 412, 'end_line': 444, 'offset_start': 15276, 'offset_end': 16191, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 445, 'end_line': 450, 'offset_start': 16197, 'offset_end': 16444, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 451, 'end_line': 475, 'offset_start': 16450, 'offset_end': 17112, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 476, 'end_line': 481, 'offset_start': 17118, 'offset_end': 17373, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165Upgradeable.supportsInterface', 'start_line': 485, 'end_line': 485, 'offset_start': 17436, 'offset_end': 17511, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165Upgradeable', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.max', 'start_line': 489, 'end_line': 491, 'offset_start': 17575, 'offset_end': 17675, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.min', 'start_line': 492, 'end_line': 494, 'offset_start': 17681, 'offset_end': 17781, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.average', 'start_line': 495, 'end_line': 498, 'offset_start': 17787, 'offset_end': 17964, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.abs', 'start_line': 499, 'end_line': 503, 'offset_start': 17970, 'offset_end': 18106, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 510, 'end_line': 511, 'offset_start': 18386, 'offset_end': 18452, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 512, 'end_line': 513, 'offset_start': 18458, 'offset_end': 18534, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 524, 'end_line': 526, 'offset_start': 18974, 'offset_end': 19104, 'content': 'function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeTo', 'start_line': 527, 'end_line': 530, 'offset_start': 19110, 'offset_end': 19304, 'content': 'function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 531, 'end_line': 534, 'offset_start': 19310, 'offset_end': 19529, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 535, 'end_line': 535, 'offset_start': 19535, 'offset_end': 19605, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 548, 'end_line': 548, 'offset_start': 20083, 'offset_end': 20137, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 549, 'end_line': 549, 'offset_start': 20143, 'offset_end': 20210, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 550, 'end_line': 550, 'offset_start': 20216, 'offset_end': 20285, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 551, 'end_line': 551, 'offset_start': 20291, 'offset_end': 20373, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 552, 'end_line': 552, 'offset_start': 20379, 'offset_end': 20452, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 553, 'end_line': 553, 'offset_start': 20458, 'offset_end': 20545, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 573, 'end_line': 575, 'offset_start': 21453, 'offset_end': 21601, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 576, 'end_line': 579, 'offset_start': 21607, 'offset_end': 21766, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 580, 'end_line': 585, 'offset_start': 21772, 'offset_end': 22115, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 586, 'end_line': 589, 'offset_start': 22121, 'offset_end': 22324, 'content': 'function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 590, 'end_line': 594, 'offset_start': 22330, 'offset_end': 22548, 'content': 'function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 595, 'end_line': 597, 'offset_start': 22554, 'offset_end': 22651, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 598, 'end_line': 600, 'offset_start': 22657, 'offset_end': 22758, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 601, 'end_line': 605, 'offset_start': 22764, 'offset_end': 23038, 'content': 'function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 606, 'end_line': 608, 'offset_start': 23044, 'offset_end': 23135, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 609, 'end_line': 617, 'offset_start': 23141, 'offset_end': 23555, 'content': 'function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 618, 'end_line': 621, 'offset_start': 23561, 'offset_end': 23726, 'content': 'function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 622, 'end_line': 624, 'offset_start': 23732, 'offset_end': 23884, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 625, 'end_line': 627, 'offset_start': 23890, 'offset_end': 24051, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 628, 'end_line': 631, 'offset_start': 24057, 'offset_end': 24299, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 632, 'end_line': 634, 'offset_start': 24305, 'offset_end': 24453, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 635, 'end_line': 638, 'offset_start': 24459, 'offset_end': 24734, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 639, 'end_line': 642, 'offset_start': 24740, 'offset_end': 25006, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 643, 'end_line': 645, 'offset_start': 25012, 'offset_end': 25126, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._exists', 'start_line': 646, 'end_line': 648, 'offset_start': 25132, 'offset_end': 25257, 'content': 'function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isApprovedOrOwner', 'start_line': 649, 'end_line': 652, 'offset_start': 25263, 'offset_end': 25534, 'content': 'function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 653, 'end_line': 655, 'offset_start': 25540, 'offset_end': 25647, 'content': 'function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 656, 'end_line': 662, 'offset_start': 25653, 'offset_end': 25931, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 663, 'end_line': 674, 'offset_start': 25937, 'offset_end': 26467, 'content': 'function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 675, 'end_line': 686, 'offset_start': 26473, 'offset_end': 26951, 'content': 'function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 687, 'end_line': 700, 'offset_start': 26957, 'offset_end': 27634, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 701, 'end_line': 704, 'offset_start': 27640, 'offset_end': 27821, 'content': 'function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 705, 'end_line': 709, 'offset_start': 27827, 'offset_end': 28103, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireMinted', 'start_line': 710, 'end_line': 712, 'offset_start': 28109, 'offset_end': 28241, 'content': 'function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 713, 'end_line': 734, 'offset_start': 28247, 'offset_end': 29044, 'content': 'function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._beforeTokenTransfer', 'start_line': 735, 'end_line': 735, 'offset_start': 29050, 'offset_end': 29165, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._afterTokenTransfer', 'start_line': 736, 'end_line': 736, 'offset_start': 29171, 'offset_end': 29285, 'content': 'function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__unsafe_increaseBalance', 'start_line': 737, 'end_line': 739, 'offset_start': 29291, 'offset_end': 29411, 'content': 'function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n        require(!_exists(tokenId), "ERC721: token already minted");\n        unchecked {\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n        emit Transfer(owner, address(0), tokenId);\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n        _beforeTokenTransfer(from, to, tokenId, 1);\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        delete _tokenApprovals[tokenId];\n        unchecked {\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n    uint256[44] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 748, 'end_line': 750, 'offset_start': 29752, 'offset_end': 29846, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 751, 'end_line': 753, 'offset_start': 29852, 'offset_end': 29962, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 758, 'end_line': 760, 'offset_start': 30035, 'offset_end': 30119, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 761, 'end_line': 763, 'offset_start': 30125, 'offset_end': 30254, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 764, 'end_line': 766, 'offset_start': 30260, 'offset_end': 30360, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 767, 'end_line': 770, 'offset_start': 30366, 'offset_end': 30563, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 771, 'end_line': 775, 'offset_start': 30569, 'offset_end': 30755, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 781, 'end_line': 782, 'offset_start': 30917, 'offset_end': 30975, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 783, 'end_line': 784, 'offset_start': 30981, 'offset_end': 31049, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 785, 'end_line': 787, 'offset_start': 31055, 'offset_end': 31150, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 788, 'end_line': 790, 'offset_start': 31156, 'offset_end': 31254, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721ReceiverUpgradeable.onERC721Received', 'start_line': 795, 'end_line': 800, 'offset_start': 31356, 'offset_end': 31515, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721ReceiverUpgradeable', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.balanceOf', 'start_line': 808, 'end_line': 808, 'offset_start': 31930, 'offset_end': 32003, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.ownerOf', 'start_line': 809, 'end_line': 809, 'offset_start': 32009, 'offset_end': 32080, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.safeTransferFrom', 'start_line': 810, 'end_line': 810, 'offset_start': 32086, 'offset_end': 32184, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.safeTransferFrom', 'start_line': 811, 'end_line': 811, 'offset_start': 32190, 'offset_end': 32267, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.transferFrom', 'start_line': 812, 'end_line': 812, 'offset_start': 32273, 'offset_end': 32346, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.approve', 'start_line': 813, 'end_line': 813, 'offset_start': 32352, 'offset_end': 32406, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.setApprovalForAll', 'start_line': 814, 'end_line': 814, 'offset_start': 32412, 'offset_end': 32480, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.getApproved', 'start_line': 815, 'end_line': 815, 'offset_start': 32486, 'offset_end': 32564, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Upgradeable.isApprovedForAll', 'start_line': 816, 'end_line': 816, 'offset_start': 32570, 'offset_end': 32657, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.name', 'start_line': 821, 'end_line': 821, 'offset_start': 32786, 'offset_end': 32839, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.symbol', 'start_line': 822, 'end_line': 822, 'offset_start': 32845, 'offset_end': 32900, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721MetadataUpgradeable.tokenURI', 'start_line': 823, 'end_line': 823, 'offset_start': 32906, 'offset_end': 32978, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822ProxiableUpgradeable.proxiableUUID', 'start_line': 827, 'end_line': 827, 'offset_start': 33051, 'offset_end': 33107, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822ProxiableUpgradeable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 833, 'end_line': 834, 'offset_start': 33295, 'offset_end': 33352, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 835, 'end_line': 836, 'offset_start': 33358, 'offset_end': 33425, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 837, 'end_line': 839, 'offset_start': 33431, 'offset_end': 33596, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 848, 'end_line': 866, 'offset_start': 33877, 'offset_end': 34485, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 867, 'end_line': 869, 'offset_start': 34491, 'offset_end': 34674, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 870, 'end_line': 874, 'offset_start': 34680, 'offset_end': 34864, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 875, 'end_line': 885, 'offset_start': 34870, 'offset_end': 35306, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 886, 'end_line': 888, 'offset_start': 35312, 'offset_end': 35460, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.equal', 'start_line': 889, 'end_line': 891, 'offset_start': 35466, 'offset_end': 35609, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 900, 'end_line': 902, 'offset_start': 35724, 'offset_end': 35827, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 903, 'end_line': 905, 'offset_start': 35833, 'offset_end': 35936, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 906, 'end_line': 908, 'offset_start': 35942, 'offset_end': 36057, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 909, 'end_line': 911, 'offset_start': 36063, 'offset_end': 36185, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 912, 'end_line': 948, 'offset_start': 36191, 'offset_end': 37652, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 949, 'end_line': 955, 'offset_start': 37658, 'offset_end': 37956, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 956, 'end_line': 971, 'offset_start': 37962, 'offset_end': 38542, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 972, 'end_line': 977, 'offset_start': 38548, 'offset_end': 38784, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 978, 'end_line': 1014, 'offset_start': 38790, 'offset_end': 39772, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1015, 'end_line': 1020, 'offset_start': 39778, 'offset_end': 40022, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1021, 'end_line': 1053, 'offset_start': 40028, 'offset_end': 40943, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1054, 'end_line': 1059, 'offset_start': 40949, 'offset_end': 41196, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1060, 'end_line': 1084, 'offset_start': 41202, 'offset_end': 41864, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1085, 'end_line': 1090, 'offset_start': 41870, 'offset_end': 42125, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.__ERC721Burnable_init', 'start_line': 1097, 'end_line': 1098, 'offset_start': 42391, 'offset_end': 42456, 'content': 'function __ERC721Burnable_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _burn(tokenId);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.__ERC721Burnable_init_unchained', 'start_line': 1099, 'end_line': 1100, 'offset_start': 42462, 'offset_end': 42537, 'content': 'function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _burn(tokenId);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.burn', 'start_line': 1101, 'end_line': 1104, 'offset_start': 42543, 'offset_end': 42728, 'content': 'function burn(uint256 tokenId) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _burn(tokenId);\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _burn(tokenId);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init', 'start_line': 1115, 'end_line': 1116, 'offset_start': 43157, 'offset_end': 43222, 'content': 'function __ERC1967Upgrade_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init_unchained', 'start_line': 1117, 'end_line': 1118, 'offset_start': 43228, 'offset_end': 43303, 'content': 'function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getImplementation', 'start_line': 1121, 'end_line': 1123, 'offset_start': 43544, 'offset_end': 43694, 'content': 'function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setImplementation', 'start_line': 1124, 'end_line': 1127, 'offset_start': 43700, 'offset_end': 43980, 'content': 'function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeTo', 'start_line': 1128, 'end_line': 1131, 'offset_start': 43986, 'offset_end': 44137, 'content': 'function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCall', 'start_line': 1132, 'end_line': 1137, 'offset_start': 44143, 'offset_end': 44418, 'content': 'function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCallUUPS', 'start_line': 1138, 'end_line': 1149, 'offset_start': 44424, 'offset_end': 45067, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getAdmin', 'start_line': 1151, 'end_line': 1153, 'offset_start': 45185, 'offset_end': 45317, 'content': 'function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setAdmin', 'start_line': 1154, 'end_line': 1157, 'offset_start': 45323, 'offset_end': 45534, 'content': 'function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._changeAdmin', 'start_line': 1158, 'end_line': 1161, 'offset_start': 45540, 'offset_end': 45674, 'content': 'function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getBeacon', 'start_line': 1163, 'end_line': 1165, 'offset_start': 45793, 'offset_end': 45927, 'content': 'function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setBeacon', 'start_line': 1166, 'end_line': 1173, 'offset_start': 45933, 'offset_end': 46347, 'content': 'function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeBeaconToAndCall', 'start_line': 1174, 'end_line': 1180, 'offset_start': 46353, 'offset_end': 46687, 'content': 'function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeaconUpgradeable.implementation', 'start_line': 1185, 'end_line': 1185, 'offset_start': 46781, 'offset_end': 46838, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeaconUpgradeable', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 1189, 'end_line': 1191, 'offset_start': 46899, 'offset_end': 47011, 'content': 'function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 1192, 'end_line': 1196, 'offset_start': 47017, 'offset_end': 47327, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1197, 'end_line': 1199, 'offset_start': 47333, 'offset_end': 47517, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 1200, 'end_line': 1206, 'offset_start': 47523, 'offset_end': 47745, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1207, 'end_line': 1209, 'offset_start': 47751, 'offset_end': 47974, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 1210, 'end_line': 1219, 'offset_start': 47980, 'offset_end': 48425, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1220, 'end_line': 1222, 'offset_start': 48431, 'offset_end': 48627, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 1223, 'end_line': 1230, 'offset_start': 48633, 'offset_end': 48958, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1231, 'end_line': 1233, 'offset_start': 48964, 'offset_end': 49161, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 1234, 'end_line': 1241, 'offset_start': 49167, 'offset_end': 49491, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 1242, 'end_line': 1256, 'offset_start': 49497, 'offset_end': 49959, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 1257, 'end_line': 1267, 'offset_start': 49965, 'offset_end': 50259, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 1268, 'end_line': 1277, 'offset_start': 50265, 'offset_end': 50607, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getAddressSlot', 'start_line': 1299, 'end_line': 1303, 'offset_start': 50987, 'offset_end': 51133, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBooleanSlot', 'start_line': 1304, 'end_line': 1308, 'offset_start': 51139, 'offset_end': 51285, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytes32Slot', 'start_line': 1309, 'end_line': 1313, 'offset_start': 51291, 'offset_end': 51437, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getUint256Slot', 'start_line': 1314, 'end_line': 1318, 'offset_start': 51443, 'offset_end': 51589, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 1319, 'end_line': 1323, 'offset_start': 51595, 'offset_end': 51739, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 1324, 'end_line': 1328, 'offset_start': 51745, 'offset_end': 51903, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 1329, 'end_line': 1333, 'offset_start': 51909, 'offset_end': 52051, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 1334, 'end_line': 1338, 'offset_start': 52057, 'offset_end': 52212, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1346, 'end_line': 1348, 'offset_start': 52470, 'offset_end': 52580, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1349, 'end_line': 1351, 'offset_start': 52586, 'offset_end': 52694, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1357, 'end_line': 1360, 'offset_start': 52808, 'offset_end': 52954, 'content': 'function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1361, 'end_line': 1363, 'offset_start': 52960, 'offset_end': 53036, 'content': 'function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1364, 'end_line': 1366, 'offset_start': 53042, 'offset_end': 53148, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n        _status = _ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = _NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/137/0x2c80179883217370f777e76c067eea91d8283c5c/0x2c80179883217370f777e76c067eea91d8283c5c.sol'}
