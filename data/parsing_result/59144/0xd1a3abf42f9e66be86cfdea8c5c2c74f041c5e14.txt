{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getAddressSlot', 'start_line': 22, 'end_line': 26, 'offset_start': 377, 'offset_end': 523, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBooleanSlot', 'start_line': 27, 'end_line': 31, 'offset_start': 529, 'offset_end': 675, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytes32Slot', 'start_line': 32, 'end_line': 36, 'offset_start': 681, 'offset_end': 827, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getUint256Slot', 'start_line': 37, 'end_line': 41, 'offset_start': 833, 'offset_end': 979, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 42, 'end_line': 46, 'offset_start': 985, 'offset_end': 1129, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getStringSlot', 'start_line': 47, 'end_line': 51, 'offset_start': 1135, 'offset_end': 1293, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 52, 'end_line': 56, 'offset_start': 1299, 'offset_end': 1441, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlotUpgradeable.getBytesSlot', 'start_line': 57, 'end_line': 61, 'offset_start': 1447, 'offset_end': 1602, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlotUpgradeable', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeaconUpgradeable.implementation', 'start_line': 71, 'end_line': 71, 'offset_start': 1890, 'offset_end': 1947, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeaconUpgradeable', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822ProxiableUpgradeable.proxiableUUID', 'start_line': 75, 'end_line': 75, 'offset_start': 2020, 'offset_end': 2076, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822ProxiableUpgradeable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 79, 'end_line': 81, 'offset_start': 2137, 'offset_end': 2249, 'content': 'function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 82, 'end_line': 86, 'offset_start': 2255, 'offset_end': 2565, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 87, 'end_line': 89, 'offset_start': 2571, 'offset_end': 2755, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 90, 'end_line': 96, 'offset_start': 2761, 'offset_end': 2983, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 97, 'end_line': 99, 'offset_start': 2989, 'offset_end': 3212, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 100, 'end_line': 109, 'offset_start': 3218, 'offset_end': 3663, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 110, 'end_line': 112, 'offset_start': 3669, 'offset_end': 3865, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 113, 'end_line': 120, 'offset_start': 3871, 'offset_end': 4196, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 121, 'end_line': 123, 'offset_start': 4202, 'offset_end': 4399, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 124, 'end_line': 131, 'offset_start': 4405, 'offset_end': 4729, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 132, 'end_line': 146, 'offset_start': 4735, 'offset_end': 5197, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 147, 'end_line': 157, 'offset_start': 5203, 'offset_end': 5497, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 158, 'end_line': 167, 'offset_start': 5503, 'offset_end': 5845, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 202, 'end_line': 208, 'offset_start': 6952, 'offset_end': 7231, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 209, 'end_line': 211, 'offset_start': 7237, 'offset_end': 7336, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 212, 'end_line': 214, 'offset_start': 7342, 'offset_end': 7434, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init', 'start_line': 218, 'end_line': 219, 'offset_start': 7550, 'offset_end': 7615, 'content': 'function __ERC1967Upgrade_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable.__ERC1967Upgrade_init_unchained', 'start_line': 220, 'end_line': 221, 'offset_start': 7621, 'offset_end': 7696, 'content': 'function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getImplementation', 'start_line': 224, 'end_line': 226, 'offset_start': 7937, 'offset_end': 8087, 'content': 'function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setImplementation', 'start_line': 227, 'end_line': 230, 'offset_start': 8093, 'offset_end': 8373, 'content': 'function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeTo', 'start_line': 231, 'end_line': 234, 'offset_start': 8379, 'offset_end': 8530, 'content': 'function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCall', 'start_line': 235, 'end_line': 240, 'offset_start': 8536, 'offset_end': 8811, 'content': 'function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeToAndCallUUPS', 'start_line': 241, 'end_line': 252, 'offset_start': 8817, 'offset_end': 9460, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getAdmin', 'start_line': 254, 'end_line': 256, 'offset_start': 9578, 'offset_end': 9710, 'content': 'function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setAdmin', 'start_line': 257, 'end_line': 260, 'offset_start': 9716, 'offset_end': 9927, 'content': 'function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._changeAdmin', 'start_line': 261, 'end_line': 264, 'offset_start': 9933, 'offset_end': 10067, 'content': 'function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._getBeacon', 'start_line': 266, 'end_line': 268, 'offset_start': 10186, 'offset_end': 10320, 'content': 'function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._setBeacon', 'start_line': 269, 'end_line': 276, 'offset_start': 10326, 'offset_end': 10740, 'content': 'function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967UpgradeUpgradeable._upgradeBeaconToAndCall', 'start_line': 277, 'end_line': 283, 'offset_start': 10746, 'offset_end': 11080, 'content': 'function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }', 'contract_name': 'ERC1967UpgradeUpgradeable', 'contract_code': '{\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 288, 'end_line': 289, 'offset_start': 11253, 'offset_end': 11319, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 290, 'end_line': 291, 'offset_start': 11325, 'offset_end': 11401, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 302, 'end_line': 304, 'offset_start': 11841, 'offset_end': 11971, 'content': 'function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeTo', 'start_line': 305, 'end_line': 308, 'offset_start': 11977, 'offset_end': 12171, 'content': 'function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 309, 'end_line': 312, 'offset_start': 12177, 'offset_end': 12396, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 313, 'end_line': 313, 'offset_start': 12402, 'offset_end': 12472, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    address private immutable __self = address(this);\n    modifier onlyProxy() {\n        require(address(this) != __self, "Function must be called through delegatecall");\n        require(_getImplementation() == __self, "Function must be called through active proxy");\n        _;\n    }\n    modifier notDelegated() {\n        require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");\n        _;\n    }\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 318, 'end_line': 319, 'offset_start': 12591, 'offset_end': 12649, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 320, 'end_line': 321, 'offset_start': 12655, 'offset_end': 12723, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 322, 'end_line': 324, 'offset_start': 12729, 'offset_end': 12824, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 325, 'end_line': 327, 'offset_start': 12830, 'offset_end': 12928, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 334, 'end_line': 336, 'offset_start': 13184, 'offset_end': 13278, 'content': 'function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 337, 'end_line': 339, 'offset_start': 13284, 'offset_end': 13394, 'content': 'function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 344, 'end_line': 346, 'offset_start': 13467, 'offset_end': 13551, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 347, 'end_line': 349, 'offset_start': 13557, 'offset_end': 13686, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 350, 'end_line': 352, 'offset_start': 13692, 'offset_end': 13792, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 353, 'end_line': 356, 'offset_start': 13798, 'offset_end': 13995, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 357, 'end_line': 361, 'offset_start': 14001, 'offset_end': 14187, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 369, 'end_line': 371, 'offset_start': 14425, 'offset_end': 14521, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 372, 'end_line': 374, 'offset_start': 14527, 'offset_end': 14621, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 383, 'end_line': 385, 'offset_start': 14775, 'offset_end': 14858, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 386, 'end_line': 388, 'offset_start': 14864, 'offset_end': 14969, 'content': 'function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 389, 'end_line': 391, 'offset_start': 14975, 'offset_end': 15080, 'content': 'function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 392, 'end_line': 395, 'offset_start': 15086, 'offset_end': 15200, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 396, 'end_line': 399, 'offset_start': 15206, 'offset_end': 15322, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 406, 'end_line': 406, 'offset_start': 15575, 'offset_end': 15629, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 407, 'end_line': 407, 'offset_start': 15635, 'offset_end': 15702, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 408, 'end_line': 408, 'offset_start': 15708, 'offset_end': 15777, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 409, 'end_line': 409, 'offset_start': 15783, 'offset_end': 15865, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 410, 'end_line': 410, 'offset_start': 15871, 'offset_end': 15944, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 411, 'end_line': 411, 'offset_start': 15950, 'offset_end': 16037, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.name', 'start_line': 415, 'end_line': 415, 'offset_start': 16128, 'offset_end': 16181, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.symbol', 'start_line': 416, 'end_line': 416, 'offset_start': 16187, 'offset_end': 16242, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.decimals', 'start_line': 417, 'end_line': 417, 'offset_start': 16248, 'offset_end': 16297, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.__ERC20_init', 'start_line': 426, 'end_line': 428, 'offset_start': 16652, 'offset_end': 16798, 'content': 'function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.__ERC20_init_unchained', 'start_line': 429, 'end_line': 432, 'offset_start': 16804, 'offset_end': 16962, 'content': 'function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.name', 'start_line': 433, 'end_line': 435, 'offset_start': 16968, 'offset_end': 17065, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.symbol', 'start_line': 436, 'end_line': 438, 'offset_start': 17071, 'offset_end': 17172, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.decimals', 'start_line': 439, 'end_line': 441, 'offset_start': 17178, 'offset_end': 17268, 'content': 'function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.totalSupply', 'start_line': 442, 'end_line': 444, 'offset_start': 17274, 'offset_end': 17379, 'content': 'function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.balanceOf', 'start_line': 445, 'end_line': 447, 'offset_start': 17385, 'offset_end': 17509, 'content': 'function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.transfer', 'start_line': 448, 'end_line': 452, 'offset_start': 17515, 'offset_end': 17703, 'content': 'function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.allowance', 'start_line': 453, 'end_line': 455, 'offset_start': 17709, 'offset_end': 17857, 'content': 'function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.approve', 'start_line': 456, 'end_line': 460, 'offset_start': 17863, 'offset_end': 18059, 'content': 'function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.transferFrom', 'start_line': 461, 'end_line': 466, 'offset_start': 18065, 'offset_end': 18320, 'content': 'function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.increaseAllowance', 'start_line': 467, 'end_line': 471, 'offset_start': 18326, 'offset_end': 18559, 'content': 'function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.decreaseAllowance', 'start_line': 472, 'end_line': 480, 'offset_start': 18565, 'offset_end': 18990, 'content': 'function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._transfer', 'start_line': 481, 'end_line': 493, 'offset_start': 18996, 'offset_end': 19616, 'content': 'function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._mint', 'start_line': 494, 'end_line': 503, 'offset_start': 19622, 'offset_end': 20041, 'content': 'function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._burn', 'start_line': 504, 'end_line': 515, 'offset_start': 20047, 'offset_end': 20622, 'content': 'function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._approve', 'start_line': 516, 'end_line': 521, 'offset_start': 20628, 'offset_end': 20966, 'content': 'function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._spendAllowance', 'start_line': 522, 'end_line': 530, 'offset_start': 20972, 'offset_end': 21382, 'content': 'function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._beforeTokenTransfer', 'start_line': 531, 'end_line': 531, 'offset_start': 21388, 'offset_end': 21478, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._afterTokenTransfer', 'start_line': 532, 'end_line': 532, 'offset_start': 21484, 'offset_end': 21573, 'content': 'function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20BurnableUpgradeable.__ERC20Burnable_init', 'start_line': 537, 'end_line': 538, 'offset_start': 21736, 'offset_end': 21800, 'content': 'function __ERC20Burnable_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC20BurnableUpgradeable', 'contract_code': '{\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20BurnableUpgradeable.__ERC20Burnable_init_unchained', 'start_line': 539, 'end_line': 540, 'offset_start': 21806, 'offset_end': 21880, 'content': 'function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC20BurnableUpgradeable', 'contract_code': '{\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20BurnableUpgradeable.burn', 'start_line': 541, 'end_line': 543, 'offset_start': 21886, 'offset_end': 21974, 'content': 'function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }', 'contract_name': 'ERC20BurnableUpgradeable', 'contract_code': '{\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20BurnableUpgradeable.burnFrom', 'start_line': 544, 'end_line': 547, 'offset_start': 21980, 'offset_end': 22140, 'content': 'function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }', 'contract_name': 'ERC20BurnableUpgradeable', 'contract_code': '{\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.tor', 'start_line': 557, 'end_line': 559, 'offset_start': 22451, 'offset_end': 22503, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.initialize', 'start_line': 560, 'end_line': 566, 'offset_start': 22509, 'offset_end': 22724, 'content': 'function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.pause', 'start_line': 567, 'end_line': 569, 'offset_start': 22730, 'offset_end': 22788, 'content': 'function pause() public onlyOwner {\n        _pause();\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.unpause', 'start_line': 570, 'end_line': 572, 'offset_start': 22794, 'offset_end': 22856, 'content': 'function unpause() public onlyOwner {\n        _unpause();\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.mint', 'start_line': 573, 'end_line': 575, 'offset_start': 22862, 'offset_end': 22954, 'content': 'function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail.send_mail', 'start_line': 576, 'end_line': 579, 'offset_start': 22960, 'offset_end': 23106, 'content': 'function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail._beforeTokenTransfer', 'start_line': 580, 'end_line': 586, 'offset_start': 23112, 'offset_end': 23304, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
{'type': 'FunctionDefinition', 'name': 'Dmail._authorizeUpgrade', 'start_line': 587, 'end_line': 591, 'offset_start': 23310, 'offset_end': 23421, 'content': 'function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}', 'contract_name': 'Dmail', 'contract_code': '{\n    event Message(\n        address indexed from,\n        string indexed to,\n        string indexed path\n    );\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize() initializer public {\n        __ERC20_init("Dmail Mail Token", "DMT");\n        __ERC20Burnable_init();\n        __Pausable_init();\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n    function send_mail(string memory to, string memory path) public  {\n        address owner = _msgSender();\n        emit Message(owner,to,path);\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        onlyOwner\n        override\n    {}\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14/0xd1a3abf42f9e66be86cfdea8c5c2c74f041c5e14.sol'}
