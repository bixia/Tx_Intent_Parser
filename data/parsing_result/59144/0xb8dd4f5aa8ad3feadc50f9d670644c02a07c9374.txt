{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.__ERC721Burnable_init', 'start_line': 7, 'end_line': 8, 'offset_start': 336, 'offset_end': 401, 'content': 'function __ERC721Burnable_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        _update(address(0), tokenId, _msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.__ERC721Burnable_init_unchained', 'start_line': 9, 'end_line': 10, 'offset_start': 407, 'offset_end': 482, 'content': 'function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        _update(address(0), tokenId, _msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721BurnableUpgradeable.burn', 'start_line': 11, 'end_line': 13, 'offset_start': 488, 'offset_end': 592, 'content': 'function burn(uint256 tokenId) public virtual {\n        _update(address(0), tokenId, _msgSender());\n    }', 'contract_name': 'ERC721BurnableUpgradeable', 'contract_code': '{\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(uint256 tokenId) public virtual {\n        _update(address(0), tokenId, _msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 59, 'end_line': 63, 'offset_start': 2106, 'offset_end': 2246, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 64, 'end_line': 73, 'offset_start': 2252, 'offset_end': 2616, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 74, 'end_line': 76, 'offset_start': 2622, 'offset_end': 2749, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 77, 'end_line': 79, 'offset_start': 2755, 'offset_end': 2874, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 80, 'end_line': 84, 'offset_start': 2880, 'offset_end': 3049, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 91, 'end_line': 91, 'offset_start': 3239, 'offset_end': 3292, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 92, 'end_line': 92, 'offset_start': 3298, 'offset_end': 3353, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 93, 'end_line': 93, 'offset_start': 3359, 'offset_end': 3431, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 97, 'end_line': 99, 'offset_start': 3485, 'offset_end': 3585, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 100, 'end_line': 102, 'offset_start': 3591, 'offset_end': 3691, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 103, 'end_line': 106, 'offset_start': 3697, 'offset_end': 3874, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 107, 'end_line': 111, 'offset_start': 3880, 'offset_end': 4016, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 122, 'end_line': 128, 'offset_start': 4187, 'offset_end': 4402, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 129, 'end_line': 134, 'offset_start': 4408, 'offset_end': 4596, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 135, 'end_line': 142, 'offset_start': 4602, 'offset_end': 4864, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 143, 'end_line': 148, 'offset_start': 4870, 'offset_end': 5059, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 149, 'end_line': 154, 'offset_start': 5065, 'offset_end': 5254, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 155, 'end_line': 157, 'offset_start': 5260, 'offset_end': 5363, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 158, 'end_line': 160, 'offset_start': 5369, 'offset_end': 5472, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 161, 'end_line': 163, 'offset_start': 5478, 'offset_end': 5593, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 164, 'end_line': 169, 'offset_start': 5599, 'offset_end': 5779, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 170, 'end_line': 207, 'offset_start': 5785, 'offset_end': 7252, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 208, 'end_line': 214, 'offset_start': 7258, 'offset_end': 7559, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 215, 'end_line': 230, 'offset_start': 7565, 'offset_end': 8145, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 231, 'end_line': 236, 'offset_start': 8151, 'offset_end': 8390, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 237, 'end_line': 273, 'offset_start': 8396, 'offset_end': 9378, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 274, 'end_line': 279, 'offset_start': 9384, 'offset_end': 9631, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 280, 'end_line': 312, 'offset_start': 9637, 'offset_end': 10552, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 313, 'end_line': 318, 'offset_start': 10558, 'offset_end': 10808, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 319, 'end_line': 343, 'offset_start': 10814, 'offset_end': 11476, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 344, 'end_line': 349, 'offset_start': 11482, 'offset_end': 11740, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 350, 'end_line': 352, 'offset_start': 11746, 'offset_end': 11867, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._getERC721EnumerableStorage', 'start_line': 367, 'end_line': 371, 'offset_start': 12729, 'offset_end': 12914, 'content': 'function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.__ERC721Enumerable_init', 'start_line': 374, 'end_line': 375, 'offset_start': 13032, 'offset_end': 13099, 'content': 'function __ERC721Enumerable_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.__ERC721Enumerable_init_unchained', 'start_line': 376, 'end_line': 377, 'offset_start': 13105, 'offset_end': 13182, 'content': 'function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.supportsInterface', 'start_line': 378, 'end_line': 380, 'offset_start': 13188, 'offset_end': 13420, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.tokenOfOwnerByIndex', 'start_line': 381, 'end_line': 387, 'offset_start': 13426, 'offset_end': 13757, 'content': 'function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.totalSupply', 'start_line': 388, 'end_line': 391, 'offset_start': 13763, 'offset_end': 13941, 'content': 'function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable.tokenByIndex', 'start_line': 392, 'end_line': 398, 'offset_start': 13947, 'offset_end': 14249, 'content': 'function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._update', 'start_line': 399, 'end_line': 412, 'offset_start': 14255, 'offset_end': 14877, 'content': 'function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._addTokenToOwnerEnumeration', 'start_line': 413, 'end_line': 418, 'offset_start': 14883, 'offset_end': 15175, 'content': 'function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._addTokenToAllTokensEnumeration', 'start_line': 419, 'end_line': 423, 'offset_start': 15181, 'offset_end': 15422, 'content': 'function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._removeTokenFromOwnerEnumeration', 'start_line': 424, 'end_line': 435, 'offset_start': 15428, 'offset_end': 16044, 'content': 'function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._removeTokenFromAllTokensEnumeration', 'start_line': 436, 'end_line': 445, 'offset_start': 16050, 'offset_end': 16551, 'content': 'function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721EnumerableUpgradeable._increaseBalance', 'start_line': 446, 'end_line': 451, 'offset_start': 16557, 'offset_end': 16790, 'content': 'function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }', 'contract_name': 'ERC721EnumerableUpgradeable', 'contract_code': '{\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n    error ERC721EnumerableForbiddenBatchMint();\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n        return previousOwner;\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = $._ownedTokens[from][lastTokenIndex];\n            $._ownedTokens[from][tokenIndex] = lastTokenId; \n            $._ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n        delete $._ownedTokensIndex[tokenId];\n        delete $._ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n        $._allTokens[tokenIndex] = lastTokenId; \n        $._allTokensIndex[lastTokenId] = tokenIndex; \n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721PausableUpgradeable.__ERC721Pausable_init', 'start_line': 458, 'end_line': 460, 'offset_start': 17132, 'offset_end': 17234, 'content': 'function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'ERC721PausableUpgradeable', 'contract_code': '{\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721PausableUpgradeable.__ERC721Pausable_init_unchained', 'start_line': 461, 'end_line': 462, 'offset_start': 17240, 'offset_end': 17315, 'content': 'function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721PausableUpgradeable', 'contract_code': '{\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721PausableUpgradeable._update', 'start_line': 463, 'end_line': 469, 'offset_start': 17321, 'offset_end': 17524, 'content': 'function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }', 'contract_name': 'ERC721PausableUpgradeable', 'contract_code': '{\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC2981.royaltyInfo', 'start_line': 474, 'end_line': 477, 'offset_start': 17649, 'offset_end': 17791, 'content': 'function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);', 'contract_name': 'IERC2981', 'contract_code': '{\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getERC721Storage', 'start_line': 500, 'end_line': 504, 'offset_start': 19164, 'offset_end': 19319, 'content': 'function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 505, 'end_line': 507, 'offset_start': 19325, 'offset_end': 19473, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 508, 'end_line': 512, 'offset_start': 19479, 'offset_end': 19697, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 513, 'end_line': 518, 'offset_start': 19703, 'offset_end': 20013, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 519, 'end_line': 525, 'offset_start': 20019, 'offset_end': 20283, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 526, 'end_line': 528, 'offset_start': 20289, 'offset_end': 20406, 'content': 'function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 529, 'end_line': 532, 'offset_start': 20412, 'offset_end': 20557, 'content': 'function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 533, 'end_line': 536, 'offset_start': 20563, 'offset_end': 20712, 'content': 'function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 537, 'end_line': 541, 'offset_start': 20718, 'offset_end': 20971, 'content': 'function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 542, 'end_line': 544, 'offset_start': 20977, 'offset_end': 21068, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 545, 'end_line': 547, 'offset_start': 21074, 'offset_end': 21186, 'content': 'function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 548, 'end_line': 551, 'offset_start': 21192, 'offset_end': 21344, 'content': 'function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 552, 'end_line': 554, 'offset_start': 21350, 'offset_end': 21493, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 555, 'end_line': 558, 'offset_start': 21499, 'offset_end': 21708, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 559, 'end_line': 567, 'offset_start': 21714, 'offset_end': 22082, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 568, 'end_line': 570, 'offset_start': 22088, 'offset_end': 22219, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 571, 'end_line': 574, 'offset_start': 22225, 'offset_end': 22432, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 575, 'end_line': 578, 'offset_start': 22438, 'offset_end': 22609, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getApproved', 'start_line': 579, 'end_line': 582, 'offset_start': 22615, 'offset_end': 22798, 'content': 'function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isAuthorized', 'start_line': 583, 'end_line': 587, 'offset_start': 22804, 'offset_end': 23075, 'content': 'function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkAuthorized', 'start_line': 588, 'end_line': 596, 'offset_start': 23081, 'offset_end': 23448, 'content': 'function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._increaseBalance', 'start_line': 597, 'end_line': 602, 'offset_start': 23454, 'offset_end': 23663, 'content': 'function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._update', 'start_line': 603, 'end_line': 623, 'offset_start': 23669, 'offset_end': 24360, 'content': 'function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 624, 'end_line': 632, 'offset_start': 24366, 'offset_end': 24692, 'content': 'function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 633, 'end_line': 635, 'offset_start': 24698, 'offset_end': 24797, 'content': 'function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 636, 'end_line': 639, 'offset_start': 24803, 'offset_end': 24984, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 640, 'end_line': 645, 'offset_start': 24990, 'offset_end': 25216, 'content': 'function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 646, 'end_line': 656, 'offset_start': 25222, 'offset_end': 25681, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 657, 'end_line': 659, 'offset_start': 25687, 'offset_end': 25814, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 660, 'end_line': 663, 'offset_start': 25820, 'offset_end': 26023, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 664, 'end_line': 666, 'offset_start': 26029, 'offset_end': 26148, 'content': 'function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 667, 'end_line': 679, 'offset_start': 26154, 'offset_end': 26708, 'content': 'function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 680, 'end_line': 687, 'offset_start': 26714, 'offset_end': 27082, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireOwned', 'start_line': 688, 'end_line': 694, 'offset_start': 27088, 'offset_end': 27328, 'content': 'function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 695, 'end_line': 711, 'offset_start': 27334, 'offset_end': 28060, 'content': 'function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 745, 'end_line': 745, 'offset_start': 29584, 'offset_end': 29659, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.tor', 'start_line': 769, 'end_line': 771, 'offset_start': 30782, 'offset_end': 30834, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.initialize', 'start_line': 772, 'end_line': 786, 'offset_start': 30840, 'offset_end': 31300, 'content': 'function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.pause', 'start_line': 787, 'end_line': 789, 'offset_start': 31306, 'offset_end': 31364, 'content': 'function pause() public onlyOwner {\n        _pause();\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.unpause', 'start_line': 790, 'end_line': 792, 'offset_start': 31370, 'offset_end': 31432, 'content': 'function unpause() public onlyOwner {\n        _unpause();\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.setContractURI', 'start_line': 793, 'end_line': 795, 'offset_start': 31438, 'offset_end': 31535, 'content': 'function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.safeMint', 'start_line': 796, 'end_line': 802, 'offset_start': 31541, 'offset_end': 31842, 'content': 'function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.setMintPrice', 'start_line': 803, 'end_line': 805, 'offset_start': 31848, 'offset_end': 31949, 'content': 'function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection._baseURI', 'start_line': 806, 'end_line': 808, 'offset_start': 31955, 'offset_end': 32047, 'content': 'function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.withdraw', 'start_line': 809, 'end_line': 812, 'offset_start': 32053, 'offset_end': 32186, 'content': 'function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection._update', 'start_line': 813, 'end_line': 827, 'offset_start': 32192, 'offset_end': 32522, 'content': 'function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.tokenURI', 'start_line': 828, 'end_line': 837, 'offset_start': 32528, 'offset_end': 32752, 'content': 'function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.setDefaultRoyality', 'start_line': 838, 'end_line': 843, 'offset_start': 32758, 'offset_end': 32922, 'content': 'function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection._increaseBalance', 'start_line': 844, 'end_line': 853, 'offset_start': 32928, 'offset_end': 33166, 'content': 'function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ClutchGeneralCollection.supportsInterface', 'start_line': 854, 'end_line': 868, 'offset_start': 33172, 'offset_end': 33525, 'content': 'function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ClutchGeneralCollection', 'contract_code': '{\n    uint256 private _nextTokenId;\n    uint256 public mintFee;\n    string public contractURI;\n    constructor() {\n        _disableInitializers();\n    }\n    function initialize(\n        address initialOwner,\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __ERC721URIStorage_init();\n        __ERC721Pausable_init();\n        __Ownable_init(initialOwner);\n        __ERC721Royalty_init();\n        __ERC721Burnable_init();\n        setDefaultRoyality(initialOwner, 500);\n        mintFee = 0.001 ether;\n    }\n    function pause() public onlyOwner {\n        _pause();\n    }\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n    function setContractURI(string memory _uri) external onlyOwner {\n        contractURI = _uri;\n    }\n    function safeMint(address to, string memory uri) public payable {\n        require(msg.value >= mintFee, "Insufficeint funds to mint token");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n        payable(owner()).transfer(msg.value);\n    }\n    function setMintPrice(uint256 newMintPrice) external onlyOwner {\n        mintFee = newMintPrice;\n    }\n    function _baseURI() internal pure override returns (string memory) {\n        return "";\n    }\n    function withdraw() public onlyOwner {\n        uint balance = address(this).balance;\n        payable(owner()).transfer(balance);\n    }\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    )\n        internal\n        override(\n            ERC721Upgradeable,\n            ERC721PausableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (address)\n    {\n        return super._update(to, tokenId, auth);\n    }\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n    function setDefaultRoyality(\n        address reciever,\n        uint96 feeNumerator\n    ) public onlyOwner {\n        _setDefaultRoyalty(reciever, feeNumerator);\n    }\n    function _increaseBalance(\n        address account,\n        uint128 amount\n    )\n        internal\n        virtual\n        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)\n    {\n        super._increaseBalance(account, amount);\n    }\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721Upgradeable,\n            ERC721URIStorageUpgradeable,\n            ERC721RoyaltyUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._getOwnableStorage', 'start_line': 878, 'end_line': 882, 'offset_start': 33946, 'offset_end': 34104, 'content': 'function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 886, 'end_line': 888, 'offset_start': 34300, 'offset_end': 34426, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 889, 'end_line': 894, 'offset_start': 34432, 'offset_end': 34666, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 899, 'end_line': 902, 'offset_start': 34739, 'offset_end': 34882, 'content': 'function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 903, 'end_line': 907, 'offset_start': 34888, 'offset_end': 35049, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 908, 'end_line': 910, 'offset_start': 35055, 'offset_end': 35155, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 911, 'end_line': 916, 'offset_start': 35161, 'offset_end': 35375, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 917, 'end_line': 922, 'offset_start': 35381, 'offset_end': 35628, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 930, 'end_line': 930, 'offset_start': 36026, 'offset_end': 36099, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 931, 'end_line': 931, 'offset_start': 36105, 'offset_end': 36176, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 932, 'end_line': 932, 'offset_start': 36182, 'offset_end': 36280, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 933, 'end_line': 933, 'offset_start': 36286, 'offset_end': 36363, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 934, 'end_line': 934, 'offset_start': 36369, 'offset_end': 36442, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 935, 'end_line': 935, 'offset_start': 36448, 'offset_end': 36502, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 936, 'end_line': 936, 'offset_start': 36508, 'offset_end': 36576, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 937, 'end_line': 937, 'offset_start': 36582, 'offset_end': 36660, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 938, 'end_line': 938, 'offset_start': 36666, 'offset_end': 36753, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721RoyaltyUpgradeable.__ERC721Royalty_init', 'start_line': 945, 'end_line': 946, 'offset_start': 37089, 'offset_end': 37153, 'content': 'function __ERC721Royalty_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC721RoyaltyUpgradeable', 'contract_code': '{\n    function __ERC721Royalty_init() internal onlyInitializing {\n    }\n    function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721RoyaltyUpgradeable.__ERC721Royalty_init_unchained', 'start_line': 947, 'end_line': 948, 'offset_start': 37159, 'offset_end': 37233, 'content': 'function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721RoyaltyUpgradeable', 'contract_code': '{\n    function __ERC721Royalty_init() internal onlyInitializing {\n    }\n    function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721RoyaltyUpgradeable.supportsInterface', 'start_line': 949, 'end_line': 951, 'offset_start': 37239, 'offset_end': 37428, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721RoyaltyUpgradeable', 'contract_code': '{\n    function __ERC721Royalty_init() internal onlyInitializing {\n    }\n    function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 955, 'end_line': 960, 'offset_start': 37489, 'offset_end': 37648, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._getPausableStorage', 'start_line': 970, 'end_line': 974, 'offset_start': 38070, 'offset_end': 38231, 'content': 'function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init', 'start_line': 979, 'end_line': 981, 'offset_start': 38363, 'offset_end': 38459, 'content': 'function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.__Pausable_init_unchained', 'start_line': 982, 'end_line': 985, 'offset_start': 38465, 'offset_end': 38620, 'content': 'function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable.paused', 'start_line': 994, 'end_line': 997, 'offset_start': 38774, 'offset_end': 38918, 'content': 'function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requireNotPaused', 'start_line': 998, 'end_line': 1002, 'offset_start': 38924, 'offset_end': 39051, 'content': 'function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._requirePaused', 'start_line': 1003, 'end_line': 1007, 'offset_start': 39057, 'offset_end': 39182, 'content': 'function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._pause', 'start_line': 1008, 'end_line': 1012, 'offset_start': 39188, 'offset_end': 39363, 'content': 'function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'PausableUpgradeable._unpause', 'start_line': 1013, 'end_line': 1017, 'offset_start': 39369, 'offset_end': 39546, 'content': 'function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'PausableUpgradeable', 'contract_code': '{\n    struct PausableStorage {\n        bool _paused;\n    }\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 1026, 'end_line': 1044, 'offset_start': 39866, 'offset_end': 40465, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 1045, 'end_line': 1047, 'offset_start': 40471, 'offset_end': 40638, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1048, 'end_line': 1052, 'offset_start': 40644, 'offset_end': 40817, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1053, 'end_line': 1066, 'offset_start': 40823, 'offset_end': 41347, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 1067, 'end_line': 1069, 'offset_start': 41353, 'offset_end': 41500, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 1070, 'end_line': 1072, 'offset_start': 41506, 'offset_end': 41687, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Enumerable.totalSupply', 'start_line': 1077, 'end_line': 1077, 'offset_start': 41801, 'offset_end': 41855, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC721Enumerable', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Enumerable.tokenOfOwnerByIndex', 'start_line': 1078, 'end_line': 1078, 'offset_start': 41861, 'offset_end': 41951, 'content': 'function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);', 'contract_name': 'IERC721Enumerable', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Enumerable.tokenByIndex', 'start_line': 1079, 'end_line': 1079, 'offset_start': 41957, 'offset_end': 42025, 'content': 'function tokenByIndex(uint256 index) external view returns (uint256);', 'contract_name': 'IERC721Enumerable', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 1085, 'end_line': 1086, 'offset_start': 42270, 'offset_end': 42327, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 1087, 'end_line': 1088, 'offset_start': 42333, 'offset_end': 42400, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 1089, 'end_line': 1091, 'offset_start': 42406, 'offset_end': 42551, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._getERC2981Storage', 'start_line': 1115, 'end_line': 1119, 'offset_start': 43590, 'offset_end': 43748, 'content': 'function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable.__ERC2981_init', 'start_line': 1124, 'end_line': 1125, 'offset_start': 44076, 'offset_end': 44134, 'content': 'function __ERC2981_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable.__ERC2981_init_unchained', 'start_line': 1126, 'end_line': 1127, 'offset_start': 44140, 'offset_end': 44208, 'content': 'function __ERC2981_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable.supportsInterface', 'start_line': 1128, 'end_line': 1130, 'offset_start': 44214, 'offset_end': 44437, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable.royaltyInfo', 'start_line': 1131, 'end_line': 1139, 'offset_start': 44443, 'offset_end': 44919, 'content': 'function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._feeDenominator', 'start_line': 1140, 'end_line': 1142, 'offset_start': 44925, 'offset_end': 45019, 'content': 'function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._setDefaultRoyalty', 'start_line': 1143, 'end_line': 1153, 'offset_start': 45025, 'offset_end': 45535, 'content': 'function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._deleteDefaultRoyalty', 'start_line': 1154, 'end_line': 1157, 'offset_start': 45541, 'offset_end': 45692, 'content': 'function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._setTokenRoyalty', 'start_line': 1158, 'end_line': 1168, 'offset_start': 45698, 'offset_end': 46244, 'content': 'function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC2981Upgradeable._resetTokenRoyalty', 'start_line': 1169, 'end_line': 1172, 'offset_start': 46250, 'offset_end': 46420, 'content': 'function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }', 'contract_name': 'ERC2981Upgradeable', 'contract_code': '{\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n    function __ERC2981_init() internal onlyInitializing {\n    }\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo memory royalty = $._tokenRoyaltyInfo[tokenId];\n        if (royalty.receiver == address(0)) {\n            royalty = $._defaultRoyaltyInfo;\n        }\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n        return (royalty.receiver, royaltyAmount);\n    }\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable._getERC721URIStorageStorage', 'start_line': 1187, 'end_line': 1191, 'offset_start': 47230, 'offset_end': 47415, 'content': 'function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable.__ERC721URIStorage_init', 'start_line': 1192, 'end_line': 1193, 'offset_start': 47421, 'offset_end': 47488, 'content': 'function __ERC721URIStorage_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable.__ERC721URIStorage_init_unchained', 'start_line': 1194, 'end_line': 1195, 'offset_start': 47494, 'offset_end': 47571, 'content': 'function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable.supportsInterface', 'start_line': 1196, 'end_line': 1198, 'offset_start': 47577, 'offset_end': 47794, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable.tokenURI', 'start_line': 1199, 'end_line': 1211, 'offset_start': 47800, 'offset_end': 48322, 'content': 'function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721URIStorageUpgradeable._setTokenURI', 'start_line': 1212, 'end_line': 1216, 'offset_start': 48328, 'offset_end': 48571, 'content': 'function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }', 'contract_name': 'ERC721URIStorageUpgradeable', 'contract_code': '{\n    using Strings for uint256;\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n    struct ERC721URIStorageStorage {\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        _requireOwned(tokenId);\n        string memory _tokenURI = $._tokenURIs[tokenId];\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n        return super.tokenURI(tokenId);\n    }\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 1221, 'end_line': 1222, 'offset_start': 48724, 'offset_end': 48782, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 1223, 'end_line': 1224, 'offset_start': 48788, 'offset_end': 48856, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 1225, 'end_line': 1227, 'offset_start': 48862, 'offset_end': 48957, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 1228, 'end_line': 1230, 'offset_start': 48963, 'offset_end': 49061, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 1231, 'end_line': 1233, 'offset_start': 49067, 'offset_end': 49163, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374/0xb8dd4f5aa8ad3feadc50f9d670644c02a07c9374.sol'}
