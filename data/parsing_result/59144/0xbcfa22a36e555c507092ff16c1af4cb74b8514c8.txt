{'type': 'FunctionDefinition', 'name': 'LibLaunchpadStorage.getStorage', 'start_line': 84, 'end_line': 86, 'offset_start': 4940, 'offset_end': 5068, 'content': 'function getStorage() internal pure returns (Storage storage stor) {\n        assembly { stor.slot := STORAGE_ID_LAUNCHPAD }\n    }', 'contract_name': 'LibLaunchpadStorage', 'contract_code': '{\n    uint256 constant STORAGE_ID_LAUNCHPAD = 2 << 128;\n    struct Storage {\n        mapping(address => bool) administrators;\n        mapping(bytes32 => DataType.LaunchpadSlot) launchpadSlots;\n        mapping(bytes32 => DataType.AccountSlotStats) accountSlotStats;\n    }\n    function getStorage() internal pure returns (Storage storage stor) {\n        assembly { stor.slot := STORAGE_ID_LAUNCHPAD }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard.tor', 'start_line': 91, 'end_line': 96, 'offset_start': 5180, 'offset_end': 5372, 'content': 'constructor() {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        if (stor.reentrancyStatus == 0) {\n            stor.reentrancyStatus = 1;\n        }\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    constructor() {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        if (stor.reentrancyStatus == 0) {\n            stor.reentrancyStatus = 1;\n        }\n    }\n    modifier nonReentrant() {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        require(stor.reentrancyStatus == 1, "ReentrancyGuard: reentrant call");\n        stor.reentrancyStatus = 2;\n        _;\n        stor.reentrancyStatus = 1;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 109, 'end_line': 113, 'offset_start': 5843, 'offset_end': 5954, 'content': 'constructor() {\n        if (owner() == address(0)) {\n            _transferOwnership(msg.sender);\n        }\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        if (owner() == address(0)) {\n            _transferOwnership(msg.sender);\n        }\n    }\n    function owner() public view virtual returns (address) {\n        return LibOwnableStorage.getStorage().owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == msg.sender, "Ownable: caller is not the owner");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) private {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        address oldOwner = stor.owner;\n        stor.owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 114, 'end_line': 116, 'offset_start': 5960, 'offset_end': 6074, 'content': 'function owner() public view virtual returns (address) {\n        return LibOwnableStorage.getStorage().owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        if (owner() == address(0)) {\n            _transferOwnership(msg.sender);\n        }\n    }\n    function owner() public view virtual returns (address) {\n        return LibOwnableStorage.getStorage().owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == msg.sender, "Ownable: caller is not the owner");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) private {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        address oldOwner = stor.owner;\n        stor.owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 121, 'end_line': 124, 'offset_start': 6200, 'offset_end': 6397, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        if (owner() == address(0)) {\n            _transferOwnership(msg.sender);\n        }\n    }\n    function owner() public view virtual returns (address) {\n        return LibOwnableStorage.getStorage().owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == msg.sender, "Ownable: caller is not the owner");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) private {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        address oldOwner = stor.owner;\n        stor.owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 125, 'end_line': 130, 'offset_start': 6403, 'offset_end': 6669, 'content': 'function _transferOwnership(address newOwner) private {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        address oldOwner = stor.owner;\n        stor.owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        if (owner() == address(0)) {\n            _transferOwnership(msg.sender);\n        }\n    }\n    function owner() public view virtual returns (address) {\n        return LibOwnableStorage.getStorage().owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == msg.sender, "Ownable: caller is not the owner");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) private {\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\n        address oldOwner = stor.owner;\n        stor.owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LibOwnableStorage.getStorage', 'start_line': 139, 'end_line': 141, 'offset_start': 6866, 'offset_end': 6992, 'content': 'function getStorage() internal pure returns (Storage storage stor) {\n        assembly { stor.slot := STORAGE_ID_OWNABLE }\n    }', 'contract_name': 'LibOwnableStorage', 'contract_code': '{\n    uint256 constant STORAGE_ID_OWNABLE = 1 << 128;\n    struct Storage {\n        uint256 reentrancyStatus;\n        address owner;\n    }\n    function getStorage() internal pure returns (Storage storage stor) {\n        assembly { stor.slot := STORAGE_ID_OWNABLE }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.launchpadBuy', 'start_line': 152, 'end_line': 178, 'offset_start': 7380, 'offset_end': 8562, 'content': 'function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.launchpadBuys', 'start_line': 179, 'end_line': 197, 'offset_start': 8568, 'offset_end': 9448, 'content': 'function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._launchpadBuy', 'start_line': 198, 'end_line': 229, 'offset_start': 9454, 'offset_end': 11036, 'content': 'function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._getLaunchpadSlot', 'start_line': 230, 'end_line': 241, 'offset_start': 11042, 'offset_end': 11838, 'content': 'function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._getLaunchpadSlotKey', 'start_line': 242, 'end_line': 246, 'offset_start': 11844, 'offset_end': 12044, 'content': 'function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._getAccountStatKey', 'start_line': 247, 'end_line': 251, 'offset_start': 12050, 'offset_end': 12278, 'content': 'function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._transferFees', 'start_line': 252, 'end_line': 272, 'offset_start': 12284, 'offset_end': 13123, 'content': 'function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._callLaunchpadBuy', 'start_line': 273, 'end_line': 326, 'offset_start': 13129, 'offset_end': 15452, 'content': 'function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._getAlreadyBuyBty', 'start_line': 327, 'end_line': 353, 'offset_start': 15458, 'offset_end': 16485, 'content': 'function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._getCurrentPrice', 'start_line': 354, 'end_line': 366, 'offset_start': 16491, 'offset_end': 17134, 'content': 'function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._checkLaunchpadBuy', 'start_line': 367, 'end_line': 424, 'offset_start': 17140, 'offset_end': 19838, 'content': 'function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._offChainSignCheck', 'start_line': 425, 'end_line': 453, 'offset_start': 19844, 'offset_end': 20884, 'content': 'function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.isInWhiteList', 'start_line': 454, 'end_line': 472, 'offset_start': 20890, 'offset_end': 21788, 'content': 'function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.hashForWhitelist', 'start_line': 473, 'end_line': 480, 'offset_start': 21794, 'offset_end': 22058, 'content': 'function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.getLaunchpadInfo', 'start_line': 481, 'end_line': 514, 'offset_start': 22064, 'offset_end': 23393, 'content': 'function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.getLaunchpadSlotInfo', 'start_line': 515, 'end_line': 550, 'offset_start': 23399, 'offset_end': 25042, 'content': 'function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.getAlreadyBuyBty', 'start_line': 551, 'end_line': 563, 'offset_start': 25048, 'offset_end': 25583, 'content': 'function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.getAccountInfoInLaunchpad', 'start_line': 564, 'end_line': 580, 'offset_start': 25589, 'offset_end': 26079, 'content': 'function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature.getAccountInfoInLaunchpadV2', 'start_line': 581, 'end_line': 649, 'offset_start': 26085, 'offset_end': 29014, 'content': 'function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'LaunchpadFeature._checkLaunchpadBuyWithoutRevert', 'start_line': 650, 'end_line': 709, 'offset_start': 29020, 'offset_end': 31392, 'content': 'function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }', 'contract_name': 'LaunchpadFeature', 'contract_code': '{\n    function launchpadBuy(\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256[] calldata additional,\n        bytes calldata data\n    ) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        uint256 maxWhitelistBuy;\n        uint256 simulationBuy;\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM) {\n            maxWhitelistBuy = additional[DataType.BUY_ADDITIONAL_IDX_WL_MAX_BUY_NUM];\n        }\n        if (additional.length > DataType.BUY_ADDITIONAL_IDX_SIMULATION) {\n            simulationBuy = additional[DataType.BUY_ADDITIONAL_IDX_SIMULATION];\n        }\n        uint256 payableValue = _launchpadBuy(\n            launchpadId, slotId, quantity, maxWhitelistBuy, simulationBuy, data\n        );\n        require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        if (simulationBuy > DataType.SIMULATION_NONE) {\n            revert(Errors.LPAD_SIMULATE_BUY_OK);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function launchpadBuys(DataType.BuyParameter[] calldata parameters) external payable nonReentrant {\n        require(tx.origin == msg.sender, "contract call not allowed");\n        uint256 ethBalanceBefore = address(this).balance - msg.value;\n        unchecked {\n            uint256 payableValue;\n            for (uint256 i; i < parameters.length; i++) {\n                payableValue += _launchpadBuy(\n                    parameters[i].launchpadId,\n                    parameters[i].slotId,\n                    parameters[i].quantity,\n                    parameters[i].maxWhitelistBuy,\n                    DataType.SIMULATION_NONE,\n                    parameters[i].data\n                );\n            }\n            require(msg.value == payableValue, Errors.LPAD_SLOT_PAY_VALUE_NOT_ENOUGH);\n        }\n        require(address(this).balance >= ethBalanceBefore, "refund error.");\n    }\n    function _launchpadBuy(\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity,\n        uint256 maxWhitelistBuy,\n        uint256 simulationBuy,\n        bytes calldata data\n    ) internal returns(uint256) {\n        require(quantity > 0, "quantity must gt 0");\n        require(quantity < type(uint16).max, Errors.LPAD_SLOT_MAX_BUY_QTY_PER_TX_LIMIT);\n        DataType.LaunchpadSlot memory slot = _getLaunchpadSlot(launchpadId, slotId);\n        (bool success, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, msg.sender);\n        require(success, "_getAlreadyBuyBty failed");\n        if (simulationBuy < DataType.SIMULATION_NO_CHECK_PROCESS_REVERT) {\n            _checkLaunchpadBuy(slot, alreadyBuyBty, quantity, maxWhitelistBuy, data, simulationBuy);\n            if (simulationBuy == DataType.SIMULATION_CHECK_REVERT) {\n                revert(Errors.LPAD_SIMULATE_BUY_OK);\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            LibLaunchpadStorage.getStorage().launchpadSlots[key].saleQty += uint32(quantity);\n        }\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(launchpadId, slotId, msg.sender);\n            LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty += uint16(quantity);\n        }\n        uint256 currentPrice = _getCurrentPrice(slot);\n        uint256 payableValue = _transferFees(slot, quantity, currentPrice);\n        _callLaunchpadBuy(slot, quantity, currentPrice, data);\n        return payableValue;\n    }\n    function _getLaunchpadSlot(bytes4 launchpadId, uint256 slotId) internal view returns(DataType.LaunchpadSlot memory slot) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        require(slot.launchpadId == launchpadId, Errors.LPAD_INVALID_ID);\n        require(slot.enable, Errors.LPAD_NOT_ENABLE);\n        require(uint256(slot.slotId) == slotId, Errors.LPAD_SLOT_IDX_INVALID);\n        require(slot.targetContract != address(0), Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID);\n        require(slot.mintSelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        if (!slot.storeAccountQtyFlag) {\n            require(slot.queryAccountMintedQtySelector != bytes4(0), Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getLaunchpadSlotKey(bytes4 launchpadId, uint256 slotId) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(launchpadId, shl(216, and(slotId, 0xff)))\n        }\n    }\n    function _getAccountStatKey(bytes4 launchpadId, uint256 slotId, address account) internal pure returns(bytes32 key) {\n        assembly {\n            key := or(or(launchpadId, shl(216, and(slotId, 0xff))), account)\n        }\n    }\n    function _transferFees(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice) internal returns(uint256) {\n        uint256 shouldPay;\n        unchecked {\n            shouldPay = buyQty * currentPrice;\n        }\n        if (slot.paymentToken == address(0)) {\n            if (shouldPay > 0) {\n                if (slot.feeType == 0 && slot.feeReceipt != address(0)) {\n                    _transferEth(slot.feeReceipt, shouldPay);\n                }\n            }\n            return shouldPay;\n        } else {\n            if (shouldPay > 0) {\n                require(slot.feeType == 0, "feeType error");\n                require(slot.feeReceipt != address(0), "feeReceipt error");\n                _transferERC20From(slot.paymentToken, msg.sender, slot.feeReceipt, shouldPay);\n            }\n            return 0;\n        }\n    }\n    function _callLaunchpadBuy(DataType.LaunchpadSlot memory slot, uint256 buyQty, uint256 currentPrice, bytes calldata data) internal {\n        uint256 price;\n        if (slot.paymentToken == address(0) && slot.feeType != 0) {\n            price = currentPrice;\n        }\n        uint256 extraOffset;\n        if (\n            slot.whiteListModel != DataType.WhiteListModel.NONE &&\n            (slot.whiteListSaleStart == 0 || block.timestamp < slot.saleStart)\n        ) {\n            extraOffset = 65;\n        }\n        if (data.length < extraOffset) {\n            revert("extra_data error");\n        }\n        bytes4 selector = slot.mintSelector;\n        address targetContract = slot.targetContract;\n        if (slot.mintParams == 0) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x24, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                if extraLength {\n                    calldatacopy(add(ptr, 0x24), add(data.offset, extraOffset), extraLength)\n                }\n                for { let i } lt(i, buyQty) { i := add(i, 1) } {\n                    if iszero(call(gas(), targetContract, price, ptr, calldataLength, ptr, 0)) {\n                        returndatacopy(0, 0, returndatasize())\n                        revert(0, returndatasize())\n                    }\n                }\n            }\n        } else if (slot.mintParams == 1) {\n            assembly {\n                let extraLength := sub(data.length, extraOffset)\n                let calldataLength := add(0x44, extraLength)\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), caller())\n                mstore(add(ptr, 0x24), buyQty)\n                if extraLength {\n                    calldatacopy(add(ptr, 0x44), add(data.offset, extraOffset), extraLength)\n                }\n                if iszero(call(gas(), targetContract, mul(buyQty, price), ptr, calldataLength, ptr, 0)) {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        } else {\n            revert(Errors.LPAD_SLOT_ABI_NOT_FOUND);\n        }\n    }\n    function _getAlreadyBuyBty(\n        DataType.LaunchpadSlot memory slot,\n        address account\n    ) internal view returns(\n        bool success,\n        uint256 alreadyBuyBty\n    ) {\n        if (slot.storeAccountQtyFlag) {\n            bytes32 key = _getAccountStatKey(slot.launchpadId, slot.slotId, account);\n            return (true, LibLaunchpadStorage.getStorage().accountSlotStats[key].totalBuyQty);\n        } else {\n            bytes4 selector = slot.queryAccountMintedQtySelector;\n            address targetContract = slot.targetContract;\n            assembly {\n                let ptr := mload(0x40) \n                mstore(ptr, selector)\n                mstore(add(ptr, 0x04), account)\n                if staticcall(gas(), targetContract, ptr, 0x24, ptr, 0x20) {\n                    if eq(returndatasize(), 0x20) {\n                        success := 1\n                        alreadyBuyBty := mload(ptr)\n                    }\n                }\n            }\n            return (success, alreadyBuyBty);\n        }\n    }\n    function _getCurrentPrice(DataType.LaunchpadSlot memory slot) internal view returns(uint256) {\n        unchecked {\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                return slot.price * (10 ** slot.priceUint);\n            } else if (slot.whiteListSaleStart > 0) { \n                uint256 price = (block.timestamp < slot.saleStart) ? slot.pricePresale : slot.price;\n                return price * (10 ** slot.priceUint);\n            } else { \n                uint256 price = slot.price > 0 ? slot.price : slot.pricePresale;\n                return price * (10 ** slot.priceUint);\n            }\n        }\n    }\n    function _checkLaunchpadBuy(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy,\n        bytes calldata data,\n        uint256 simulateBuy\n    ) internal view {\n        unchecked {\n            if (slot.storeSaleQtyFlag) {\n                if (slot.saleQty + buyQty > uint256(slot.maxSupply)) {\n                    revert(Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY);\n                }\n            }\n            require(block.timestamp < slot.saleEnd, Errors.LPAD_SLOT_SALE_END);\n            if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n                if (block.timestamp < slot.saleStart) {\n                    if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                        revert(Errors.LPAD_SLOT_SALE_NOT_START);\n                    }\n                }\n                if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                    revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                }\n            } else {\n                if (simulateBuy == DataType.SIMULATION_CHECK_SKIP_WHITELIST_PROCESS_REVERT) {\n                    return;\n                }\n                if (slot.whiteListSaleStart > 0) { \n                    if (block.timestamp < slot.whiteListSaleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (block.timestamp < slot.saleStart) { \n                        if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                        }\n                    } else { \n                        if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                            revert(Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT);\n                        }\n                        return;\n                    }\n                } else { \n                    if (block.timestamp < slot.saleStart) {\n                        if (simulateBuy != DataType.SIMULATION_CHECK_SKIP_START_PROCESS_REVERT) {\n                            revert(Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START);\n                        }\n                    }\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        revert(Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT);\n                    }\n                }\n                require(_offChainSignCheck(slot, msg.sender, maxWhitelistBuy, data), Errors.LPAD_SLOT_ACCOUNT_NOT_IN_WHITELIST);\n            }\n        }\n    }\n    function _offChainSignCheck(\n        DataType.LaunchpadSlot memory slot,\n        address account,\n        uint256 maxBuyNum,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signature.length >= 65) {\n            if (slot.signer == address(0)) {\n                return false;\n            }\n            uint256 slotId = uint256(slot.slotId);\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    "\\x19Ethereum Signed Message:\\n32",\n                    keccak256(abi.encodePacked(account, address(this), slot.launchpadId, slotId, maxBuyNum))\n                )\n            );\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := calldataload(signature.offset)\n                s := calldataload(add(signature.offset, 0x20))\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\n            }\n            return (ecrecover(hash, v, r, s) == slot.signer);\n        }\n        return false;\n    }\n    function isInWhiteList(\n        bytes4 launchpadId,\n        uint256 slotId,\n        address[] calldata accounts,\n        uint256[] calldata offChainMaxBuy,\n        bytes[] calldata offChainSign\n    ) external view returns (uint8[] memory wln) {\n        wln = new uint8[](accounts.length);\n        if (offChainSign.length > 0) {\n            require(accounts.length == offChainMaxBuy.length && accounts.length == offChainSign.length, Errors.LPAD_INPUT_ARRAY_LEN_NOT_MATCH);\n            bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n            DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n            for (uint256 i; i < accounts.length; i++) {\n                if (_offChainSignCheck(slot, accounts[0], offChainMaxBuy[i], offChainSign[i])) {\n                    wln[i] = uint8(offChainMaxBuy[i]);\n                }\n            }\n        }\n    }\n    function hashForWhitelist(\n        address account,\n        bytes4 launchpadId,\n        uint256 slot,\n        uint256 maxBuy\n    ) external view returns (bytes32) {\n        return keccak256(abi.encodePacked(account, address(this), launchpadId, slot, maxBuy));\n    }\n    function getLaunchpadInfo(bytes4 , bytes4 launchpadId, uint256[] calldata ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, 0);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        boolData = new bool[](2);\n        boolData[0] = slot.enable;\n        boolData[1] = slot.enable;\n        bytesData = new bytes[](1);\n        bytesData[0] = abi.encodePacked(slot.launchpadId);\n        addressData = new address[](3);\n        addressData[0] = address(0); \n        addressData[1] = address(this); \n        if (slot.feeType == 0) {\n            addressData[2] = slot.feeReceipt != address(0) ? slot.feeReceipt : address(this);\n        } else {\n            addressData[2] = slot.targetContract;\n        }\n        uint256 slotsNum = 1;\n        uint256 feesNum = 1;\n        intData = new uint256[](4 + feesNum + slotsNum * 2);\n        intData[0] = slotsNum;\n        intData[1] = feesNum;\n        intData[2] = 0; \n        intData[3] = 0; \n        intData[4] = 10000; \n        for (uint256 i = 5; i < intData.length; i += 2) {\n            intData[i] = slot.saleQty;\n            intData[i + 1] = 0;\n        }\n    }\n    function getLaunchpadSlotInfo(bytes4 , bytes4 launchpadId, uint256 slotId) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        address[] memory addressData,\n        bytes4[] memory bytesData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return (boolData, intData, addressData, bytesData); \n        }\n        boolData = new bool[](6);\n        boolData[0] = slot.enable; \n        boolData[1] = true; \n        intData = new uint256[](13);\n        intData[0] = uint256(slot.saleStart); \n        intData[1] = uint256(slot.whiteListModel); \n        intData[2] = uint256(slot.maxSupply); \n        intData[3] = uint256(slot.saleQty); \n        intData[4] = uint256(slot.maxBuyQtyPerAccount); \n        intData[5]  = _getCurrentPrice(slot);\n        intData[6] = 0; \n        intData[7] = 0; \n        intData[8] = 0; \n        intData[9] = uint256(slot.saleEnd); \n        intData[10] = uint256(slot.whiteListSaleStart); \n        intData[11] = uint256(slot.pricePresale * (10 ** slot.priceUint)); \n        intData[12] = uint256(slot.price * (10 ** slot.priceUint)); \n        addressData = new address[](3);\n        addressData[0] = slot.paymentToken; \n        addressData[1] = slot.targetContract; \n        addressData[2] = address(this); \n        bytesData = new bytes4[](2);\n        bytesData[0] = slot.mintSelector;\n        bytesData[1] = slot.queryAccountMintedQtySelector;\n    }\n    function getAlreadyBuyBty(\n        address account,\n        bytes4 launchpadId,\n        uint256 slotId\n    ) external view returns (uint256) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return 0;\n        }\n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        return alreadyBuyBty;\n    }\n    function getAccountInfoInLaunchpad(\n        bytes4 proxyId,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) external view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        (\n            boolData,\n            intData,\n            byteData\n        ) = getAccountInfoInLaunchpadV2(msg.sender, proxyId, launchpadId, slotId, quantity);\n        return (boolData, intData, byteData);\n    }\n    function getAccountInfoInLaunchpadV2(\n        address account,\n        bytes4 ,\n        bytes4 launchpadId,\n        uint256 slotId,\n        uint256 quantity\n    ) public view returns (\n        bool[] memory boolData,\n        uint256[] memory intData,\n        bytes[] memory byteData\n    ) {\n        bytes32 key = _getLaunchpadSlotKey(launchpadId, slotId);\n        DataType.LaunchpadSlot memory slot = LibLaunchpadStorage.getStorage().launchpadSlots[key];\n        if (launchpadId == 0 || launchpadId != slot.launchpadId || slotId != slot.slotId) {\n            return(boolData, intData, byteData); \n        }\n        boolData = new bool[](4);\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            boolData[0] = false; \n            boolData[3] = false; \n        } else {\n            boolData[0] = true; \n            boolData[3] = !(slot.whiteListSaleStart != 0 && block.timestamp >= slot.saleStart); \n        }\n        intData = new uint256[](6);\n        intData[0] = slot.saleQty; \n        intData[2] = 0; \n        intData[3] = (slot.whiteListModel == DataType.WhiteListModel.NONE) ? 0 : (quantity >> 128);\n        quantity = uint256(quantity & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); \n        (, uint256 alreadyBuyBty) = _getAlreadyBuyBty(slot, account);\n        if (boolData[3]) {\n            intData[1] = (intData[3] > alreadyBuyBty) ? (intData[3] - alreadyBuyBty) : 0;\n        } else {\n            intData[1] = uint256(slot.maxBuyQtyPerAccount) - alreadyBuyBty;\n        }\n        byteData = new bytes[](2);\n        byteData[1] = bytes("Do not support openBox");\n        if (account != address(0)) {\n            if (quantity > 0) {\n                byteData[0] = bytes(\n                    _checkLaunchpadBuyWithoutRevert(\n                        slot, alreadyBuyBty, quantity, intData[3]\n                    )\n                );\n            }\n            uint256 paymentNeeded = quantity * _getCurrentPrice(slot);\n            if (slot.paymentToken != address(0)) { \n                intData[4] = IERC20(slot.paymentToken).balanceOf(account);\n                boolData[1] = intData[4] >= paymentNeeded;\n                boolData[2] = IERC20(slot.paymentToken).allowance(account, address(this)) >= paymentNeeded;\n            } else { \n                intData[4] = account.balance;\n                boolData[1] = intData[4] > paymentNeeded;\n                boolData[2] = true;\n            }\n            if (account == slot.signer) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_SIGNER; \n            } else if (account == slot.feeReceipt) {\n                intData[5] = DataType.ROLE_LAUNCHPAD_FEE_RECEIPTS; \n            } else if (\n                account == owner() ||\n                LibLaunchpadStorage.getStorage().administrators[account]\n            ) {\n                intData[5] = DataType.ROLE_PROXY_OWNER; \n            }\n        } else {\n            byteData[0] = bytes(Errors.OK);\n        }\n    }\n    function _checkLaunchpadBuyWithoutRevert(\n        DataType.LaunchpadSlot memory slot,\n        uint256 alreadyBuyBty,\n        uint256 buyQty,\n        uint256 maxWhitelistBuy\n    ) internal view returns(string memory errCode) {\n        if (!slot.enable) {\n            return Errors.LPAD_NOT_ENABLE;\n        }\n        if (slot.targetContract == address(0)) {\n            return Errors.LPAD_SLOT_TARGET_CONTRACT_INVALID;\n        }\n        if (slot.mintSelector == bytes4(0)) {\n            return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n        }\n        if (!slot.storeAccountQtyFlag) {\n            if (slot.queryAccountMintedQtySelector == bytes4(0)) {\n                return Errors.LPAD_SLOT_ABI_NOT_FOUND;\n            }\n        }\n        if (slot.storeSaleQtyFlag) {\n            if ((slot.saleQty + buyQty) > uint256(slot.maxSupply)) {\n                return Errors.LPAD_SLOT_QTY_NOT_ENOUGH_TO_BUY;\n            }\n        }\n        if (block.timestamp >= slot.saleEnd) {\n            return Errors.LPAD_SLOT_SALE_END;\n        }\n        if (slot.whiteListModel == DataType.WhiteListModel.NONE) {\n            if (block.timestamp < slot.saleStart) {\n                return Errors.LPAD_SLOT_SALE_NOT_START;\n            }\n            if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n            }\n        } else {\n            if (slot.whiteListSaleStart > 0) { \n                if (block.timestamp < slot.whiteListSaleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (block.timestamp < slot.saleStart) {\n                    if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                        return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                    }\n                } else {\n                    if (buyQty + alreadyBuyBty > slot.maxBuyQtyPerAccount) {\n                        return Errors.LPAD_SLOT_ACCOUNT_MAX_BUY_LIMIT;\n                    }\n                }\n            } else {\n                if (block.timestamp < slot.saleStart) {\n                    return Errors.LPAD_SLOT_WHITELIST_SALE_NOT_START;\n                }\n                if (buyQty + alreadyBuyBty > maxWhitelistBuy) {\n                    return Errors.LPAD_SLOT_WHITELIST_BUY_NUM_LIMIT;\n                }\n            }\n        }\n        return Errors.OK;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 713, 'end_line': 713, 'offset_start': 31443, 'offset_end': 31497, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 714, 'end_line': 714, 'offset_start': 31503, 'offset_end': 31570, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 715, 'end_line': 715, 'offset_start': 31576, 'offset_end': 31652, 'content': 'function transfer(address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 716, 'end_line': 716, 'offset_start': 31658, 'offset_end': 31740, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 717, 'end_line': 717, 'offset_start': 31746, 'offset_end': 31819, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 718, 'end_line': 722, 'offset_start': 31825, 'offset_end': 31951, 'content': 'function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'FixinTokenSpender._transferERC20From', 'start_line': 791, 'end_line': 813, 'offset_start': 34515, 'offset_end': 35495, 'content': 'function _transferERC20From(address token, address owner, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x44), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }', 'contract_name': 'FixinTokenSpender', 'contract_code': '{\n    uint256 constant private ADDRESS_MASK = ((1 << 160) - 1);\n    function _transferERC20From(address token, address owner, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x44), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferERC20(address token, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferEth(address recipient, uint256 amount) internal {\n        assembly {\n            if amount {\n                if iszero(call(gas(), recipient, amount, 0, 0, 0, 0)) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x40, 0x0000001c5f7472616e736665724574682f5452414e534645525f4641494c4544)\n                    mstore(0x60, 0)\n                    revert(0, 0x64)\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'FixinTokenSpender._transferERC20', 'start_line': 814, 'end_line': 835, 'offset_start': 35501, 'offset_end': 36401, 'content': 'function _transferERC20(address token, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }', 'contract_name': 'FixinTokenSpender', 'contract_code': '{\n    uint256 constant private ADDRESS_MASK = ((1 << 160) - 1);\n    function _transferERC20From(address token, address owner, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x44), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferERC20(address token, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferEth(address recipient, uint256 amount) internal {\n        assembly {\n            if amount {\n                if iszero(call(gas(), recipient, amount, 0, 0, 0, 0)) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x40, 0x0000001c5f7472616e736665724574682f5452414e534645525f4641494c4544)\n                    mstore(0x60, 0)\n                    revert(0, 0x64)\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
{'type': 'FunctionDefinition', 'name': 'FixinTokenSpender._transferEth', 'start_line': 836, 'end_line': 848, 'offset_start': 36407, 'offset_end': 37008, 'content': 'function _transferEth(address recipient, uint256 amount) internal {\n        assembly {\n            if amount {\n                if iszero(call(gas(), recipient, amount, 0, 0, 0, 0)) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x40, 0x0000001c5f7472616e736665724574682f5452414e534645525f4641494c4544)\n                    mstore(0x60, 0)\n                    revert(0, 0x64)\n                }\n            }\n        }\n    }', 'contract_name': 'FixinTokenSpender', 'contract_code': '{\n    uint256 constant private ADDRESS_MASK = ((1 << 160) - 1);\n    function _transferERC20From(address token, address owner, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x44), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferERC20(address token, address to, uint256 amount) internal {\n        uint256 success;\n        assembly {\n            let ptr := mload(0x40) \n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\n            mstore(add(ptr, 0x24), amount)\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, ptr, 32)\n            let rdsize := returndatasize()\n            success := and(\n                success,                             \n                or(\n                    iszero(rdsize),                  \n                    and(\n                        iszero(lt(rdsize, 32)),      \n                        eq(mload(ptr), 1)            \n                    )\n                )\n            )\n        }\n        require(success != 0, "_transferERC20/TRANSFER_FAILED");\n    }\n    function _transferEth(address recipient, uint256 amount) internal {\n        assembly {\n            if amount {\n                if iszero(call(gas(), recipient, amount, 0, 0, 0, 0)) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\n                    mstore(0x40, 0x0000001c5f7472616e736665724574682f5452414e534645525f4641494c4544)\n                    mstore(0x60, 0)\n                    revert(0, 0x64)\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8/0xbcfa22a36e555c507092ff16c1af4cb74b8514c8.sol'}
