{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 8, 'end_line': 26, 'offset_start': 247, 'offset_end': 855, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toString', 'start_line': 27, 'end_line': 29, 'offset_start': 861, 'offset_end': 1044, 'content': 'function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 30, 'end_line': 34, 'offset_start': 1050, 'offset_end': 1234, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 35, 'end_line': 45, 'offset_start': 1240, 'offset_end': 1676, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.toHexString', 'start_line': 46, 'end_line': 48, 'offset_start': 1682, 'offset_end': 1830, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'StringsUpgradeable.equal', 'start_line': 49, 'end_line': 51, 'offset_start': 1836, 'offset_end': 1979, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'StringsUpgradeable', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMathUpgradeable.abs(value))));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 56, 'end_line': 57, 'offset_start': 2110, 'offset_end': 2168, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 58, 'end_line': 59, 'offset_start': 2174, 'offset_end': 2242, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 60, 'end_line': 62, 'offset_start': 2248, 'offset_end': 2343, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 63, 'end_line': 65, 'offset_start': 2349, 'offset_end': 2447, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267Upgradeable.eip712Domain', 'start_line': 71, 'end_line': 82, 'offset_start': 2575, 'offset_end': 2884, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267Upgradeable', 'contract_code': '{\n    event EIP712DomainChanged();\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 88, 'end_line': 89, 'offset_start': 3072, 'offset_end': 3129, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 90, 'end_line': 91, 'offset_start': 3135, 'offset_end': 3202, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 92, 'end_line': 94, 'offset_start': 3208, 'offset_end': 3373, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.max', 'start_line': 99, 'end_line': 101, 'offset_start': 3468, 'offset_end': 3568, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.min', 'start_line': 102, 'end_line': 104, 'offset_start': 3574, 'offset_end': 3674, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.average', 'start_line': 105, 'end_line': 108, 'offset_start': 3680, 'offset_end': 3857, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMathUpgradeable.abs', 'start_line': 109, 'end_line': 113, 'offset_start': 3863, 'offset_end': 3999, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMathUpgradeable', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.max', 'start_line': 122, 'end_line': 124, 'offset_start': 4125, 'offset_end': 4228, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.min', 'start_line': 125, 'end_line': 127, 'offset_start': 4234, 'offset_end': 4337, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.average', 'start_line': 128, 'end_line': 130, 'offset_start': 4343, 'offset_end': 4458, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.ceilDiv', 'start_line': 131, 'end_line': 133, 'offset_start': 4464, 'offset_end': 4586, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 134, 'end_line': 170, 'offset_start': 4592, 'offset_end': 6053, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.mulDiv', 'start_line': 171, 'end_line': 177, 'offset_start': 6059, 'offset_end': 6357, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 178, 'end_line': 193, 'offset_start': 6363, 'offset_end': 6943, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.sqrt', 'start_line': 194, 'end_line': 199, 'offset_start': 6949, 'offset_end': 7185, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 200, 'end_line': 236, 'offset_start': 7191, 'offset_end': 8173, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log2', 'start_line': 237, 'end_line': 242, 'offset_start': 8179, 'offset_end': 8423, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 243, 'end_line': 275, 'offset_start': 8429, 'offset_end': 9344, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log10', 'start_line': 276, 'end_line': 281, 'offset_start': 9350, 'offset_end': 9597, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 282, 'end_line': 306, 'offset_start': 9603, 'offset_end': 10265, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'MathUpgradeable.log256', 'start_line': 307, 'end_line': 312, 'offset_start': 10271, 'offset_end': 10526, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'MathUpgradeable', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1, "Math: mulDiv overflow");\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.__ERC20_init', 'start_line': 325, 'end_line': 327, 'offset_start': 11059, 'offset_end': 11205, 'content': 'function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.__ERC20_init_unchained', 'start_line': 328, 'end_line': 331, 'offset_start': 11211, 'offset_end': 11369, 'content': 'function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.name', 'start_line': 332, 'end_line': 334, 'offset_start': 11375, 'offset_end': 11472, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.symbol', 'start_line': 335, 'end_line': 337, 'offset_start': 11478, 'offset_end': 11579, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.decimals', 'start_line': 338, 'end_line': 340, 'offset_start': 11585, 'offset_end': 11675, 'content': 'function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.totalSupply', 'start_line': 341, 'end_line': 343, 'offset_start': 11681, 'offset_end': 11786, 'content': 'function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.balanceOf', 'start_line': 344, 'end_line': 346, 'offset_start': 11792, 'offset_end': 11916, 'content': 'function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.transfer', 'start_line': 347, 'end_line': 351, 'offset_start': 11922, 'offset_end': 12110, 'content': 'function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.allowance', 'start_line': 352, 'end_line': 354, 'offset_start': 12116, 'offset_end': 12264, 'content': 'function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.approve', 'start_line': 355, 'end_line': 359, 'offset_start': 12270, 'offset_end': 12466, 'content': 'function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.transferFrom', 'start_line': 360, 'end_line': 365, 'offset_start': 12472, 'offset_end': 12727, 'content': 'function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.increaseAllowance', 'start_line': 366, 'end_line': 370, 'offset_start': 12733, 'offset_end': 12966, 'content': 'function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable.decreaseAllowance', 'start_line': 371, 'end_line': 379, 'offset_start': 12972, 'offset_end': 13397, 'content': 'function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._transfer', 'start_line': 380, 'end_line': 392, 'offset_start': 13403, 'offset_end': 14023, 'content': 'function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._mint', 'start_line': 393, 'end_line': 402, 'offset_start': 14029, 'offset_end': 14448, 'content': 'function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._burn', 'start_line': 403, 'end_line': 414, 'offset_start': 14454, 'offset_end': 15029, 'content': 'function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._approve', 'start_line': 415, 'end_line': 420, 'offset_start': 15035, 'offset_end': 15373, 'content': 'function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._spendAllowance', 'start_line': 421, 'end_line': 429, 'offset_start': 15379, 'offset_end': 15789, 'content': 'function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._beforeTokenTransfer', 'start_line': 430, 'end_line': 430, 'offset_start': 15795, 'offset_end': 15885, 'content': 'function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Upgradeable._afterTokenTransfer', 'start_line': 431, 'end_line': 431, 'offset_start': 15891, 'offset_end': 15980, 'content': 'function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}', 'contract_name': 'ERC20Upgradeable', 'contract_code': '{\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n        return true;\n    }\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), "ERC20: transfer from the zero address");\n        require(to != address(0), "ERC20: transfer to the zero address");\n        _beforeTokenTransfer(from, to, amount);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        _afterTokenTransfer(from, to, amount);\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: mint to the zero address");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), "ERC20: burn from the zero address");\n        _beforeTokenTransfer(account, address(0), amount);\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, "ERC20: insufficient allowance");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n    uint256[45] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable._throwError', 'start_line': 444, 'end_line': 454, 'offset_start': 16265, 'offset_end': 16752, 'content': 'function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.tryRecover', 'start_line': 455, 'end_line': 469, 'offset_start': 16758, 'offset_end': 17309, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.recover', 'start_line': 470, 'end_line': 474, 'offset_start': 17315, 'offset_end': 17541, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.tryRecover', 'start_line': 475, 'end_line': 479, 'offset_start': 17547, 'offset_end': 17852, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.recover', 'start_line': 480, 'end_line': 484, 'offset_start': 17858, 'offset_end': 18079, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.tryRecover', 'start_line': 485, 'end_line': 494, 'offset_start': 18085, 'offset_end': 18580, 'content': 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.recover', 'start_line': 495, 'end_line': 499, 'offset_start': 18586, 'offset_end': 18817, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.toEthSignedMessageHash', 'start_line': 500, 'end_line': 506, 'offset_start': 18823, 'offset_end': 19081, 'content': 'function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.toEthSignedMessageHash', 'start_line': 507, 'end_line': 509, 'offset_start': 19087, 'offset_end': 19293, 'content': 'function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.toTypedDataHash', 'start_line': 510, 'end_line': 518, 'offset_start': 19299, 'offset_end': 19652, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSAUpgradeable.toDataWithIntendedValidatorHash', 'start_line': 519, 'end_line': 521, 'offset_start': 19658, 'offset_end': 19848, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }', 'contract_name': 'ECDSAUpgradeable', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, "\\x19\\x01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x00", validator, data));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 557, 'end_line': 563, 'offset_start': 21000, 'offset_end': 21279, 'content': 'function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 564, 'end_line': 566, 'offset_start': 21285, 'offset_end': 21384, 'content': 'function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 567, 'end_line': 569, 'offset_start': 21390, 'offset_end': 21482, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    uint8 private _initialized;\n    bool private _initializing;\n    event Initialized(uint8 version);\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            "Initializable: contract is already initialized"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        require(_initializing, "Initializable: contract is not initializing");\n        _;\n    }\n    function _disableInitializers() internal virtual {\n        require(!_initializing, "Initializable: contract is initializing");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.hasRole', 'start_line': 576, 'end_line': 576, 'offset_start': 21855, 'offset_end': 21931, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': '{\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.getRoleAdmin', 'start_line': 577, 'end_line': 577, 'offset_start': 21937, 'offset_end': 22004, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': '{\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.grantRole', 'start_line': 578, 'end_line': 578, 'offset_start': 22010, 'offset_end': 22068, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': '{\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.revokeRole', 'start_line': 579, 'end_line': 579, 'offset_start': 22074, 'offset_end': 22133, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': '{\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControlUpgradeable.renounceRole', 'start_line': 580, 'end_line': 580, 'offset_start': 22139, 'offset_end': 22200, 'content': 'function renounceRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControlUpgradeable', 'contract_code': '{\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init', 'start_line': 593, 'end_line': 595, 'offset_start': 22709, 'offset_end': 22855, 'content': 'function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init_unchained', 'start_line': 596, 'end_line': 601, 'offset_start': 22861, 'offset_end': 23072, 'content': 'function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._domainSeparatorV4', 'start_line': 602, 'end_line': 604, 'offset_start': 23078, 'offset_end': 23186, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._buildDomainSeparator', 'start_line': 605, 'end_line': 607, 'offset_start': 23192, 'offset_end': 23383, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._hashTypedDataV4', 'start_line': 608, 'end_line': 610, 'offset_start': 23389, 'offset_end': 23564, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.eip712Domain', 'start_line': 611, 'end_line': 636, 'offset_start': 23570, 'offset_end': 24218, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Name', 'start_line': 637, 'end_line': 639, 'offset_start': 24224, 'offset_end': 24321, 'content': 'function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Version', 'start_line': 640, 'end_line': 642, 'offset_start': 24327, 'offset_end': 24430, 'content': 'function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712NameHash', 'start_line': 643, 'end_line': 655, 'offset_start': 24436, 'offset_end': 24842, 'content': 'function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712VersionHash', 'start_line': 656, 'end_line': 668, 'offset_start': 24848, 'offset_end': 25281, 'content': 'function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant _TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    bytes32 private _hashedName;\n    bytes32 private _hashedVersion;\n    string private _name;\n    string private _version;\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        require(_hashedName == 0 && _hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    uint256[48] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.totalSupply', 'start_line': 675, 'end_line': 675, 'offset_start': 25534, 'offset_end': 25588, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.balanceOf', 'start_line': 676, 'end_line': 676, 'offset_start': 25594, 'offset_end': 25661, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transfer', 'start_line': 677, 'end_line': 677, 'offset_start': 25667, 'offset_end': 25736, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.allowance', 'start_line': 678, 'end_line': 678, 'offset_start': 25742, 'offset_end': 25824, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.approve', 'start_line': 679, 'end_line': 679, 'offset_start': 25830, 'offset_end': 25903, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Upgradeable.transferFrom', 'start_line': 680, 'end_line': 680, 'offset_start': 25909, 'offset_end': 25996, 'content': 'function transferFrom(address from, address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20Upgradeable', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.isContract', 'start_line': 684, 'end_line': 686, 'offset_start': 26057, 'offset_end': 26169, 'content': 'function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.sendValue', 'start_line': 687, 'end_line': 691, 'offset_start': 26175, 'offset_end': 26485, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 692, 'end_line': 694, 'offset_start': 26491, 'offset_end': 26675, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCall', 'start_line': 695, 'end_line': 701, 'offset_start': 26681, 'offset_end': 26903, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 702, 'end_line': 704, 'offset_start': 26909, 'offset_end': 27132, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionCallWithValue', 'start_line': 705, 'end_line': 714, 'offset_start': 27138, 'offset_end': 27583, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 715, 'end_line': 717, 'offset_start': 27589, 'offset_end': 27785, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionStaticCall', 'start_line': 718, 'end_line': 725, 'offset_start': 27791, 'offset_end': 28116, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 726, 'end_line': 728, 'offset_start': 28122, 'offset_end': 28319, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.functionDelegateCall', 'start_line': 729, 'end_line': 736, 'offset_start': 28325, 'offset_end': 28649, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResultFromTarget', 'start_line': 737, 'end_line': 751, 'offset_start': 28655, 'offset_end': 29117, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable.verifyCallResult', 'start_line': 752, 'end_line': 762, 'offset_start': 29123, 'offset_end': 29417, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AddressUpgradeable._revert', 'start_line': 763, 'end_line': 772, 'offset_start': 29423, 'offset_end': 29765, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'AddressUpgradeable', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165Upgradeable.supportsInterface', 'start_line': 776, 'end_line': 776, 'offset_start': 29828, 'offset_end': 29903, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165Upgradeable', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.name', 'start_line': 781, 'end_line': 781, 'offset_start': 30029, 'offset_end': 30082, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.symbol', 'start_line': 782, 'end_line': 782, 'offset_start': 30088, 'offset_end': 30143, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20MetadataUpgradeable.decimals', 'start_line': 783, 'end_line': 783, 'offset_start': 30149, 'offset_end': 30198, 'content': 'function decimals() external view returns (uint8);', 'contract_name': 'IERC20MetadataUpgradeable', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.__Soul_init', 'start_line': 823, 'end_line': 830, 'offset_start': 31649, 'offset_end': 32039, 'content': 'function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.transfer', 'start_line': 831, 'end_line': 833, 'offset_start': 32045, 'offset_end': 32170, 'content': 'function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.transferFrom', 'start_line': 834, 'end_line': 836, 'offset_start': 32176, 'offset_end': 32319, 'content': 'function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.mintSoul', 'start_line': 837, 'end_line': 844, 'offset_start': 32325, 'offset_end': 32799, 'content': 'function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul._verify', 'start_line': 845, 'end_line': 868, 'offset_start': 32805, 'offset_end': 33771, 'content': 'function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.decimals', 'start_line': 869, 'end_line': 871, 'offset_start': 33777, 'offset_end': 33866, 'content': 'function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'Soul.burn', 'start_line': 872, 'end_line': 875, 'offset_start': 33872, 'offset_end': 34053, 'content': 'function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }', 'contract_name': 'Soul', 'contract_code': '{\n    struct _DateTime {\n            uint16 year;\n            uint8 month;\n            uint8 day;\n    }\n    uint constant private DAY_IN_SECONDS = 86400;\n    uint constant private YEAR_IN_SECONDS = 31536000;\n    uint constant private LEAP_YEAR_IN_SECONDS = 31622400;\n    uint16 constant private ORIGIN_YEAR = 1970;\n    address private soul_singer;\n    string private constant SIGNING_DOMAIN = "Soul";\n    string private constant SIGNATURE_VERSION = "1";\n    bytes32 public constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6;\n    bytes32 private typeHash;\n    mapping(address=>uint256) private addressTimeMap;\n    event MintSoul(\n        address account,\n        uint256 amount,\n        uint256 ymd\n    );\n    event MintParams(\n        uint256 chainId,\n        bytes32 eip712DomainHash,\n        bytes32 hashStruct,\n        bytes32 digest\n    );\n    error InvalidSigner();\n    struct MintData {\n        address account;\n        uint256 amount;\n        uint256 ymd;\n    }\n    function __Soul_init(string memory _name,string memory _symbol) public initializer()  {\n        soul_singer = msg.sender;\n        typeHash = keccak256("MintData(address account,uint256 amount,uint256 ymd)");\n        __EIP712_init(SIGNING_DOMAIN,SIGNATURE_VERSION);\n        __ERC20_init(_name,_symbol);\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        revert("do not support");\n    }\n    function mintSoul(MintData calldata mintData, bytes memory signature) external{\n        address signer = _verify(mintData, signature);\n        require(hasRole(MINTER_ROLE,signer),"invald signer");\n        require(addressTimeMap[mintData.account] < mintData.ymd,"You can only mint once a day");\n        addressTimeMap[mintData.account] = mintData.ymd;\n        _mint(mintData.account,mintData.amount);\n        emit MintSoul(mintData.account,mintData.amount,mintData.ymd);\n    }\n    function _verify(MintData calldata mintData, bytes memory signature) internal returns (address) {\n        uint256 chainId = uint256(block.chainid);\n        bytes32 eip712DomainHash = keccak256(\n        abi.encode(\n                keccak256(\n                    "EIP712Domain(string name,string version,uint256 chainId)"\n                ),\n                keccak256(bytes("Soul")),\n                keccak256(bytes("1")),\n                chainId\n            )\n        );\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                keccak256("MintData(address account,uint256 amount,uint256 ymd)"),\n                mintData.account,\n                mintData.amount,\n                mintData.ymd\n            )\n        );\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", eip712DomainHash, hashStruct));\n        emit MintParams(chainId,eip712DomainHash,hashStruct,digest);\n        return ECDSAUpgradeable.recover(digest, signature);\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 0;\n    }\n    function burn(address account, uint256 amount) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE,msg.sender),"do not have admin role");\n        super._burn(account,amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 884, 'end_line': 885, 'offset_start': 34437, 'offset_end': 34501, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 886, 'end_line': 887, 'offset_start': 34507, 'offset_end': 34581, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 898, 'end_line': 900, 'offset_start': 34869, 'offset_end': 35081, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 901, 'end_line': 903, 'offset_start': 35087, 'offset_end': 35231, 'content': 'function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 904, 'end_line': 906, 'offset_start': 35237, 'offset_end': 35339, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 907, 'end_line': 920, 'offset_start': 35345, 'offset_end': 35845, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 921, 'end_line': 923, 'offset_start': 35851, 'offset_end': 35979, 'content': 'function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 924, 'end_line': 926, 'offset_start': 35985, 'offset_end': 36129, 'content': 'function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 927, 'end_line': 929, 'offset_start': 36135, 'offset_end': 36281, 'content': 'function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 930, 'end_line': 933, 'offset_start': 36287, 'offset_end': 36499, 'content': 'function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setupRole', 'start_line': 934, 'end_line': 936, 'offset_start': 36505, 'offset_end': 36614, 'content': 'function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 937, 'end_line': 941, 'offset_start': 36620, 'offset_end': 36866, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 942, 'end_line': 947, 'offset_start': 36872, 'offset_end': 37104, 'content': 'function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 948, 'end_line': 953, 'offset_start': 37110, 'offset_end': 37343, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        StringsUpgradeable.toHexString(account),\n                        " is missing role ",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n        _revokeRole(role, account);\n    }\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0xc5cb997016c9a3ac91cbe306e59b048a812c056f/0xc5cb997016c9a3ac91cbe306e59b048a812c056f.sol'}
