{'type': 'FunctionDefinition', 'name': 'IAccessControl.hasRole', 'start_line': 11, 'end_line': 11, 'offset_start': 505, 'offset_end': 581, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(\n        bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole\n    );\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.getRoleAdmin', 'start_line': 12, 'end_line': 12, 'offset_start': 587, 'offset_end': 654, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(\n        bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole\n    );\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.grantRole', 'start_line': 13, 'end_line': 13, 'offset_start': 660, 'offset_end': 718, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(\n        bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole\n    );\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.revokeRole', 'start_line': 14, 'end_line': 14, 'offset_start': 724, 'offset_end': 783, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(\n        bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole\n    );\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.renounceRole', 'start_line': 15, 'end_line': 15, 'offset_start': 789, 'offset_end': 861, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(\n        bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole\n    );\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267.eip712Domain', 'start_line': 19, 'end_line': 30, 'offset_start': 923, 'offset_end': 1232, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267', 'contract_code': '{\n    event EIP712DomainChanged();\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 33, 'end_line': 33, 'offset_start': 1270, 'offset_end': 1326, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 65, 'end_line': 65, 'offset_start': 2729, 'offset_end': 2786, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 68, 'end_line': 70, 'offset_start': 2822, 'offset_end': 2959, 'content': 'function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n        external\n        returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 76, 'end_line': 84, 'offset_start': 3113, 'offset_end': 3441, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 85, 'end_line': 87, 'offset_start': 3447, 'offset_end': 3597, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 88, 'end_line': 97, 'offset_start': 3603, 'offset_end': 4014, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 98, 'end_line': 105, 'offset_start': 4020, 'offset_end': 4301, 'content': 'function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 106, 'end_line': 112, 'offset_start': 4307, 'offset_end': 4579, 'content': 'function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 113, 'end_line': 126, 'offset_start': 4585, 'offset_end': 4994, 'content': 'function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 127, 'end_line': 137, 'offset_start': 5000, 'offset_end': 5251, 'content': 'function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 138, 'end_line': 147, 'offset_start': 5257, 'offset_end': 5575, 'content': 'function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success,) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value)\n        internal\n        returns (bytes memory)\n    {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata)\n        internal\n        view\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 168, 'end_line': 172, 'offset_start': 5920, 'offset_end': 6066, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 173, 'end_line': 177, 'offset_start': 6072, 'offset_end': 6218, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 178, 'end_line': 182, 'offset_start': 6224, 'offset_end': 6370, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 183, 'end_line': 187, 'offset_start': 6376, 'offset_end': 6522, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 188, 'end_line': 192, 'offset_start': 6528, 'offset_end': 6672, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 193, 'end_line': 197, 'offset_start': 6678, 'offset_end': 6836, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 198, 'end_line': 202, 'offset_start': 6842, 'offset_end': 6984, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 203, 'end_line': 207, 'offset_start': 6990, 'offset_end': 7145, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 219, 'end_line': 237, 'offset_start': 7435, 'offset_end': 8050, 'content': 'function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 238, 'end_line': 242, 'offset_start': 8056, 'offset_end': 8310, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 243, 'end_line': 254, 'offset_start': 8316, 'offset_end': 8716, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 255, 'end_line': 259, 'offset_start': 8722, 'offset_end': 8971, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 260, 'end_line': 273, 'offset_start': 8977, 'offset_end': 9536, 'content': 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 274, 'end_line': 278, 'offset_start': 9542, 'offset_end': 9801, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 279, 'end_line': 289, 'offset_start': 9807, 'offset_end': 10315, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        unchecked {\n            bytes32 s =\n                vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        pure\n        returns (address, RecoverError, bytes32)\n    {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 292, 'end_line': 292, 'offset_start': 10343, 'offset_end': 10418, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 302, 'end_line': 308, 'offset_start': 10564, 'offset_end': 10779, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 309, 'end_line': 314, 'offset_start': 10785, 'offset_end': 10973, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 315, 'end_line': 322, 'offset_start': 10979, 'offset_end': 11241, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 323, 'end_line': 328, 'offset_start': 11247, 'offset_end': 11436, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 329, 'end_line': 334, 'offset_start': 11442, 'offset_end': 11631, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 335, 'end_line': 337, 'offset_start': 11637, 'offset_end': 11740, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 338, 'end_line': 340, 'offset_start': 11746, 'offset_end': 11849, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 341, 'end_line': 343, 'offset_start': 11855, 'offset_end': 11970, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 344, 'end_line': 349, 'offset_start': 11976, 'offset_end': 12156, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 350, 'end_line': 391, 'offset_start': 12162, 'offset_end': 13657, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 392, 'end_line': 402, 'offset_start': 13663, 'offset_end': 13992, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 403, 'end_line': 418, 'offset_start': 13998, 'offset_end': 14578, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 419, 'end_line': 424, 'offset_start': 14584, 'offset_end': 14823, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 425, 'end_line': 461, 'offset_start': 14829, 'offset_end': 15811, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 462, 'end_line': 467, 'offset_start': 15817, 'offset_end': 16064, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 468, 'end_line': 500, 'offset_start': 16070, 'offset_end': 16985, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 501, 'end_line': 506, 'offset_start': 16991, 'offset_end': 17241, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 507, 'end_line': 531, 'offset_start': 17247, 'offset_end': 17909, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 532, 'end_line': 537, 'offset_start': 17915, 'offset_end': 18173, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 538, 'end_line': 540, 'offset_start': 18179, 'offset_end': 18300, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 543, 'end_line': 545, 'offset_start': 18329, 'offset_end': 18429, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 546, 'end_line': 548, 'offset_start': 18435, 'offset_end': 18535, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 549, 'end_line': 552, 'offset_start': 18541, 'offset_end': 18718, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 553, 'end_line': 557, 'offset_start': 18724, 'offset_end': 18860, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 603, 'end_line': 607, 'offset_start': 20357, 'offset_end': 20497, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE =\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 608, 'end_line': 617, 'offset_start': 20503, 'offset_end': 20867, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE =\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 618, 'end_line': 620, 'offset_start': 20873, 'offset_end': 21000, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE =\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 621, 'end_line': 623, 'offset_start': 21006, 'offset_end': 21125, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE =\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 624, 'end_line': 628, 'offset_start': 21131, 'offset_end': 21300, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE =\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 642, 'end_line': 642, 'offset_start': 21725, 'offset_end': 21798, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 643, 'end_line': 643, 'offset_start': 21804, 'offset_end': 21875, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 644, 'end_line': 645, 'offset_start': 21881, 'offset_end': 21987, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 646, 'end_line': 646, 'offset_start': 21993, 'offset_end': 22070, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 647, 'end_line': 647, 'offset_start': 22076, 'offset_end': 22149, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 648, 'end_line': 648, 'offset_start': 22155, 'offset_end': 22209, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 649, 'end_line': 649, 'offset_start': 22215, 'offset_end': 22283, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 650, 'end_line': 650, 'offset_start': 22289, 'offset_end': 22367, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 651, 'end_line': 651, 'offset_start': 22373, 'offset_end': 22460, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\n        external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 654, 'end_line': 654, 'offset_start': 22524, 'offset_end': 22577, 'content': 'function __Context_init() internal onlyInitializing {}', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {}\n    function __Context_init_unchained() internal onlyInitializing {}\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 655, 'end_line': 655, 'offset_start': 22583, 'offset_end': 22646, 'content': 'function __Context_init_unchained() internal onlyInitializing {}', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {}\n    function __Context_init_unchained() internal onlyInitializing {}\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 656, 'end_line': 658, 'offset_start': 22652, 'offset_end': 22747, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {}\n    function __Context_init_unchained() internal onlyInitializing {}\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 659, 'end_line': 661, 'offset_start': 22753, 'offset_end': 22851, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {}\n    function __Context_init_unchained() internal onlyInitializing {}\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 671, 'end_line': 675, 'offset_start': 23216, 'offset_end': 23398, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 677, 'end_line': 679, 'offset_start': 23446, 'offset_end': 23556, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 680, 'end_line': 683, 'offset_start': 23562, 'offset_end': 23744, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 689, 'end_line': 695, 'offset_start': 23858, 'offset_end': 24102, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 696, 'end_line': 699, 'offset_start': 24108, 'offset_end': 24258, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 700, 'end_line': 703, 'offset_start': 24264, 'offset_end': 24444, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 706, 'end_line': 706, 'offset_start': 24491, 'offset_end': 24544, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 707, 'end_line': 707, 'offset_start': 24550, 'offset_end': 24605, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 708, 'end_line': 708, 'offset_start': 24611, 'offset_end': 24683, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 714, 'end_line': 732, 'offset_start': 24890, 'offset_end': 25489, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 733, 'end_line': 735, 'offset_start': 25495, 'offset_end': 25662, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 736, 'end_line': 740, 'offset_start': 25668, 'offset_end': 25841, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 741, 'end_line': 754, 'offset_start': 25847, 'offset_end': 26371, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 755, 'end_line': 757, 'offset_start': 26377, 'offset_end': 26524, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 758, 'end_line': 760, 'offset_start': 26530, 'offset_end': 26711, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 763, 'end_line': 763, 'offset_start': 26783, 'offset_end': 26835, 'content': 'function __ERC165_init() internal onlyInitializing {}', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {}\n    function __ERC165_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 764, 'end_line': 764, 'offset_start': 26841, 'offset_end': 26903, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {}', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {}\n    function __ERC165_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 765, 'end_line': 767, 'offset_start': 26909, 'offset_end': 27054, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {}\n    function __ERC165_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 779, 'end_line': 781, 'offset_start': 27569, 'offset_end': 27706, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 782, 'end_line': 787, 'offset_start': 27712, 'offset_end': 27992, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 788, 'end_line': 796, 'offset_start': 27998, 'offset_end': 28331, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 799, 'end_line': 801, 'offset_start': 28456, 'offset_end': 28575, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 802, 'end_line': 807, 'offset_start': 28581, 'offset_end': 28797, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 808, 'end_line': 811, 'offset_start': 28803, 'offset_end': 28935, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 814, 'end_line': 816, 'offset_start': 29061, 'offset_end': 29182, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 817, 'end_line': 826, 'offset_start': 29188, 'offset_end': 29622, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 827, 'end_line': 835, 'offset_start': 29628, 'offset_end': 29959, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 836, 'end_line': 840, 'offset_start': 29965, 'offset_end': 30086, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT =\n        0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 843, 'end_line': 849, 'offset_start': 30121, 'offset_end': 30394, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return keccak256(\n            bytes.concat(\n                "\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message\n            )\n        );\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex"1900", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"1901")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 850, 'end_line': 856, 'offset_start': 30400, 'offset_end': 30668, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return keccak256(\n            bytes.concat(\n                "\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message\n            )\n        );\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return keccak256(\n            bytes.concat(\n                "\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message\n            )\n        );\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex"1900", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"1901")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 857, 'end_line': 863, 'offset_start': 30674, 'offset_end': 30891, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex"1900", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return keccak256(\n            bytes.concat(\n                "\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message\n            )\n        );\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex"1900", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"1901")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 864, 'end_line': 876, 'offset_start': 30897, 'offset_end': 31281, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"1901")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return keccak256(\n            bytes.concat(\n                "\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message\n            )\n        );\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(hex"1900", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32 digest)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"1901")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._getAccessControlStorage', 'start_line': 894, 'end_line': 898, 'offset_start': 31808, 'offset_end': 31984, 'content': 'function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 903, 'end_line': 903, 'offset_start': 32071, 'offset_end': 32130, 'content': 'function __AccessControl_init() internal onlyInitializing {}', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 904, 'end_line': 904, 'offset_start': 32136, 'offset_end': 32205, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {}', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 905, 'end_line': 908, 'offset_start': 32211, 'offset_end': 32424, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 909, 'end_line': 912, 'offset_start': 32430, 'offset_end': 32636, 'content': 'function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 913, 'end_line': 915, 'offset_start': 32642, 'offset_end': 32744, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 916, 'end_line': 920, 'offset_start': 32750, 'offset_end': 32946, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 921, 'end_line': 924, 'offset_start': 32952, 'offset_end': 33142, 'content': 'function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 925, 'end_line': 927, 'offset_start': 33148, 'offset_end': 33283, 'content': 'function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 928, 'end_line': 934, 'offset_start': 33289, 'offset_end': 33454, 'content': 'function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 935, 'end_line': 940, 'offset_start': 33460, 'offset_end': 33703, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 941, 'end_line': 946, 'offset_start': 33709, 'offset_end': 34026, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 947, 'end_line': 956, 'offset_start': 34032, 'offset_end': 34418, 'content': 'function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 957, 'end_line': 966, 'offset_start': 34424, 'offset_end': 34811, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation =\n        0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {}\n    function __AccessControl_init_unchained() internal onlyInitializing {}\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account)\n        public\n        virtual\n        onlyRole(getRoleAdmin(role))\n    {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 981, 'end_line': 981, 'offset_start': 35248, 'offset_end': 35309, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {}', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 982, 'end_line': 982, 'offset_start': 35315, 'offset_end': 35386, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 983, 'end_line': 985, 'offset_start': 35392, 'offset_end': 35525, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 986, 'end_line': 994, 'offset_start': 35531, 'offset_end': 35780, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 995, 'end_line': 1002, 'offset_start': 35786, 'offset_end': 36022, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 1003, 'end_line': 1007, 'offset_start': 36028, 'offset_end': 36185, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 1008, 'end_line': 1008, 'offset_start': 36191, 'offset_end': 36261, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 1009, 'end_line': 1018, 'offset_start': 36267, 'offset_end': 36758, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {}\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {}\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self \n                || ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._getEIP712Storage', 'start_line': 1032, 'end_line': 1036, 'offset_start': 37253, 'offset_end': 37408, 'content': 'function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init', 'start_line': 1037, 'end_line': 1039, 'offset_start': 37414, 'offset_end': 37560, 'content': 'function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init_unchained', 'start_line': 1040, 'end_line': 1049, 'offset_start': 37566, 'offset_end': 37860, 'content': 'function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._domainSeparatorV4', 'start_line': 1050, 'end_line': 1052, 'offset_start': 37866, 'offset_end': 37974, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._buildDomainSeparator', 'start_line': 1053, 'end_line': 1059, 'offset_start': 37980, 'offset_end': 38222, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._hashTypedDataV4', 'start_line': 1060, 'end_line': 1062, 'offset_start': 38228, 'offset_end': 38403, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.eip712Domain', 'start_line': 1063, 'end_line': 1088, 'offset_start': 38409, 'offset_end': 39099, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Name', 'start_line': 1089, 'end_line': 1092, 'offset_start': 39105, 'offset_end': 39259, 'content': 'function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Version', 'start_line': 1093, 'end_line': 1096, 'offset_start': 39265, 'offset_end': 39425, 'content': 'function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712NameHash', 'start_line': 1097, 'end_line': 1110, 'offset_start': 39431, 'offset_end': 39894, 'content': 'function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712VersionHash', 'start_line': 1111, 'end_line': 1124, 'offset_start': 39900, 'offset_end': 40390, 'content': 'function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH = keccak256(\n        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n    );\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation =\n        0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version)\n        internal\n        onlyInitializing\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getERC721Storage', 'start_line': 1145, 'end_line': 1149, 'offset_start': 41051, 'offset_end': 41206, 'content': 'function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 1150, 'end_line': 1152, 'offset_start': 41212, 'offset_end': 41360, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 1153, 'end_line': 1160, 'offset_start': 41366, 'offset_end': 41604, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 1161, 'end_line': 1170, 'offset_start': 41610, 'offset_end': 41940, 'content': 'function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 1171, 'end_line': 1177, 'offset_start': 41946, 'offset_end': 42210, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 1178, 'end_line': 1180, 'offset_start': 42216, 'offset_end': 42333, 'content': 'function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 1181, 'end_line': 1184, 'offset_start': 42339, 'offset_end': 42484, 'content': 'function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 1185, 'end_line': 1188, 'offset_start': 42490, 'offset_end': 42639, 'content': 'function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 1189, 'end_line': 1193, 'offset_start': 42645, 'offset_end': 42898, 'content': 'function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 1194, 'end_line': 1196, 'offset_start': 42904, 'offset_end': 42995, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 1197, 'end_line': 1199, 'offset_start': 43001, 'offset_end': 43113, 'content': 'function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 1200, 'end_line': 1203, 'offset_start': 43119, 'offset_end': 43271, 'content': 'function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 1204, 'end_line': 1206, 'offset_start': 43277, 'offset_end': 43420, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 1207, 'end_line': 1210, 'offset_start': 43426, 'offset_end': 43635, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 1211, 'end_line': 1219, 'offset_start': 43641, 'offset_end': 44009, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1220, 'end_line': 1222, 'offset_start': 44015, 'offset_end': 44146, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1223, 'end_line': 1229, 'offset_start': 44152, 'offset_end': 44379, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 1230, 'end_line': 1233, 'offset_start': 44385, 'offset_end': 44556, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getApproved', 'start_line': 1234, 'end_line': 1237, 'offset_start': 44562, 'offset_end': 44745, 'content': 'function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isAuthorized', 'start_line': 1238, 'end_line': 1248, 'offset_start': 44751, 'offset_end': 45076, 'content': 'function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkAuthorized', 'start_line': 1249, 'end_line': 1261, 'offset_start': 45082, 'offset_end': 45477, 'content': 'function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._increaseBalance', 'start_line': 1262, 'end_line': 1267, 'offset_start': 45483, 'offset_end': 45692, 'content': 'function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._update', 'start_line': 1268, 'end_line': 1292, 'offset_start': 45698, 'offset_end': 46417, 'content': 'function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 1293, 'end_line': 1301, 'offset_start': 46423, 'offset_end': 46749, 'content': 'function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1302, 'end_line': 1304, 'offset_start': 46755, 'offset_end': 46854, 'content': 'function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1305, 'end_line': 1308, 'offset_start': 46860, 'offset_end': 47041, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 1309, 'end_line': 1314, 'offset_start': 47047, 'offset_end': 47273, 'content': 'function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 1315, 'end_line': 1325, 'offset_start': 47279, 'offset_end': 47738, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1326, 'end_line': 1328, 'offset_start': 47744, 'offset_end': 47871, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1329, 'end_line': 1335, 'offset_start': 47877, 'offset_end': 48100, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1336, 'end_line': 1338, 'offset_start': 48106, 'offset_end': 48225, 'content': 'function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1339, 'end_line': 1351, 'offset_start': 48231, 'offset_end': 48785, 'content': 'function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 1352, 'end_line': 1359, 'offset_start': 48791, 'offset_end': 49159, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireOwned', 'start_line': 1360, 'end_line': 1366, 'offset_start': 49165, 'offset_end': 49405, 'content': 'function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 1367, 'end_line': 1387, 'offset_start': 49411, 'offset_end': 50179, 'content': 'function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation =\n        0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n        public\n        virtual\n    {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return spender != address(0)\n            && (\n                owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender\n            );\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n    {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth)\n        internal\n        virtual\n        returns (address)\n    {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n        private\n    {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (\n                bytes4 retval\n            ) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.distributeRewards', 'start_line': 1390, 'end_line': 1398, 'offset_start': 50222, 'offset_end': 50440, 'content': 'function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.withdrawFunds', 'start_line': 1399, 'end_line': 1405, 'offset_start': 50446, 'offset_end': 50605, 'content': 'function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.createEscrow', 'start_line': 1406, 'end_line': 1411, 'offset_start': 50611, 'offset_end': 50765, 'content': 'function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.updateEscrowAdmin', 'start_line': 1412, 'end_line': 1412, 'offset_start': 50771, 'offset_end': 50841, 'content': 'function updateEscrowAdmin(uint256 questId, address newAdmin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.addTokenToWhitelist', 'start_line': 1413, 'end_line': 1413, 'offset_start': 50847, 'offset_end': 50916, 'content': 'function addTokenToWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.removeTokenFromWhitelist', 'start_line': 1414, 'end_line': 1414, 'offset_start': 50922, 'offset_end': 50996, 'content': 'function removeTokenFromWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.initialize', 'start_line': 1415, 'end_line': 1415, 'offset_start': 51002, 'offset_end': 51045, 'content': 'function initialize(address admin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tor', 'start_line': 1523, 'end_line': 1525, 'offset_start': 54812, 'offset_end': 54864, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.cubeVersion', 'start_line': 1526, 'end_line': 1528, 'offset_start': 54870, 'offset_end': 54957, 'content': 'function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initialize', 'start_line': 1529, 'end_line': 1543, 'offset_start': 54963, 'offset_end': 55478, 'content': 'function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._authorizeUpgrade', 'start_line': 1544, 'end_line': 1548, 'offset_start': 55484, 'offset_end': 55609, 'content': 'function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.isQuestActive', 'start_line': 1549, 'end_line': 1551, 'offset_start': 55615, 'offset_end': 55722, 'content': 'function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tokenURI', 'start_line': 1552, 'end_line': 1554, 'offset_start': 55728, 'offset_end': 55863, 'content': 'function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCube', 'start_line': 1555, 'end_line': 1567, 'offset_start': 55869, 'offset_end': 56229, 'content': 'function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCubes', 'start_line': 1568, 'end_line': 1595, 'offset_start': 56235, 'offset_end': 57048, 'content': 'function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._mintCube', 'start_line': 1596, 'end_line': 1645, 'offset_start': 57054, 'offset_end': 58752, 'content': 'function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._validateSignature', 'start_line': 1646, 'end_line': 1655, 'offset_start': 58758, 'offset_end': 59128, 'content': 'function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._processPayouts', 'start_line': 1656, 'end_line': 1684, 'offset_start': 59134, 'offset_end': 60276, 'content': 'function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getSigner', 'start_line': 1685, 'end_line': 1692, 'offset_start': 60282, 'offset_end': 60495, 'content': 'function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._computeDigest', 'start_line': 1693, 'end_line': 1695, 'offset_start': 60501, 'offset_end': 60653, 'content': 'function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getStructHash', 'start_line': 1696, 'end_line': 1710, 'offset_start': 60659, 'offset_end': 61192, 'content': 'function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeString', 'start_line': 1711, 'end_line': 1713, 'offset_start': 61198, 'offset_end': 61326, 'content': 'function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeTx', 'start_line': 1714, 'end_line': 1720, 'offset_start': 61332, 'offset_end': 61597, 'content': 'function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeCompletedTxs', 'start_line': 1721, 'end_line': 1734, 'offset_start': 61603, 'offset_end': 62037, 'content': 'function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipient', 'start_line': 1735, 'end_line': 1737, 'offset_start': 62043, 'offset_end': 62214, 'content': 'function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipients', 'start_line': 1738, 'end_line': 1747, 'offset_start': 62220, 'offset_end': 62641, 'content': 'function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeReward', 'start_line': 1748, 'end_line': 1761, 'offset_start': 62647, 'offset_end': 63065, 'content': 'function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.setIsMintingActive', 'start_line': 1762, 'end_line': 1765, 'offset_start': 63071, 'offset_end': 63258, 'content': 'function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.withdraw', 'start_line': 1766, 'end_line': 1772, 'offset_start': 63264, 'offset_end': 63538, 'content': 'function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initializeQuest', 'start_line': 1773, 'end_line': 1783, 'offset_start': 63544, 'offset_end': 63913, 'content': 'function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.unpublishQuest', 'start_line': 1784, 'end_line': 1787, 'offset_start': 63919, 'offset_end': 64069, 'content': 'function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.supportsInterface', 'start_line': 1788, 'end_line': 1795, 'offset_start': 64075, 'offset_end': 64298, 'content': 'function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/59144/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
