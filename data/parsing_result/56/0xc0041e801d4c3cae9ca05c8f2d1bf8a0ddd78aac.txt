{'type': 'FunctionDefinition', 'name': 'ERC721.tokenURI', 'start_line': 9, 'end_line': 9, 'offset_start': 367, 'offset_end': 440, 'content': 'function tokenURI(uint256 id) public view virtual returns (string memory);', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.ownerOf', 'start_line': 12, 'end_line': 14, 'offset_start': 550, 'offset_end': 698, 'content': 'function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.balanceOf', 'start_line': 15, 'end_line': 18, 'offset_start': 704, 'offset_end': 870, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tor', 'start_line': 21, 'end_line': 24, 'offset_start': 1002, 'offset_end': 1112, 'content': 'constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.approve', 'start_line': 25, 'end_line': 30, 'offset_start': 1118, 'offset_end': 1396, 'content': 'function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.setApprovalForAll', 'start_line': 31, 'end_line': 34, 'offset_start': 1402, 'offset_end': 1603, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.transferFrom', 'start_line': 35, 'end_line': 53, 'offset_start': 1609, 'offset_end': 2177, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 54, 'end_line': 66, 'offset_start': 2183, 'offset_end': 2577, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 67, 'end_line': 80, 'offset_start': 2583, 'offset_end': 3008, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.supportsInterface', 'start_line': 81, 'end_line': 86, 'offset_start': 3014, 'offset_end': 3241, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._mint', 'start_line': 87, 'end_line': 95, 'offset_start': 3247, 'offset_end': 3558, 'content': 'function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._burn', 'start_line': 96, 'end_line': 105, 'offset_start': 3564, 'offset_end': 3874, 'content': 'function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 106, 'end_line': 114, 'offset_start': 3880, 'offset_end': 4218, 'content': 'function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 115, 'end_line': 127, 'offset_start': 4224, 'offset_end': 4613, 'content': 'function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721TokenReceiver.onERC721Received', 'start_line': 130, 'end_line': 137, 'offset_start': 4661, 'offset_end': 4870, 'content': 'function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }', 'contract_name': 'ERC721TokenReceiver', 'contract_code': '{\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'CookieBadge.tor', 'start_line': 151, 'end_line': 157, 'offset_start': 5235, 'offset_end': 5390, 'content': 'constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _uri\n    ) ERC721(_name, _symbol) {\n        uri = _uri;\n    }', 'contract_name': 'CookieBadge', 'contract_code': '{\n    uint256 public currentTokenId;\n    string uri;\n    error SoulBoundToken__CannotTransfer();\n    error AlreadyMinted();\n    error CallerIsContract();\n    modifier callerIsUser() {\n        if (tx.origin != msg.sender) revert CallerIsContract();\n        _;\n    }\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _uri\n    ) ERC721(_name, _symbol) {\n        uri = _uri;\n    }\n    function mintTo() external callerIsUser returns (uint256) {\n        if (balanceOf(msg.sender) > 0) revert AlreadyMinted();\n        uint256 newItemId = ++currentTokenId;\n        _safeMint(msg.sender, newItemId);\n        return newItemId;\n    }\n    function transferFrom(address, address, uint256) public virtual override {\n        revert SoulBoundToken__CannotTransfer();\n    }\n    function tokenURI(\n        uint256\n    ) public view virtual override returns (string memory) {\n        return uri;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'CookieBadge.mintTo', 'start_line': 158, 'end_line': 163, 'offset_start': 5396, 'offset_end': 5637, 'content': 'function mintTo() external callerIsUser returns (uint256) {\n        if (balanceOf(msg.sender) > 0) revert AlreadyMinted();\n        uint256 newItemId = ++currentTokenId;\n        _safeMint(msg.sender, newItemId);\n        return newItemId;\n    }', 'contract_name': 'CookieBadge', 'contract_code': '{\n    uint256 public currentTokenId;\n    string uri;\n    error SoulBoundToken__CannotTransfer();\n    error AlreadyMinted();\n    error CallerIsContract();\n    modifier callerIsUser() {\n        if (tx.origin != msg.sender) revert CallerIsContract();\n        _;\n    }\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _uri\n    ) ERC721(_name, _symbol) {\n        uri = _uri;\n    }\n    function mintTo() external callerIsUser returns (uint256) {\n        if (balanceOf(msg.sender) > 0) revert AlreadyMinted();\n        uint256 newItemId = ++currentTokenId;\n        _safeMint(msg.sender, newItemId);\n        return newItemId;\n    }\n    function transferFrom(address, address, uint256) public virtual override {\n        revert SoulBoundToken__CannotTransfer();\n    }\n    function tokenURI(\n        uint256\n    ) public view virtual override returns (string memory) {\n        return uri;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'CookieBadge.transferFrom', 'start_line': 164, 'end_line': 166, 'offset_start': 5643, 'offset_end': 5771, 'content': 'function transferFrom(address, address, uint256) public virtual override {\n        revert SoulBoundToken__CannotTransfer();\n    }', 'contract_name': 'CookieBadge', 'contract_code': '{\n    uint256 public currentTokenId;\n    string uri;\n    error SoulBoundToken__CannotTransfer();\n    error AlreadyMinted();\n    error CallerIsContract();\n    modifier callerIsUser() {\n        if (tx.origin != msg.sender) revert CallerIsContract();\n        _;\n    }\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _uri\n    ) ERC721(_name, _symbol) {\n        uri = _uri;\n    }\n    function mintTo() external callerIsUser returns (uint256) {\n        if (balanceOf(msg.sender) > 0) revert AlreadyMinted();\n        uint256 newItemId = ++currentTokenId;\n        _safeMint(msg.sender, newItemId);\n        return newItemId;\n    }\n    function transferFrom(address, address, uint256) public virtual override {\n        revert SoulBoundToken__CannotTransfer();\n    }\n    function tokenURI(\n        uint256\n    ) public view virtual override returns (string memory) {\n        return uri;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
{'type': 'FunctionDefinition', 'name': 'CookieBadge.tokenURI', 'start_line': 167, 'end_line': 171, 'offset_start': 5777, 'offset_end': 5897, 'content': 'function tokenURI(\n        uint256\n    ) public view virtual override returns (string memory) {\n        return uri;\n    }', 'contract_name': 'CookieBadge', 'contract_code': '{\n    uint256 public currentTokenId;\n    string uri;\n    error SoulBoundToken__CannotTransfer();\n    error AlreadyMinted();\n    error CallerIsContract();\n    modifier callerIsUser() {\n        if (tx.origin != msg.sender) revert CallerIsContract();\n        _;\n    }\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _uri\n    ) ERC721(_name, _symbol) {\n        uri = _uri;\n    }\n    function mintTo() external callerIsUser returns (uint256) {\n        if (balanceOf(msg.sender) > 0) revert AlreadyMinted();\n        uint256 newItemId = ++currentTokenId;\n        _safeMint(msg.sender, newItemId);\n        return newItemId;\n    }\n    function transferFrom(address, address, uint256) public virtual override {\n        revert SoulBoundToken__CannotTransfer();\n    }\n    function tokenURI(\n        uint256\n    ) public view virtual override returns (string memory) {\n        return uri;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac/0xc0041e801d4c3cae9ca05c8f2d1bf8a0ddd78aac.sol'}
