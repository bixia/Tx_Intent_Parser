{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 6, 'end_line': 6, 'offset_start': 209, 'offset_end': 263, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 7, 'end_line': 7, 'offset_start': 269, 'offset_end': 336, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 8, 'end_line': 8, 'offset_start': 342, 'offset_end': 410, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 9, 'end_line': 9, 'offset_start': 416, 'offset_end': 498, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 10, 'end_line': 10, 'offset_start': 504, 'offset_end': 576, 'content': 'function approve(address spender, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 11, 'end_line': 11, 'offset_start': 582, 'offset_end': 668, 'content': 'function transferFrom(address from, address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.permit', 'start_line': 15, 'end_line': 23, 'offset_start': 726, 'offset_end': 908, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.nonces', 'start_line': 24, 'end_line': 24, 'offset_start': 914, 'offset_end': 976, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20Permit.DOMAIN_SEPARATOR', 'start_line': 25, 'end_line': 25, 'offset_start': 982, 'offset_end': 1041, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC20Permit', 'contract_code': '{\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    function nonces(address owner) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 32, 'end_line': 40, 'offset_start': 1220, 'offset_end': 1549, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 41, 'end_line': 43, 'offset_start': 1555, 'offset_end': 1705, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 44, 'end_line': 50, 'offset_start': 1711, 'offset_end': 2102, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 51, 'end_line': 54, 'offset_start': 2108, 'offset_end': 2361, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 55, 'end_line': 58, 'offset_start': 2367, 'offset_end': 2619, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 59, 'end_line': 72, 'offset_start': 2625, 'offset_end': 3036, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 73, 'end_line': 79, 'offset_start': 3042, 'offset_end': 3265, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 80, 'end_line': 89, 'offset_start': 3271, 'offset_end': 3589, 'content': 'function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.tor', 'start_line': 99, 'end_line': 101, 'offset_start': 3860, 'offset_end': 3905, 'content': 'constructor() {\n        _paused = false;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.paused', 'start_line': 110, 'end_line': 112, 'offset_start': 4059, 'offset_end': 4142, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requireNotPaused', 'start_line': 113, 'end_line': 117, 'offset_start': 4148, 'offset_end': 4275, 'content': 'function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requirePaused', 'start_line': 118, 'end_line': 122, 'offset_start': 4281, 'offset_end': 4406, 'content': 'function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._pause', 'start_line': 123, 'end_line': 126, 'offset_start': 4412, 'offset_end': 4526, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._unpause', 'start_line': 127, 'end_line': 130, 'offset_start': 4532, 'offset_end': 4648, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    bool private _paused;\n    event Paused(address account);\n    event Unpaused(address account);\n    error EnforcedPause();\n    error ExpectedPause();\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.pendingOwner', 'start_line': 137, 'end_line': 139, 'offset_start': 4892, 'offset_end': 4990, 'content': 'function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.transferOwnership', 'start_line': 140, 'end_line': 143, 'offset_start': 4996, 'offset_end': 5173, 'content': 'function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step._transferOwnership', 'start_line': 144, 'end_line': 147, 'offset_start': 5179, 'offset_end': 5331, 'content': 'function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable2Step.acceptOwnership', 'start_line': 148, 'end_line': 154, 'offset_start': 5337, 'offset_end': 5565, 'content': 'function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }', 'contract_name': 'Ownable2Step', 'contract_code': '{\n    address private _pendingOwner;\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.tor', 'start_line': 180, 'end_line': 183, 'offset_start': 6658, 'offset_end': 6793, 'content': 'constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.claim', 'start_line': 184, 'end_line': 203, 'offset_start': 6799, 'offset_end': 7611, 'content': 'function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.setAirdropConfig', 'start_line': 204, 'end_line': 207, 'offset_start': 7617, 'offset_end': 7767, 'content': 'function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.withdraw', 'start_line': 208, 'end_line': 211, 'offset_start': 7773, 'offset_end': 7937, 'content': 'function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.pause', 'start_line': 212, 'end_line': 214, 'offset_start': 7943, 'offset_end': 8003, 'content': 'function pause() external onlyOwner {\n        _pause();\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleAirdrop.unpause', 'start_line': 215, 'end_line': 217, 'offset_start': 8009, 'offset_end': 8073, 'content': 'function unpause() external onlyOwner {\n        _unpause();\n    }', 'contract_name': 'MerkleAirdrop', 'contract_code': '{\n    using SafeERC20 for IERC20;\n    struct AirdropConfig {\n        bytes32 merkleRoot;\n        uint128 startTime;\n        uint128 endTime;\n    }\n    error ClaimNotAvailable();\n    error InvalidProof();\n    error UserAlreadyClaimed();\n    event ConfigUpdated(AirdropConfig config);\n    event UserClaimed(address user, uint256 amount);\n    event TokenWithdrawn(address owner, uint256 amount);\n    IERC20 public immutable ultiToken;\n    AirdropConfig public airdropConfig;\n    string public name;\n    mapping(address => uint256) public userClaimedAmounts;\n    constructor(string memory name_, address token_) Ownable(_msgSender()) {\n        name = name_;\n        ultiToken = IERC20(token_);\n    }\n    function claim(uint256 amount, bytes32[] calldata proof) external whenNotPaused {\n        bytes32 merkleRoot = airdropConfig.merkleRoot;\n        if (\n            block.timestamp < airdropConfig.startTime ||\n            block.timestamp > airdropConfig.endTime ||\n            merkleRoot == 0x0\n        ) {\n            revert ClaimNotAvailable();\n        }\n        if (userClaimedAmounts[_msgSender()] > 0) {\n            revert UserAlreadyClaimed();\n        }\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_msgSender(), amount))));\n        if (!MerkleProof.verify(proof, merkleRoot, leaf)) {\n            revert InvalidProof();\n        }\n        userClaimedAmounts[_msgSender()] = amount;\n        emit UserClaimed(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function setAirdropConfig(AirdropConfig calldata config) external onlyOwner {\n        airdropConfig = config;\n        emit ConfigUpdated(config);\n    }\n    function withdraw(uint256 amount) external onlyOwner {\n        emit TokenWithdrawn(_msgSender(), amount);\n        ultiToken.safeTransfer(_msgSender(), amount);\n    }\n    function pause() external onlyOwner {\n        _pause();\n    }\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 226, 'end_line': 231, 'offset_start': 8409, 'offset_end': 8595, 'content': 'constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 236, 'end_line': 238, 'offset_start': 8668, 'offset_end': 8752, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 239, 'end_line': 243, 'offset_start': 8758, 'offset_end': 8919, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 244, 'end_line': 246, 'offset_start': 8925, 'offset_end': 9025, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 247, 'end_line': 252, 'offset_start': 9031, 'offset_end': 9245, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 253, 'end_line': 257, 'offset_start': 9251, 'offset_end': 9437, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verify', 'start_line': 262, 'end_line': 264, 'offset_start': 9534, 'offset_end': 9687, 'content': 'function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verifyCalldata', 'start_line': 265, 'end_line': 267, 'offset_start': 9693, 'offset_end': 9864, 'content': 'function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProof', 'start_line': 268, 'end_line': 274, 'offset_start': 9870, 'offset_end': 10159, 'content': 'function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProofCalldata', 'start_line': 275, 'end_line': 281, 'offset_start': 10165, 'offset_end': 10464, 'content': 'function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerify', 'start_line': 282, 'end_line': 289, 'offset_start': 10470, 'offset_end': 10727, 'content': 'function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerifyCalldata', 'start_line': 290, 'end_line': 297, 'offset_start': 10733, 'offset_end': 11010, 'content': 'function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProof', 'start_line': 298, 'end_line': 332, 'offset_start': 11016, 'offset_end': 12287, 'content': 'function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProofCalldata', 'start_line': 333, 'end_line': 367, 'offset_start': 12293, 'offset_end': 13576, 'content': 'function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._hashPair', 'start_line': 368, 'end_line': 370, 'offset_start': 13582, 'offset_end': 13728, 'content': 'function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._efficientHash', 'start_line': 371, 'end_line': 377, 'offset_start': 13734, 'offset_end': 13951, 'content': 'function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    error MerkleProofInvalidMultiproof();\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 387, 'end_line': 389, 'offset_start': 14351, 'offset_end': 14510, 'content': 'function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 390, 'end_line': 392, 'offset_start': 14516, 'offset_end': 14703, 'content': 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeIncreaseAllowance', 'start_line': 393, 'end_line': 396, 'offset_start': 14709, 'offset_end': 14933, 'content': 'function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeDecreaseAllowance', 'start_line': 397, 'end_line': 405, 'offset_start': 14939, 'offset_end': 15406, 'content': 'function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.forceApprove', 'start_line': 406, 'end_line': 412, 'offset_start': 15412, 'offset_end': 15790, 'content': 'function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturn', 'start_line': 413, 'end_line': 418, 'offset_start': 15796, 'offset_end': 16085, 'content': 'function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20._callOptionalReturnBool', 'start_line': 419, 'end_line': 422, 'offset_start': 16091, 'offset_end': 16383, 'content': 'function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    using Address for address;\n    error SafeERC20FailedOperation(address token);\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 426, 'end_line': 428, 'offset_start': 16444, 'offset_end': 16539, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 429, 'end_line': 431, 'offset_start': 16545, 'offset_end': 16643, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._contextSuffixLength', 'start_line': 432, 'end_line': 434, 'offset_start': 16649, 'offset_end': 16745, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8/0x61c3d91b883e4f0a38205e2a10808505bd5d28c8.sol'}
