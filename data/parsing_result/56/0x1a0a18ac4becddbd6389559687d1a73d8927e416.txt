{'type': 'FunctionDefinition', 'name': 'IStableSwap.get_dy', 'start_line': 4, 'end_line': 8, 'offset_start': 53, 'offset_end': 167, 'content': 'function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwap.exchange', 'start_line': 9, 'end_line': 14, 'offset_start': 173, 'offset_end': 294, 'content': 'function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwap.coins', 'start_line': 15, 'end_line': 15, 'offset_start': 300, 'offset_end': 357, 'content': 'function coins(uint256 i) external view returns (address);', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwap.balances', 'start_line': 16, 'end_line': 16, 'offset_start': 363, 'offset_end': 423, 'content': 'function balances(uint256 i) external view returns (uint256);', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwap.A', 'start_line': 17, 'end_line': 17, 'offset_start': 429, 'offset_end': 473, 'content': 'function A() external view returns (uint256);', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwap.fee', 'start_line': 18, 'end_line': 18, 'offset_start': 479, 'offset_end': 525, 'content': 'function fee() external view returns (uint256);', 'contract_name': 'IStableSwap', 'contract_code': '{\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 minDy\n    ) external payable;\n    function coins(uint256 i) external view returns (address);\n    function balances(uint256 i) external view returns (uint256);\n    function A() external view returns (uint256);\n    function fee() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.allowance', 'start_line': 71, 'end_line': 71, 'offset_start': 1963, 'offset_end': 2056, 'content': 'function allowance(address, address, address) external view returns (uint160, uint48, uint48);', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.approve', 'start_line': 72, 'end_line': 72, 'offset_start': 2062, 'offset_end': 2154, 'content': 'function approve(address token, address spender, uint160 amount, uint48 expiration) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.permit', 'start_line': 73, 'end_line': 73, 'offset_start': 2160, 'offset_end': 2259, 'content': 'function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.permit', 'start_line': 74, 'end_line': 74, 'offset_start': 2265, 'offset_end': 2362, 'content': 'function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.transferFrom', 'start_line': 75, 'end_line': 75, 'offset_start': 2368, 'offset_end': 2455, 'content': 'function transferFrom(address from, address to, uint160 amount, address token) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.transferFrom', 'start_line': 76, 'end_line': 76, 'offset_start': 2461, 'offset_end': 2544, 'content': 'function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.lockdown', 'start_line': 77, 'end_line': 77, 'offset_start': 2550, 'offset_end': 2615, 'content': 'function lockdown(TokenSpenderPair[] calldata approvals) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IAllowanceTransfer.invalidateNonces', 'start_line': 78, 'end_line': 78, 'offset_start': 2621, 'offset_end': 2704, 'content': 'function invalidateNonces(address token, address spender, uint48 newNonce) external;', 'contract_name': 'IAllowanceTransfer', 'contract_code': '{\n    error AllowanceExpired(uint256 deadline);\n    error InsufficientAllowance(uint256 amount);\n    error ExcessiveInvalidation();\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n    event Lockdown(address indexed owner, address token, address spender);\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PermitBatch {\n        PermitDetails[] details;\n        address spender;\n        uint256 sigDeadline;\n    }\n    struct PackedAllowance {\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n    struct TokenSpenderPair {\n        address token;\n        address spender;\n    }\n    struct AllowanceTransferDetails {\n        address from;\n        address to;\n        uint160 amount;\n        address token;\n    }\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeNFTMarket.buyTokenUsingBNB', 'start_line': 82, 'end_line': 85, 'offset_start': 2766, 'offset_end': 2870, 'content': 'function buyTokenUsingBNB(\n        address _collection, \n        uint256 _tokenId\n    ) external payable;', 'contract_name': 'IPancakeNFTMarket', 'contract_code': '{\n    function buyTokenUsingBNB(\n        address _collection, \n        uint256 _tokenId\n    ) external payable;\n    function buyTokenUsingWBNB(\n        address _collection,\n        uint256 _tokenId,\n        uint256 _price\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeNFTMarket.buyTokenUsingWBNB', 'start_line': 86, 'end_line': 90, 'offset_start': 2876, 'offset_end': 2996, 'content': 'function buyTokenUsingWBNB(\n        address _collection,\n        uint256 _tokenId,\n        uint256 _price\n    ) external;', 'contract_name': 'IPancakeNFTMarket', 'contract_code': '{\n    function buyTokenUsingBNB(\n        address _collection, \n        uint256 _tokenId\n    ) external payable;\n    function buyTokenUsingWBNB(\n        address _collection,\n        uint256 _tokenId,\n        uint256 _price\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.slot0', 'start_line': 94, 'end_line': 105, 'offset_start': 3061, 'offset_end': 3378, 'content': 'function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.feeGrowthGlobal0X128', 'start_line': 106, 'end_line': 106, 'offset_start': 3384, 'offset_end': 3447, 'content': 'function feeGrowthGlobal0X128() external view returns (uint256);', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.feeGrowthGlobal1X128', 'start_line': 107, 'end_line': 107, 'offset_start': 3453, 'offset_end': 3516, 'content': 'function feeGrowthGlobal1X128() external view returns (uint256);', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.protocolFees', 'start_line': 108, 'end_line': 108, 'offset_start': 3522, 'offset_end': 3600, 'content': 'function protocolFees() external view returns (uint128 token0, uint128 token1);', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.liquidity', 'start_line': 109, 'end_line': 109, 'offset_start': 3606, 'offset_end': 3658, 'content': 'function liquidity() external view returns (uint128);', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.ticks', 'start_line': 110, 'end_line': 122, 'offset_start': 3664, 'offset_end': 4060, 'content': 'function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.tickBitmap', 'start_line': 123, 'end_line': 123, 'offset_start': 4066, 'offset_end': 4137, 'content': 'function tickBitmap(int16 wordPosition) external view returns (uint256);', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.positions', 'start_line': 124, 'end_line': 133, 'offset_start': 4143, 'offset_end': 4421, 'content': 'function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolState.observations', 'start_line': 134, 'end_line': 142, 'offset_start': 4427, 'offset_end': 4674, 'content': 'function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );', 'contract_name': 'IPancakeV3PoolState', 'contract_code': '{\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint32 feeProtocol,\n            bool unlocked\n        );\n    function feeGrowthGlobal0X128() external view returns (uint256);\n    function feeGrowthGlobal1X128() external view returns (uint256);\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n    function liquidity() external view returns (uint128);\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddress', 'start_line': 148, 'end_line': 153, 'offset_start': 4798, 'offset_end': 5053, 'content': 'function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toPool', 'start_line': 154, 'end_line': 162, 'offset_start': 5059, 'offset_end': 5499, 'content': 'function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toLengthOffset', 'start_line': 163, 'end_line': 176, 'offset_start': 5505, 'offset_end': 6038, 'content': 'function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toBytes', 'start_line': 177, 'end_line': 183, 'offset_start': 6044, 'offset_end': 6315, 'content': 'function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toAddressArray', 'start_line': 184, 'end_line': 190, 'offset_start': 6321, 'offset_end': 6603, 'content': 'function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toBytesArray', 'start_line': 191, 'end_line': 197, 'offset_start': 6609, 'offset_end': 6887, 'content': 'function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'BytesLib.toUintArray', 'start_line': 198, 'end_line': 204, 'offset_start': 6893, 'offset_end': 7169, 'content': 'function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }', 'contract_name': 'BytesLib', 'contract_code': '{\n    error SliceOutOfBounds();\n    function toAddress(bytes calldata _bytes) internal pure returns (address _address) {\n        if (_bytes.length < Constants.ADDR_SIZE) revert SliceOutOfBounds();\n        assembly {\n            _address := shr(96, calldataload(_bytes.offset))\n        }\n    }\n    function toPool(bytes calldata _bytes) internal pure returns (address token0, uint24 fee, address token1) {\n        if (_bytes.length < Constants.V3_POP_OFFSET) revert SliceOutOfBounds();\n        assembly {\n            let firstWord := calldataload(_bytes.offset)\n            token0 := shr(96, firstWord)\n            fee := and(shr(72, firstWord), 0xffffff)\n            token1 := shr(96, calldataload(add(_bytes.offset, 23)))\n        }\n    }\n    function toLengthOffset(bytes calldata _bytes, uint256 _arg)\n        internal\n        pure\n        returns (uint256 length, uint256 offset)\n    {\n        uint256 relativeOffset;\n        assembly {\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))\n            length := calldataload(lengthPtr)\n            offset := add(lengthPtr, 0x20)\n            relativeOffset := sub(offset, _bytes.offset)\n        }\n        if (_bytes.length < length + relativeOffset) revert SliceOutOfBounds();\n    }\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toAddressArray(bytes calldata _bytes, uint256 _arg) internal pure returns (address[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toBytesArray(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n    function toUintArray(bytes calldata _bytes, uint256 _arg) internal pure returns (uint[] calldata res) {\n        (uint256 length, uint256 offset) = toLengthOffset(_bytes, _arg);\n        assembly {\n            res.length := length\n            res.offset := offset\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwapFactory.pairLength', 'start_line': 221, 'end_line': 221, 'offset_start': 7553, 'offset_end': 7606, 'content': 'function pairLength() external view returns (uint256);', 'contract_name': 'IStableSwapFactory', 'contract_code': '{\n    struct StableSwapPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address LPContract;\n    }\n    struct StableSwapThreePoolPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address token2;\n        address LPContract;\n    }\n    function pairLength() external view returns (uint256);\n    function getPairInfo(address _tokenA, address _tokenB) \n        external \n        view \n        returns (StableSwapPairInfo memory info);\n    function getThreePoolPairInfo(address _tokenA, address _tokenB)\n        external\n        view\n        returns (StableSwapThreePoolPairInfo memory info);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwapFactory.getPairInfo', 'start_line': 222, 'end_line': 225, 'offset_start': 7612, 'offset_end': 7748, 'content': 'function getPairInfo(address _tokenA, address _tokenB) \n        external \n        view \n        returns (StableSwapPairInfo memory info);', 'contract_name': 'IStableSwapFactory', 'contract_code': '{\n    struct StableSwapPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address LPContract;\n    }\n    struct StableSwapThreePoolPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address token2;\n        address LPContract;\n    }\n    function pairLength() external view returns (uint256);\n    function getPairInfo(address _tokenA, address _tokenB) \n        external \n        view \n        returns (StableSwapPairInfo memory info);\n    function getThreePoolPairInfo(address _tokenA, address _tokenB)\n        external\n        view\n        returns (StableSwapThreePoolPairInfo memory info);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwapFactory.getThreePoolPairInfo', 'start_line': 226, 'end_line': 229, 'offset_start': 7754, 'offset_end': 7905, 'content': 'function getThreePoolPairInfo(address _tokenA, address _tokenB)\n        external\n        view\n        returns (StableSwapThreePoolPairInfo memory info);', 'contract_name': 'IStableSwapFactory', 'contract_code': '{\n    struct StableSwapPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address LPContract;\n    }\n    struct StableSwapThreePoolPairInfo {\n        address swapContract;\n        address token0;\n        address token1;\n        address token2;\n        address LPContract;\n    }\n    function pairLength() external view returns (uint256);\n    function getPairInfo(address _tokenA, address _tokenB) \n        external \n        view \n        returns (StableSwapPairInfo memory info);\n    function getThreePoolPairInfo(address _tokenA, address _tokenB)\n        external\n        view\n        returns (StableSwapThreePoolPairInfo memory info);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.permit2TransferFrom', 'start_line': 254, 'end_line': 256, 'offset_start': 9137, 'offset_end': 9293, 'content': 'function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.permit2TransferFrom', 'start_line': 257, 'end_line': 265, 'offset_start': 9299, 'offset_end': 9673, 'content': 'function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Permit2Payments.payOrPermit2Transfer', 'start_line': 266, 'end_line': 269, 'offset_start': 9679, 'offset_end': 9935, 'content': 'function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }', 'contract_name': 'Permit2Payments', 'contract_code': '{\n    using SafeCast160 for uint256;\n    error FromAddressIsNotOwner();\n    function permit2TransferFrom(address token, address from, address to, uint160 amount) internal {\n        PERMIT2.transferFrom(from, to, amount, token);\n    }\n    function permit2TransferFrom(IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails, address owner)\n        internal\n    {\n        uint256 batchLength = batchDetails.length;\n        for (uint256 i = 0; i < batchLength; ++i) {\n            if (batchDetails[i].from != owner) revert FromAddressIsNotOwner();\n        }\n        PERMIT2.transferFrom(batchDetails);\n    }\n    function payOrPermit2Transfer(address token, address payer, address recipient, uint256 amount) internal {\n        if (payer == address(this)) pay(token, recipient, amount);\n        else permit2TransferFrom(token, payer, recipient, amount.toUint160());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast160.toUint160', 'start_line': 274, 'end_line': 277, 'offset_start': 10014, 'offset_end': 10177, 'content': 'function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }', 'contract_name': 'SafeCast160', 'contract_code': '{\n    error UnsafeCast();\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) revert UnsafeCast();\n        return uint160(value);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tokenURI', 'start_line': 286, 'end_line': 286, 'offset_start': 10547, 'offset_end': 10620, 'content': 'function tokenURI(uint256 id) public view virtual returns (string memory);', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.ownerOf', 'start_line': 289, 'end_line': 291, 'offset_start': 10730, 'offset_end': 10878, 'content': 'function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.balanceOf', 'start_line': 292, 'end_line': 295, 'offset_start': 10884, 'offset_end': 11050, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tor', 'start_line': 298, 'end_line': 301, 'offset_start': 11182, 'offset_end': 11292, 'content': 'constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.approve', 'start_line': 302, 'end_line': 307, 'offset_start': 11298, 'offset_end': 11576, 'content': 'function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.setApprovalForAll', 'start_line': 308, 'end_line': 311, 'offset_start': 11582, 'offset_end': 11783, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.transferFrom', 'start_line': 312, 'end_line': 330, 'offset_start': 11789, 'offset_end': 12357, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 331, 'end_line': 343, 'offset_start': 12363, 'offset_end': 12757, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 344, 'end_line': 357, 'offset_start': 12763, 'offset_end': 13188, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.supportsInterface', 'start_line': 358, 'end_line': 363, 'offset_start': 13194, 'offset_end': 13421, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._mint', 'start_line': 364, 'end_line': 372, 'offset_start': 13427, 'offset_end': 13738, 'content': 'function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._burn', 'start_line': 373, 'end_line': 382, 'offset_start': 13744, 'offset_end': 14054, 'content': 'function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 383, 'end_line': 391, 'offset_start': 14060, 'offset_end': 14398, 'content': 'function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 392, 'end_line': 404, 'offset_start': 14404, 'offset_end': 14793, 'content': 'function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    string public name;\n    string public symbol;\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n    mapping(uint256 => address) internal _ownerOf;\n    mapping(address => uint256) internal _balanceOf;\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), "ZERO_ADDRESS");\n        return _balanceOf[owner];\n    }\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");\n        getApproved[id] = spender;\n        emit Approval(owner, spender, id);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], "WRONG_FROM");\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            "NOT_AUTHORIZED"\n        );\n        unchecked {\n            _balanceOf[from]--;\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        delete getApproved[id];\n        emit Transfer(from, to, id);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0x80ac58cd || \n            interfaceId == 0x5b5e139f; \n    }\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), "INVALID_RECIPIENT");\n        require(_ownerOf[id] == address(0), "ALREADY_MINTED");\n        unchecked {\n            _balanceOf[to]++;\n        }\n        _ownerOf[id] = to;\n        emit Transfer(address(0), to, id);\n    }\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n        require(owner != address(0), "NOT_MINTED");\n        unchecked {\n            _balanceOf[owner]--;\n        }\n        delete _ownerOf[id];\n        delete getApproved[id];\n        emit Transfer(owner, address(0), id);\n    }\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721TokenReceiver.onERC721Received', 'start_line': 407, 'end_line': 414, 'offset_start': 14841, 'offset_end': 15050, 'content': 'function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }', 'contract_name': 'ERC721TokenReceiver', 'contract_code': '{\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC721Received', 'start_line': 421, 'end_line': 423, 'offset_start': 15405, 'offset_end': 15558, 'content': 'function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC1155Received', 'start_line': 424, 'end_line': 426, 'offset_start': 15564, 'offset_end': 15728, 'content': 'function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.onERC1155BatchReceived', 'start_line': 427, 'end_line': 433, 'offset_start': 15734, 'offset_end': 15958, 'content': 'function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Callbacks.supportsInterface', 'start_line': 434, 'end_line': 437, 'offset_start': 15964, 'offset_end': 16220, 'content': 'function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'Callbacks', 'contract_code': '{\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC721Receiver).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'LockAndMsgSender.map', 'start_line': 455, 'end_line': 463, 'offset_start': 16752, 'offset_end': 17049, 'content': 'function map(address recipient) internal view returns (address) {\n        if (recipient == Constants.MSG_SENDER) {\n            return lockedBy;\n        } else if (recipient == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }', 'contract_name': 'LockAndMsgSender', 'contract_code': '{\n    error ContractLocked();\n    address internal constant NOT_LOCKED_FLAG = address(1);\n    address internal lockedBy = NOT_LOCKED_FLAG;\n    modifier isNotLocked() {\n        if (msg.sender != address(this)) {\n            if (lockedBy != NOT_LOCKED_FLAG) revert ContractLocked();\n            lockedBy = msg.sender;\n            _;\n            lockedBy = NOT_LOCKED_FLAG;\n        } else {\n            _;\n        }\n    }\n    function map(address recipient) internal view returns (address) {\n        if (recipient == Constants.MSG_SENDER) {\n            return lockedBy;\n        } else if (recipient == Constants.ADDRESS_THIS) {\n            return address(this);\n        } else {\n            return recipient;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH9.deposit', 'start_line': 468, 'end_line': 468, 'offset_start': 17181, 'offset_end': 17216, 'content': 'function deposit() external payable;', 'contract_name': 'IWETH9', 'contract_code': '{\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IWETH9.withdraw', 'start_line': 469, 'end_line': 469, 'offset_start': 17222, 'offset_end': 17257, 'content': 'function withdraw(uint256) external;', 'contract_name': 'IWETH9', 'contract_code': '{\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toUint160', 'start_line': 473, 'end_line': 475, 'offset_start': 17309, 'offset_end': 17419, 'content': 'function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt128', 'start_line': 476, 'end_line': 478, 'offset_start': 17425, 'offset_end': 17531, 'content': 'function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeCast.toInt256', 'start_line': 479, 'end_line': 482, 'offset_start': 17537, 'offset_end': 17657, 'content': 'function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }', 'contract_name': 'SafeCast', 'contract_code': '{\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155Receiver.onERC1155Received', 'start_line': 487, 'end_line': 493, 'offset_start': 17777, 'offset_end': 17955, 'content': 'function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC1155Receiver', 'contract_code': '{\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155Receiver.onERC1155BatchReceived', 'start_line': 494, 'end_line': 500, 'offset_start': 17961, 'offset_end': 18168, 'content': 'function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC1155Receiver', 'contract_code': '{\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'StableSwapRouter.tor', 'start_line': 521, 'end_line': 527, 'offset_start': 19170, 'offset_end': 19353, 'content': 'constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }', 'contract_name': 'StableSwapRouter', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    using UniversalRouterHelper for address;\n    error StableTooLittleReceived();\n    error StableTooMuchRequested();\n    error StableInvalidPath();\n    address public stableSwapFactory;\n    address public stableSwapInfo;\n    event SetStableSwap(address indexed factory, address indexed info);\n    constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }\n    function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }\n    function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }\n    function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }\n    function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'StableSwapRouter.setStableSwap', 'start_line': 528, 'end_line': 536, 'offset_start': 19359, 'offset_end': 19659, 'content': 'function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }', 'contract_name': 'StableSwapRouter', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    using UniversalRouterHelper for address;\n    error StableTooLittleReceived();\n    error StableTooMuchRequested();\n    error StableInvalidPath();\n    address public stableSwapFactory;\n    address public stableSwapInfo;\n    event SetStableSwap(address indexed factory, address indexed info);\n    constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }\n    function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }\n    function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }\n    function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }\n    function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'StableSwapRouter._stableSwap', 'start_line': 537, 'end_line': 551, 'offset_start': 19665, 'offset_end': 20350, 'content': 'function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }', 'contract_name': 'StableSwapRouter', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    using UniversalRouterHelper for address;\n    error StableTooLittleReceived();\n    error StableTooMuchRequested();\n    error StableInvalidPath();\n    address public stableSwapFactory;\n    address public stableSwapInfo;\n    event SetStableSwap(address indexed factory, address indexed info);\n    constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }\n    function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }\n    function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }\n    function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }\n    function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'StableSwapRouter.stableSwapExactInput', 'start_line': 552, 'end_line': 570, 'offset_start': 20356, 'offset_end': 21096, 'content': 'function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }', 'contract_name': 'StableSwapRouter', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    using UniversalRouterHelper for address;\n    error StableTooLittleReceived();\n    error StableTooMuchRequested();\n    error StableInvalidPath();\n    address public stableSwapFactory;\n    address public stableSwapInfo;\n    event SetStableSwap(address indexed factory, address indexed info);\n    constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }\n    function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }\n    function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }\n    function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }\n    function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'StableSwapRouter.stableSwapExactOutput', 'start_line': 571, 'end_line': 584, 'offset_start': 21102, 'offset_end': 21705, 'content': 'function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }', 'contract_name': 'StableSwapRouter', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    using UniversalRouterHelper for address;\n    error StableTooLittleReceived();\n    error StableTooMuchRequested();\n    error StableInvalidPath();\n    address public stableSwapFactory;\n    address public stableSwapInfo;\n    event SetStableSwap(address indexed factory, address indexed info);\n    constructor(\n        address _stableSwapFactory,\n        address _stableSwapInfo\n    ) {\n        stableSwapFactory = _stableSwapFactory;\n        stableSwapInfo = _stableSwapInfo;\n    }\n    function setStableSwap(\n        address _factory,\n        address _info\n    ) external onlyOwner {\n        require(_factory != address(0) && _info != address(0));\n        stableSwapFactory = _factory;\n        stableSwapInfo = _info;\n        emit SetStableSwap(stableSwapFactory, stableSwapInfo);\n    }\n    function _stableSwap(\n        address[] calldata path,\n        uint256[] calldata flag\n    ) private {\n        unchecked {\n            if (path.length - 1 != flag.length) revert StableInvalidPath();\n            for (uint256 i; i < flag.length; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 k, uint256 j, address swapContract) = stableSwapFactory.getStableInfo(input, output, flag[i]); \n                uint256 amountIn = ERC20(input).balanceOf(address(this));\n                ERC20(input).safeApprove(swapContract, amountIn);\n                IStableSwap(swapContract).exchange(k, j, amountIn, 0);\n            }\n        }\n    }\n    function stableSwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        if (\n            amountIn != Constants.ALREADY_PAID && amountIn != Constants.CONTRACT_BALANCE\n        ) {\n            payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        _stableSwap(path, flag); \n        uint256 amountOut = tokenOut.balanceOf(address(this));\n        if (amountOut < amountOutMinimum) revert StableTooLittleReceived();\n        if (recipient != address(this)) pay(address(tokenOut), recipient, amountOut);\n    }\n    function stableSwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        uint256[] calldata flag,\n        address payer\n    ) internal {\n        uint256 amountIn = stableSwapFactory.getStableAmountsIn(stableSwapInfo, path, flag, amountOut)[0];\n        if (amountIn > amountInMaximum) revert StableTooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, address(this), amountIn);\n        _stableSwap(path, flag); \n        if (recipient != address(this)) pay(path[path.length - 1], recipient, amountOut);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.tor', 'start_line': 600, 'end_line': 600, 'offset_start': 22496, 'offset_end': 22624, 'content': 'constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.execute', 'start_line': 601, 'end_line': 607, 'offset_start': 22630, 'offset_end': 22825, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.execute', 'start_line': 608, 'end_line': 632, 'offset_start': 22831, 'offset_end': 23796, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.successRequired', 'start_line': 633, 'end_line': 635, 'offset_start': 23802, 'offset_end': 23936, 'content': 'function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.pause', 'start_line': 636, 'end_line': 638, 'offset_start': 23942, 'offset_end': 24016, 'content': 'function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.unpause', 'start_line': 639, 'end_line': 641, 'offset_start': 24022, 'offset_end': 24097, 'content': 'function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouter.', 'start_line': 642, 'end_line': 642, 'offset_start': 24103, 'offset_end': 24131, 'content': 'receive() external payable {}', 'contract_name': 'UniversalRouter', 'contract_code': '{\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\n        _;\n    }\n    constructor(RouterParameters memory params) RouterImmutables(params) StableSwapRouter(params.stableFactory, params.stableInfo) {}\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline)\n        external\n        payable\n        checkDeadline(deadline)\n    {\n        execute(commands, inputs);\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) \n        public \n        payable \n        override \n        isNotLocked \n        whenNotPaused \n    {\n        bool success;\n        bytes memory output;\n        uint256 numCommands = commands.length;\n        if (inputs.length != numCommands) revert LengthMismatch();\n        for (uint256 commandIndex = 0; commandIndex < numCommands;) {\n            bytes1 command = commands[commandIndex];\n            bytes calldata input = inputs[commandIndex];\n            (success, output) = dispatch(command, input);\n            if (!success && successRequired(command)) {\n                revert ExecutionFailed({commandIndex: commandIndex, message: output});\n            }\n            unchecked {\n                commandIndex++;\n            }\n        }\n        uint256 balance = address(this).balance;\n        if ((balance > 0) && (msg.sender != address(this))) sweep(Constants.ETH, msg.sender, balance);\n    }\n    function successRequired(bytes1 command) internal pure returns (bool) {\n        return command & Commands.FLAG_ALLOW_REVERT == 0;\n    }\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n    }\n    receive() external payable {}\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 648, 'end_line': 648, 'offset_start': 24342, 'offset_end': 24396, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 649, 'end_line': 649, 'offset_start': 24402, 'offset_end': 24469, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 650, 'end_line': 650, 'offset_start': 24475, 'offset_end': 24544, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 651, 'end_line': 651, 'offset_start': 24550, 'offset_end': 24632, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 652, 'end_line': 652, 'offset_start': 24638, 'offset_end': 24711, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 653, 'end_line': 657, 'offset_start': 24717, 'offset_end': 24834, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.name', 'start_line': 722, 'end_line': 722, 'offset_start': 26661, 'offset_end': 26714, 'content': 'function name() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.symbol', 'start_line': 723, 'end_line': 723, 'offset_start': 26720, 'offset_end': 26775, 'content': 'function symbol() external pure returns (string memory);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.decimals', 'start_line': 724, 'end_line': 724, 'offset_start': 26781, 'offset_end': 26830, 'content': 'function decimals() external pure returns (uint8);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.totalSupply', 'start_line': 725, 'end_line': 725, 'offset_start': 26836, 'offset_end': 26887, 'content': 'function totalSupply() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.balanceOf', 'start_line': 726, 'end_line': 726, 'offset_start': 26893, 'offset_end': 26955, 'content': 'function balanceOf(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.allowance', 'start_line': 727, 'end_line': 727, 'offset_start': 26961, 'offset_end': 27040, 'content': 'function allowance(address owner, address spender) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.approve', 'start_line': 728, 'end_line': 728, 'offset_start': 27046, 'offset_end': 27115, 'content': 'function approve(address spender, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transfer', 'start_line': 729, 'end_line': 729, 'offset_start': 27121, 'offset_end': 27186, 'content': 'function transfer(address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.transferFrom', 'start_line': 730, 'end_line': 730, 'offset_start': 27192, 'offset_end': 27275, 'content': 'function transferFrom(address from, address to, uint value) external returns (bool);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.DOMAIN_SEPARATOR', 'start_line': 731, 'end_line': 731, 'offset_start': 27281, 'offset_end': 27340, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.PERMIT_TYPEHASH', 'start_line': 732, 'end_line': 732, 'offset_start': 27346, 'offset_end': 27404, 'content': 'function PERMIT_TYPEHASH() external pure returns (bytes32);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.nonces', 'start_line': 733, 'end_line': 733, 'offset_start': 27410, 'offset_end': 27469, 'content': 'function nonces(address owner) external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.permit', 'start_line': 734, 'end_line': 734, 'offset_start': 27475, 'offset_end': 27589, 'content': 'function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.MINIMUM_LIQUIDITY', 'start_line': 746, 'end_line': 746, 'offset_start': 27983, 'offset_end': 28040, 'content': 'function MINIMUM_LIQUIDITY() external pure returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.factory', 'start_line': 747, 'end_line': 747, 'offset_start': 28046, 'offset_end': 28096, 'content': 'function factory() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token0', 'start_line': 748, 'end_line': 748, 'offset_start': 28102, 'offset_end': 28151, 'content': 'function token0() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.token1', 'start_line': 749, 'end_line': 749, 'offset_start': 28157, 'offset_end': 28206, 'content': 'function token1() external view returns (address);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.getReserves', 'start_line': 750, 'end_line': 750, 'offset_start': 28212, 'offset_end': 28320, 'content': 'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price0CumulativeLast', 'start_line': 751, 'end_line': 751, 'offset_start': 28326, 'offset_end': 28386, 'content': 'function price0CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.price1CumulativeLast', 'start_line': 752, 'end_line': 752, 'offset_start': 28392, 'offset_end': 28452, 'content': 'function price1CumulativeLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.kLast', 'start_line': 753, 'end_line': 753, 'offset_start': 28458, 'offset_end': 28503, 'content': 'function kLast() external view returns (uint);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.mint', 'start_line': 754, 'end_line': 754, 'offset_start': 28509, 'offset_end': 28568, 'content': 'function mint(address to) external returns (uint liquidity);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.burn', 'start_line': 755, 'end_line': 755, 'offset_start': 28574, 'offset_end': 28645, 'content': 'function burn(address to) external returns (uint amount0, uint amount1);', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.swap', 'start_line': 756, 'end_line': 756, 'offset_start': 28651, 'offset_end': 28740, 'content': 'function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.skim', 'start_line': 757, 'end_line': 757, 'offset_start': 28746, 'offset_end': 28780, 'content': 'function skim(address to) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.sync', 'start_line': 758, 'end_line': 758, 'offset_start': 28786, 'offset_end': 28810, 'content': 'function sync() external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniswapV2Pair.initialize', 'start_line': 759, 'end_line': 759, 'offset_start': 28816, 'offset_end': 28862, 'content': 'function initialize(address, address) external;', 'contract_name': 'IUniswapV2Pair', 'contract_code': '{\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.initialize', 'start_line': 763, 'end_line': 763, 'offset_start': 28929, 'offset_end': 28979, 'content': 'function initialize(uint160 sqrtPriceX96) external;', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.mint', 'start_line': 764, 'end_line': 770, 'offset_start': 28985, 'offset_end': 29186, 'content': 'function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.collect', 'start_line': 771, 'end_line': 777, 'offset_start': 29192, 'offset_end': 29411, 'content': 'function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.burn', 'start_line': 778, 'end_line': 782, 'offset_start': 29417, 'offset_end': 29562, 'content': 'function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.swap', 'start_line': 783, 'end_line': 789, 'offset_start': 29568, 'offset_end': 29785, 'content': 'function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.flash', 'start_line': 790, 'end_line': 795, 'offset_start': 29791, 'offset_end': 29926, 'content': 'function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolActions.increaseObservationCardinalityNext', 'start_line': 796, 'end_line': 796, 'offset_start': 29932, 'offset_end': 30019, 'content': 'function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;', 'contract_name': 'IPancakeV3PoolActions', 'contract_code': '{\n    function initialize(uint160 sqrtPriceX96) external;\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.dispatch', 'start_line': 821, 'end_line': 1119, 'offset_start': 31262, 'offset_end': 47983, 'content': 'function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error BuyPancakeNFTFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.execute', 'start_line': 1120, 'end_line': 1120, 'offset_start': 47989, 'offset_end': 48080, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error BuyPancakeNFTFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.callAndTransfer721', 'start_line': 1121, 'end_line': 1136, 'offset_start': 48086, 'offset_end': 48737, 'content': 'function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error BuyPancakeNFTFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.callAndTransfer1155', 'start_line': 1137, 'end_line': 1154, 'offset_start': 48743, 'offset_end': 49503, 'content': 'function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error BuyPancakeNFTFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Dispatcher.getValueAndData', 'start_line': 1155, 'end_line': 1160, 'offset_start': 49509, 'offset_end': 49734, 'content': 'function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }', 'contract_name': 'Dispatcher', 'contract_code': '{\n    using BytesLib for bytes;\n    error InvalidCommandType(uint256 commandType);\n    error BuyPunkFailed();\n    error BuyPancakeNFTFailed();\n    error InvalidOwnerERC721();\n    error InvalidOwnerERC1155();\n    error BalanceTooLow();\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal returns (bool success, bytes memory output) {\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\n        success = true;\n        if (command < Commands.FOURTH_IF_BOUNDARY) {\n            if (command < Commands.SECOND_IF_BOUNDARY) {\n                if (command < Commands.FIRST_IF_BOUNDARY) {\n                    if (command == Commands.V3_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V3_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        bytes calldata path = inputs.toBytes(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v3SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM) {\n                        address token;\n                        address recipient;\n                        uint160 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amount := calldataload(add(inputs.offset, 0x40))\n                        }\n                        permit2TransferFrom(token, lockedBy, map(recipient), amount);\n                    } else if (command == Commands.PERMIT2_PERMIT_BATCH) {\n                        (IAllowanceTransfer.PermitBatch memory permitBatch,) =\n                            abi.decode(inputs, (IAllowanceTransfer.PermitBatch, bytes));\n                        bytes calldata data = inputs.toBytes(1);\n                        PERMIT2.permit(lockedBy, permitBatch, data);\n                    } else if (command == Commands.SWEEP) {\n                        address token;\n                        address recipient;\n                        uint160 amountMin;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            amountMin := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweep(token, map(recipient), amountMin);\n                    } else if (command == Commands.TRANSFER) {\n                        address token;\n                        address recipient;\n                        uint256 value;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            value := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.pay(token, map(recipient), value);\n                    } else if (command == Commands.PAY_PORTION) {\n                        address token;\n                        address recipient;\n                        uint256 bips;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            bips := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.payPortion(token, map(recipient), bips);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.V2_SWAP_EXACT_IN) {\n                        address recipient;\n                        uint256 amountIn;\n                        uint256 amountOutMin;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountIn := calldataload(add(inputs.offset, 0x20))\n                            amountOutMin := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactInput(map(recipient), amountIn, amountOutMin, path, payer);\n                    } else if (command == Commands.V2_SWAP_EXACT_OUT) {\n                        address recipient;\n                        uint256 amountOut;\n                        uint256 amountInMax;\n                        bool payerIsUser;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountOut := calldataload(add(inputs.offset, 0x20))\n                            amountInMax := calldataload(add(inputs.offset, 0x40))\n                            payerIsUser := calldataload(add(inputs.offset, 0x80))\n                        }\n                        address[] calldata path = inputs.toAddressArray(3);\n                        address payer = payerIsUser ? lockedBy : address(this);\n                        v2SwapExactOutput(map(recipient), amountOut, amountInMax, path, payer);\n                    } else if (command == Commands.PERMIT2_PERMIT) {\n                        IAllowanceTransfer.PermitSingle calldata permitSingle;\n                        assembly {\n                            permitSingle := inputs.offset\n                        }\n                        bytes calldata data = inputs.toBytes(6); \n                        PERMIT2.permit(lockedBy, permitSingle, data);\n                    } else if (command == Commands.WRAP_ETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.wrapETH(map(recipient), amountMin);\n                    } else if (command == Commands.UNWRAP_WETH) {\n                        address recipient;\n                        uint256 amountMin;\n                        assembly {\n                            recipient := calldataload(inputs.offset)\n                            amountMin := calldataload(add(inputs.offset, 0x20))\n                        }\n                        Payments.unwrapWETH9(map(recipient), amountMin);\n                    } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\n                        (IAllowanceTransfer.AllowanceTransferDetails[] memory batchDetails) =\n                            abi.decode(inputs, (IAllowanceTransfer.AllowanceTransferDetails[]));\n                        permit2TransferFrom(batchDetails, lockedBy);\n                    } else if (command == Commands.BALANCE_CHECK_ERC20) {\n                        address owner;\n                        address token;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            minBalance := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC20(token).balanceOf(owner) >= minBalance);\n                        if (!success) output = abi.encodePacked(BalanceTooLow.selector);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            } else {\n                if (command < Commands.THIRD_IF_BOUNDARY) {\n                    if (command == Commands.OWNER_CHECK_721) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        success = (ERC721(token).ownerOf(id) == owner);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC721.selector);\n                    } else if (command == Commands.OWNER_CHECK_1155) {\n                        address owner;\n                        address token;\n                        uint256 id;\n                        uint256 minBalance;\n                        assembly {\n                            owner := calldataload(inputs.offset)\n                            token := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            minBalance := calldataload(add(inputs.offset, 0x60))\n                        }\n                        success = (ERC1155(token).balanceOf(owner, id) >= minBalance);\n                        if (!success) output = abi.encodePacked(InvalidOwnerERC1155.selector);\n                    } else if (command == Commands.SWEEP_ERC721) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                        }\n                        Payments.sweepERC721(token, map(recipient), id);\n                    } else if (command == Commands.SWEEP_ERC1155) {\n                        address token;\n                        address recipient;\n                        uint256 id;\n                        uint256 amount;\n                        assembly {\n                            token := calldataload(inputs.offset)\n                            recipient := calldataload(add(inputs.offset, 0x20))\n                            id := calldataload(add(inputs.offset, 0x40))\n                            amount := calldataload(add(inputs.offset, 0x60))\n                        }\n                        Payments.sweepERC1155(token, map(recipient), id, amount);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                } else {\n                    if (command == Commands.SEAPORT_V1_5) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_5.call{value: value}(data);\n                    } else if (command == Commands.SEAPORT_V1_4) {\n                        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n                        (success, output) = SEAPORT_V1_4.call{value: value}(data);\n                    } else if (command == Commands.LOOKS_RARE_V2) {\n                        uint256 value;\n                        assembly {\n                            value := calldataload(inputs.offset)\n                        }\n                        bytes calldata data = inputs.toBytes(1);\n                        (success, output) = LOOKS_RARE_V2.call{value: value}(data);\n                    } else if (command == Commands.X2Y2_721) {\n                        (success, output) = callAndTransfer721(inputs, X2Y2);\n                    } else if (command == Commands.X2Y2_1155) {\n                        (success, output) = callAndTransfer1155(inputs, X2Y2);\n                    } else {\n                        revert InvalidCommandType(command);\n                    }\n                }\n            }\n        } else {\n            if (command == Commands.EXECUTE_SUB_PLAN) {\n                bytes calldata _commands = inputs.toBytes(0);\n                bytes[] calldata _inputs = inputs.toBytesArray(1);\n                (success, output) =\n                    (address(this)).call(abi.encodeWithSelector(Dispatcher.execute.selector, _commands, _inputs));                \n            } else if (command == Commands.APPROVE_ERC20) {\n                ERC20 token;\n                RouterImmutables.Spenders spender;\n                assembly {\n                    token := calldataload(inputs.offset)\n                    spender := calldataload(add(inputs.offset, 0x20))\n                }\n                Payments.approveERC20(token, spender);\n            } else if (command == Commands.STABLE_SWAP_EXACT_IN) {\n                address recipient;\n                uint256 amountIn;\n                uint256 amountOutMin;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountIn := calldataload(add(inputs.offset, 0x20))\n                    amountOutMin := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactInput(map(recipient), amountIn, amountOutMin, path, flag, payer);\n            } else if (command == Commands.STABLE_SWAP_EXACT_OUT) {\n                address recipient;\n                uint256 amountOut;\n                uint256 amountInMax;\n                bool payerIsUser;\n                assembly {\n                    recipient := calldataload(inputs.offset)\n                    amountOut := calldataload(add(inputs.offset, 0x20))\n                    amountInMax := calldataload(add(inputs.offset, 0x40))\n                    payerIsUser := calldataload(add(inputs.offset, 0xa0))\n                }\n                address[] calldata path = inputs.toAddressArray(3);\n                uint256[] calldata flag = inputs.toUintArray(4);\n                address payer = payerIsUser ? lockedBy : address(this);\n                stableSwapExactOutput(map(recipient), amountOut, amountInMax, path, flag, payer);\n            } else if (command == Commands.PANCAKE_NFT_BNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 value;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    value := calldataload(add(inputs.offset, 0x40))\n                }\n                (success, output) = PANCAKESWAP_NFT_MARKET.call{value: value}(\n                    abi.encodeWithSelector(IPancakeNFTMarket.buyTokenUsingBNB.selector, collection, tokenId)\n                );\n                if (!success) output = abi.encodePacked(BuyPancakeNFTFailed.selector);\n            } else if (command == Commands.PANCAKE_NFT_WBNB) {\n                address collection;\n                uint256 tokenId;\n                uint256 price;\n                assembly {\n                    collection := calldataload(inputs.offset)\n                    tokenId := calldataload(add(inputs.offset, 0x20))\n                    price := calldataload(add(inputs.offset, 0x40))\n                }\n                IPancakeNFTMarket(PANCAKESWAP_NFT_MARKET).buyTokenUsingWBNB(collection, tokenId, price);\n            } else {\n                revert InvalidCommandType(command);\n            }\n        }\n    }\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable virtual;\n    function callAndTransfer721(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC721(token).safeTransferFrom(address(this), map(recipient), id);\n    }\n    function callAndTransfer1155(bytes calldata inputs, address protocol)\n        internal\n        returns (bool success, bytes memory output)\n    {\n        (uint256 value, bytes calldata data) = getValueAndData(inputs);\n        address recipient;\n        address token;\n        uint256 id;\n        uint256 amount;\n        assembly {\n            recipient := calldataload(add(inputs.offset, 0x40))\n            token := calldataload(add(inputs.offset, 0x60))\n            id := calldataload(add(inputs.offset, 0x80))\n            amount := calldataload(add(inputs.offset, 0xa0))\n        }\n        (success, output) = protocol.call{value: value}(data);\n        if (success) ERC1155(token).safeTransferFrom(address(this), map(recipient), id, amount, new bytes(0));\n    }\n    function getValueAndData(bytes calldata inputs) internal pure returns (uint256 value, bytes calldata data) {\n        assembly {\n            value := calldataload(inputs.offset)\n        }\n        data = inputs.toBytes(1);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.tor', 'start_line': 1168, 'end_line': 1170, 'offset_start': 49935, 'offset_end': 49980, 'content': 'constructor() {\n        _paused = false;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.paused', 'start_line': 1179, 'end_line': 1181, 'offset_start': 50134, 'offset_end': 50217, 'content': 'function paused() public view virtual returns (bool) {\n        return _paused;\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requireNotPaused', 'start_line': 1182, 'end_line': 1184, 'offset_start': 50223, 'offset_end': 50328, 'content': 'function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._requirePaused', 'start_line': 1185, 'end_line': 1187, 'offset_start': 50334, 'offset_end': 50439, 'content': 'function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._pause', 'start_line': 1188, 'end_line': 1191, 'offset_start': 50445, 'offset_end': 50559, 'content': 'function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._unpause', 'start_line': 1192, 'end_line': 1195, 'offset_start': 50565, 'offset_end': 50681, 'content': 'function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    constructor() {\n        _paused = false;\n    }\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), "Pausable: paused");\n    }\n    function _requirePaused() internal view virtual {\n        require(paused(), "Pausable: not paused");\n    }\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'RewardsCollector.collectRewards', 'start_line': 1206, 'end_line': 1212, 'offset_start': 51144, 'offset_end': 51519, 'content': 'function collectRewards(bytes calldata looksRareClaim) external {\n        (bool success,) = LOOKS_RARE_REWARDS_DISTRIBUTOR.call(looksRareClaim);\n        if (!success) revert UnableToClaim();\n        uint256 balance = LOOKS_RARE_TOKEN.balanceOf(address(this));\n        LOOKS_RARE_TOKEN.safeTransfer(ROUTER_REWARDS_DISTRIBUTOR, balance);\n        emit RewardsSent(balance);\n    }', 'contract_name': 'RewardsCollector', 'contract_code': '{\n    using SafeTransferLib for ERC20;\n    event RewardsSent(uint256 amount);\n    error UnableToClaim();\n    function collectRewards(bytes calldata looksRareClaim) external {\n        (bool success,) = LOOKS_RARE_REWARDS_DISTRIBUTOR.call(looksRareClaim);\n        if (!success) revert UnableToClaim();\n        uint256 balance = LOOKS_RARE_TOKEN.balanceOf(address(this));\n        LOOKS_RARE_TOKEN.safeTransfer(ROUTER_REWARDS_DISTRIBUTOR, balance);\n        emit RewardsSent(balance);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'RouterImmutables.tor', 'start_line': 1258, 'end_line': 1275, 'offset_start': 53146, 'offset_end': 54048, 'content': 'constructor(RouterParameters memory params) {\n        PERMIT2 = IAllowanceTransfer(params.permit2);\n        WETH9 = IWETH9(params.weth9);\n        SEAPORT_V1_5 = params.seaportV1_5;\n        SEAPORT_V1_4 = params.seaportV1_4;\n        OPENSEA_CONDUIT = params.openseaConduit;\n        X2Y2 = params.x2y2;\n        LOOKS_RARE_V2 = params.looksRareV2;\n        LOOKS_RARE_TOKEN = ERC20(params.looksRareToken);\n        LOOKS_RARE_REWARDS_DISTRIBUTOR = params.looksRareRewardsDistributor;\n        ROUTER_REWARDS_DISTRIBUTOR = params.routerRewardsDistributor;\n        PANCAKESWAP_V2_FACTORY = params.v2Factory;\n        PANCAKESWAP_V2_PAIR_INIT_CODE_HASH = params.v2InitCodeHash;\n        PANCAKESWAP_V3_FACTORY = params.v3Factory;\n        PANCAKESWAP_V3_POOL_INIT_CODE_HASH = params.v3InitCodeHash;\n        PANCAKESWAP_V3_DEPLOYER = params.v3Deployer;\n        PANCAKESWAP_NFT_MARKET = params.pancakeNFTMarket;\n    }', 'contract_name': 'RouterImmutables', 'contract_code': '{\n    IWETH9 internal immutable WETH9;\n    IAllowanceTransfer internal immutable PERMIT2;\n    address internal immutable SEAPORT_V1_5;\n    address internal immutable SEAPORT_V1_4;\n    address internal immutable OPENSEA_CONDUIT;\n    address internal immutable X2Y2;\n    address internal immutable LOOKS_RARE_V2;\n    ERC20 internal immutable LOOKS_RARE_TOKEN;\n    address internal immutable LOOKS_RARE_REWARDS_DISTRIBUTOR;\n    address internal immutable ROUTER_REWARDS_DISTRIBUTOR;\n    address internal immutable PANCAKESWAP_V2_FACTORY;\n    bytes32 internal immutable PANCAKESWAP_V2_PAIR_INIT_CODE_HASH;\n    address internal immutable PANCAKESWAP_V3_FACTORY;\n    bytes32 internal immutable PANCAKESWAP_V3_POOL_INIT_CODE_HASH;\n    address internal immutable PANCAKESWAP_V3_DEPLOYER;\n    address internal immutable PANCAKESWAP_NFT_MARKET;\n    enum Spenders {\n        OSConduit\n    }\n    constructor(RouterParameters memory params) {\n        PERMIT2 = IAllowanceTransfer(params.permit2);\n        WETH9 = IWETH9(params.weth9);\n        SEAPORT_V1_5 = params.seaportV1_5;\n        SEAPORT_V1_4 = params.seaportV1_4;\n        OPENSEA_CONDUIT = params.openseaConduit;\n        X2Y2 = params.x2y2;\n        LOOKS_RARE_V2 = params.looksRareV2;\n        LOOKS_RARE_TOKEN = ERC20(params.looksRareToken);\n        LOOKS_RARE_REWARDS_DISTRIBUTOR = params.looksRareRewardsDistributor;\n        ROUTER_REWARDS_DISTRIBUTOR = params.routerRewardsDistributor;\n        PANCAKESWAP_V2_FACTORY = params.v2Factory;\n        PANCAKESWAP_V2_PAIR_INIT_CODE_HASH = params.v2InitCodeHash;\n        PANCAKESWAP_V3_FACTORY = params.v3Factory;\n        PANCAKESWAP_V3_POOL_INIT_CODE_HASH = params.v3InitCodeHash;\n        PANCAKESWAP_V3_DEPLOYER = params.v3Deployer;\n        PANCAKESWAP_NFT_MARKET = params.pancakeNFTMarket;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getStableInfo', 'start_line': 1290, 'end_line': 1312, 'offset_start': 54666, 'offset_end': 55751, 'content': 'function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getStableAmountsIn', 'start_line': 1313, 'end_line': 1329, 'offset_start': 55757, 'offset_end': 56518, 'content': 'function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.sortTokens', 'start_line': 1330, 'end_line': 1332, 'offset_start': 56524, 'offset_end': 56719, 'content': 'function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.pairForPreSorted', 'start_line': 1333, 'end_line': 1347, 'offset_start': 56725, 'offset_end': 57176, 'content': "function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }", 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.pairFor', 'start_line': 1348, 'end_line': 1355, 'offset_start': 57182, 'offset_end': 57484, 'content': 'function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.pairAndToken0For', 'start_line': 1356, 'end_line': 1364, 'offset_start': 57490, 'offset_end': 57825, 'content': 'function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.pairAndReservesFor', 'start_line': 1365, 'end_line': 1374, 'offset_start': 57831, 'offset_end': 58321, 'content': 'function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getAmountOut', 'start_line': 1375, 'end_line': 1385, 'offset_start': 58327, 'offset_end': 58776, 'content': 'function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getAmountIn', 'start_line': 1386, 'end_line': 1395, 'offset_start': 58782, 'offset_end': 59181, 'content': 'function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getAmountInMultihop', 'start_line': 1396, 'end_line': 1409, 'offset_start': 59187, 'offset_end': 59768, 'content': 'function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.hasMultiplePools', 'start_line': 1410, 'end_line': 1412, 'offset_start': 59774, 'offset_end': 59926, 'content': 'function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.decodeFirstPool', 'start_line': 1413, 'end_line': 1415, 'offset_start': 59932, 'offset_end': 60063, 'content': 'function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.getFirstPool', 'start_line': 1416, 'end_line': 1418, 'offset_start': 60069, 'offset_end': 60204, 'content': 'function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.decodeFirstToken', 'start_line': 1419, 'end_line': 1421, 'offset_start': 60210, 'offset_end': 60337, 'content': 'function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.skipToken', 'start_line': 1422, 'end_line': 1424, 'offset_start': 60343, 'offset_end': 60481, 'content': 'function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }', 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'UniversalRouterHelper.computePoolAddress', 'start_line': 1425, 'end_line': 1447, 'offset_start': 60487, 'offset_end': 61180, 'content': "function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }", 'contract_name': 'UniversalRouterHelper', 'contract_code': "{\n    using BytesLib for bytes;\n    error InvalidPoolAddress();\n    error InvalidPoolLength();\n    error InvalidReserves();\n    error InvalidPath();\n    function getStableInfo(\n        address stableSwapFactory,\n        address input,\n        address output,\n        uint256 flag\n    ) internal view returns (uint256 i, uint256 j, address swapContract) {\n        if (flag == 2) {\n            IStableSwapFactory.StableSwapPairInfo memory info = IStableSwapFactory(stableSwapFactory).getPairInfo(input, output);\n            i = input == info.token0 ? 0 : 1;\n            j = (i == 0) ? 1 : 0;\n            swapContract = info.swapContract;\n        } else if (flag == 3) {\n            IStableSwapFactory.StableSwapThreePoolPairInfo memory info = IStableSwapFactory(stableSwapFactory).getThreePoolPairInfo(input, output);\n            if (input == info.token0) i = 0;\n            else if (input == info.token1) i = 1;\n            else if (input == info.token2) i = 2;\n            if (output == info.token0) j = 0;\n            else if (output == info.token1) j = 1;\n            else if (output == info.token2) j = 2;\n            swapContract = info.swapContract;\n        }\n        if (swapContract == address(0)) revert InvalidPoolAddress();\n    }\n    function getStableAmountsIn(\n        address stableSwapFactory,\n        address stableSwapInfo,\n        address[] calldata path,\n        uint256[] calldata flag,\n        uint256 amountOut\n    ) internal view returns (uint256[] memory amounts) {\n        uint256 length = path.length;\n        if (length < 2) revert InvalidPoolLength();\n        amounts = new uint256[](length);\n        amounts[length - 1] = amountOut;\n        for (uint256 i = length - 1; i > 0; i--) {\n            uint256 last = i - 1;\n            (uint256 k, uint256 j, address swapContract) = getStableInfo(stableSwapFactory, path[last], path[i], flag[last]);\n            amounts[last] = IStableSwapInfo(stableSwapInfo).get_dx(swapContract, k, j, amounts[i], type(uint256).max);\n        }\n    }\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n    function pairForPreSorted(address factory, bytes32 initCodeHash, address token0, address token1)\n        private\n        pure\n        returns (address pair)\n    {\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), initCodeHash)\n                    )\n                )\n            )\n        );\n    }\n    function pairFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair)\n    {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndToken0For(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        internal\n        pure\n        returns (address pair, address token0)\n    {\n        address token1;\n        (token0, token1) = sortTokens(tokenA, tokenB);\n        pair = pairForPreSorted(factory, initCodeHash, token0, token1);\n    }\n    function pairAndReservesFor(address factory, bytes32 initCodeHash, address tokenA, address tokenB)\n        private\n        view\n        returns (address pair, uint256 reserveA, uint256 reserveB)\n    {\n        address token0;\n        (pair, token0) = pairAndToken0For(factory, initCodeHash, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountOut)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 amountInWithFee = amountIn * 9975;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        internal\n        pure\n        returns (uint256 amountIn)\n    {\n        if (reserveIn == 0 || reserveOut == 0) revert InvalidReserves();\n        uint256 numerator = reserveIn * amountOut * 10000;\n        uint256 denominator = (reserveOut - amountOut) * 9975;\n        amountIn = (numerator / denominator) + 1;\n    }\n    function getAmountInMultihop(address factory, bytes32 initCodeHash, uint256 amountOut, address[] calldata path)\n        internal\n        view\n        returns (uint256 amount, address pair)\n    {\n        if (path.length < 2) revert InvalidPath();\n        amount = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            (pair, reserveIn, reserveOut) = pairAndReservesFor(factory, initCodeHash, path[i - 1], path[i]);\n            amount = getAmountIn(amount, reserveIn, reserveOut);\n        }\n    }\n    function hasMultiplePools(bytes calldata path) internal pure returns (bool) {\n        return path.length >= Constants.MULTIPLE_V3_POOLS_MIN_LENGTH;\n    }\n    function decodeFirstPool(bytes calldata path) internal pure returns (address, uint24, address) {\n        return path.toPool();\n    }\n    function getFirstPool(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[:Constants.V3_POP_OFFSET];\n    }\n    function decodeFirstToken(bytes calldata path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress();\n    }\n    function skipToken(bytes calldata path) internal pure returns (bytes calldata) {\n        return path[Constants.NEXT_V3_POOL_OFFSET:];\n    }\n    function computePoolAddress(\n        address deployer, \n        bytes32 initCodeHash, \n        address tokenA, \n        address tokenB, \n        uint24 fee\n    ) internal pure returns (address pool) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex'ff',\n                            deployer,\n                            keccak256(abi.encode(tokenA, tokenB, fee)),\n                            initCodeHash\n                        )\n                    )\n                )\n            )\n        );\n    }\n}", 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter._v2Swap', 'start_line': 1461, 'end_line': 1486, 'offset_start': 61818, 'offset_end': 63386, 'content': 'function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniversalRouterHelper.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniversalRouterHelper.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniversalRouterHelper.pairAndToken0For(\n                        PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniversalRouterHelper.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniversalRouterHelper.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniversalRouterHelper.pairAndToken0For(\n                        PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniversalRouterHelper.pairFor(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniversalRouterHelper.getAmountInMultihop(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter.v2SwapExactInput', 'start_line': 1487, 'end_line': 1506, 'offset_start': 63392, 'offset_end': 64195, 'content': 'function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniversalRouterHelper.pairFor(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniversalRouterHelper.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniversalRouterHelper.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniversalRouterHelper.pairAndToken0For(\n                        PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniversalRouterHelper.pairFor(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniversalRouterHelper.getAmountInMultihop(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V2SwapRouter.v2SwapExactOutput', 'start_line': 1507, 'end_line': 1519, 'offset_start': 64201, 'offset_end': 64753, 'content': 'function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniversalRouterHelper.getAmountInMultihop(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }', 'contract_name': 'V2SwapRouter', 'contract_code': '{\n    error V2TooLittleReceived();\n    error V2TooMuchRequested();\n    error V2InvalidPath();\n    function _v2Swap(address[] calldata path, address recipient, address pair) private {\n        unchecked {\n            if (path.length < 2) revert V2InvalidPath();\n            (address token0,) = UniversalRouterHelper.sortTokens(path[0], path[1]);\n            uint256 finalPairIndex = path.length - 1;\n            uint256 penultimatePairIndex = finalPairIndex - 1;\n            for (uint256 i; i < finalPairIndex; i++) {\n                (address input, address output) = (path[i], path[i + 1]);\n                (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pair).getReserves();\n                (uint256 reserveInput, uint256 reserveOutput) =\n                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n                uint256 amountInput = ERC20(input).balanceOf(pair) - reserveInput;\n                uint256 amountOutput = UniversalRouterHelper.getAmountOut(amountInput, reserveInput, reserveOutput);\n                (uint256 amount0Out, uint256 amount1Out) =\n                    input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\n                address nextPair;\n                (nextPair, token0) = i < penultimatePairIndex\n                    ? UniversalRouterHelper.pairAndToken0For(\n                        PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, output, path[i + 2]\n                    )\n                    : (recipient, address(0));\n                IUniswapV2Pair(pair).swap(amount0Out, amount1Out, nextPair, new bytes(0));\n                pair = nextPair;\n            }\n        }\n    }\n    function v2SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        address firstPair =\n            UniversalRouterHelper.pairFor(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, path[0], path[1]);\n        if (\n            amountIn != Constants.ALREADY_PAID \n        ) {\n            payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        }\n        ERC20 tokenOut = ERC20(path[path.length - 1]);\n        uint256 balanceBefore = tokenOut.balanceOf(recipient);\n        _v2Swap(path, recipient, firstPair);\n        uint256 amountOut = tokenOut.balanceOf(recipient) - balanceBefore;\n        if (amountOut < amountOutMinimum) revert V2TooLittleReceived();\n    }\n    function v2SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        address[] calldata path,\n        address payer\n    ) internal {\n        (uint256 amountIn, address firstPair) =\n            UniversalRouterHelper.getAmountInMultihop(PANCAKESWAP_V2_FACTORY, PANCAKESWAP_V2_PAIR_INIT_CODE_HASH, amountOut, path);\n        if (amountIn > amountInMaximum) revert V2TooMuchRequested();\n        payOrPermit2Transfer(path[0], payer, firstPair, amountIn);\n        _v2Swap(path, recipient, firstPair);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 1526, 'end_line': 1528, 'offset_start': 64972, 'offset_end': 65034, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 1533, 'end_line': 1535, 'offset_start': 65107, 'offset_end': 65191, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 1536, 'end_line': 1538, 'offset_start': 65197, 'offset_end': 65326, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 1539, 'end_line': 1541, 'offset_start': 65332, 'offset_end': 65432, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 1542, 'end_line': 1545, 'offset_start': 65438, 'offset_end': 65635, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 1546, 'end_line': 1550, 'offset_start': 65641, 'offset_end': 65827, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.pancakeV3SwapCallback', 'start_line': 1575, 'end_line': 1594, 'offset_start': 67162, 'offset_end': 68384, 'content': 'function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': '{\n    using UniversalRouterHelper for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IPancakeV3Pool(UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.v3SwapExactInput', 'start_line': 1595, 'end_line': 1626, 'offset_start': 68390, 'offset_end': 69520, 'content': 'function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': '{\n    using UniversalRouterHelper for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IPancakeV3Pool(UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter.v3SwapExactOutput', 'start_line': 1627, 'end_line': 1640, 'offset_start': 69526, 'offset_end': 70123, 'content': 'function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': '{\n    using UniversalRouterHelper for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IPancakeV3Pool(UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'V3SwapRouter._swap', 'start_line': 1641, 'end_line': 1654, 'offset_start': 70129, 'offset_end': 70857, 'content': 'function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IPancakeV3Pool(UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }', 'contract_name': 'V3SwapRouter', 'contract_code': '{\n    using UniversalRouterHelper for bytes;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n    error V3InvalidSwap();\n    error V3TooLittleReceived();\n    error V3TooMuchRequested();\n    error V3InvalidAmountOut();\n    error V3InvalidCaller();\n    uint256 private constant DEFAULT_MAX_AMOUNT_IN = type(uint256).max;\n    uint256 private maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        if (amount0Delta <= 0 && amount1Delta <= 0) revert V3InvalidSwap(); \n        (, address payer) = abi.decode(data, (bytes, address));\n        bytes calldata path = data.toBytes(0);\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        if (UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee) != msg.sender) revert V3InvalidCaller();\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\n        if (isExactInput) {\n            payOrPermit2Transfer(tokenIn, payer, msg.sender, amountToPay);\n        } else {\n            if (path.hasMultiplePools()) {\n                path = path.skipToken();\n                _swap(-amountToPay.toInt256(), msg.sender, path, payer, false);\n            } else {\n                if (amountToPay > maxAmountInCached) revert V3TooMuchRequested();\n                payOrPermit2Transfer(tokenOut, payer, msg.sender, amountToPay);\n            }\n        }\n    }\n    function v3SwapExactInput(\n        address recipient,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        if (amountIn == Constants.CONTRACT_BALANCE) {\n            address tokenIn = path.decodeFirstToken();\n            amountIn = ERC20(tokenIn).balanceOf(address(this));\n        }\n        uint256 amountOut;\n        while (true) {\n            bool hasMultiplePools = path.hasMultiplePools();\n            (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) = _swap(\n                amountIn.toInt256(),\n                hasMultiplePools ? address(this) : recipient, \n                path.getFirstPool(), \n                payer, \n                true\n            );\n            amountIn = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            if (hasMultiplePools) {\n                payer = address(this);\n                path = path.skipToken();\n            } else {\n                amountOut = amountIn;\n                break;\n            }\n        }\n        if (amountOut < amountOutMinimum) revert V3TooLittleReceived();\n    }\n    function v3SwapExactOutput(\n        address recipient,\n        uint256 amountOut,\n        uint256 amountInMaximum,\n        bytes calldata path,\n        address payer\n    ) internal {\n        maxAmountInCached = amountInMaximum;\n        (int256 amount0Delta, int256 amount1Delta, bool zeroForOne) =\n            _swap(-amountOut.toInt256(), recipient, path, payer, false);\n        uint256 amountOutReceived = zeroForOne ? uint256(-amount1Delta) : uint256(-amount0Delta);\n        if (amountOutReceived != amountOut) revert V3InvalidAmountOut();\n        maxAmountInCached = DEFAULT_MAX_AMOUNT_IN;\n    }\n    function _swap(int256 amount, address recipient, bytes calldata path, address payer, bool isExactIn)\n        private\n        returns (int256 amount0Delta, int256 amount1Delta, bool zeroForOne)\n    {\n        (address tokenIn, uint24 fee, address tokenOut) = path.decodeFirstPool();\n        zeroForOne = isExactIn ? tokenIn < tokenOut : tokenOut < tokenIn;\n        (amount0Delta, amount1Delta) = IPancakeV3Pool(UniversalRouterHelper.computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)).swap(\n            recipient,\n            zeroForOne,\n            amount,\n            (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1),\n            abi.encode(path, payer)\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IRewardsCollector.collectRewards', 'start_line': 1659, 'end_line': 1659, 'offset_start': 70972, 'offset_end': 71035, 'content': 'function collectRewards(bytes calldata looksRareClaim) external;', 'contract_name': 'IRewardsCollector', 'contract_code': '{\n    function collectRewards(bytes calldata looksRareClaim) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IStableSwapInfo.get_dx', 'start_line': 1663, 'end_line': 1669, 'offset_start': 71095, 'offset_end': 71253, 'content': 'function get_dx(\n        address _swap,\n        uint256 i,\n        uint256 j,\n        uint256 dy,\n        uint256 max_dx\n    ) external view returns (uint256);', 'contract_name': 'IStableSwapInfo', 'contract_code': '{\n    function get_dx(\n        address _swap,\n        uint256 i,\n        uint256 j,\n        uint256 dy,\n        uint256 max_dx\n    ) external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.pay', 'start_line': 1686, 'end_line': 1695, 'offset_start': 71928, 'offset_end': 72305, 'content': 'function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.approveERC20', 'start_line': 1696, 'end_line': 1701, 'offset_start': 72311, 'offset_end': 72588, 'content': 'function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.payPortion', 'start_line': 1702, 'end_line': 1713, 'offset_start': 72594, 'offset_end': 73164, 'content': 'function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweep', 'start_line': 1714, 'end_line': 1725, 'offset_start': 73170, 'offset_end': 73730, 'content': 'function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweepERC721', 'start_line': 1726, 'end_line': 1728, 'offset_start': 73736, 'offset_end': 73888, 'content': 'function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.sweepERC1155', 'start_line': 1729, 'end_line': 1733, 'offset_start': 73894, 'offset_end': 74227, 'content': "function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }", 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.wrapETH', 'start_line': 1734, 'end_line': 1746, 'offset_start': 74233, 'offset_end': 74688, 'content': 'function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Payments.unwrapWETH9', 'start_line': 1747, 'end_line': 1758, 'offset_start': 74694, 'offset_end': 75093, 'content': 'function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }', 'contract_name': 'Payments', 'contract_code': "{\n    using SafeTransferLib for ERC20;\n    using SafeTransferLib for address;\n    error InsufficientToken();\n    error InsufficientETH();\n    error InvalidBips();\n    error InvalidSpender();\n    uint256 internal constant FEE_BIPS_BASE = 10_000;\n    function pay(address token, address recipient, uint256 value) internal {\n        if (token == Constants.ETH) {\n            recipient.safeTransferETH(value);\n        } else {\n            if (value == Constants.CONTRACT_BALANCE) {\n                value = ERC20(token).balanceOf(address(this));\n            }\n            ERC20(token).safeTransfer(recipient, value);\n        }\n    }\n    function approveERC20(ERC20 token, Spenders spender) internal {\n        address spenderAddress;\n        if (spender == Spenders.OSConduit) spenderAddress = OPENSEA_CONDUIT;\n        else revert InvalidSpender();\n        token.safeApprove(spenderAddress, type(uint256).max);\n    }\n    function payPortion(address token, address recipient, uint256 bips) internal {\n        if (bips == 0 || bips > FEE_BIPS_BASE) revert InvalidBips();\n        if (token == Constants.ETH) {\n            uint256 balance = address(this).balance;\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            recipient.safeTransferETH(amount);\n        } else {\n            uint256 balance = ERC20(token).balanceOf(address(this));\n            uint256 amount = (balance * bips) / FEE_BIPS_BASE;\n            ERC20(token).safeTransfer(recipient, amount);\n        }\n    }\n    function sweep(address token, address recipient, uint256 amountMinimum) internal {\n        uint256 balance;\n        if (token == Constants.ETH) {\n            balance = address(this).balance;\n            if (balance < amountMinimum) revert InsufficientETH();\n            if (balance > 0) recipient.safeTransferETH(balance);\n        } else {\n            balance = ERC20(token).balanceOf(address(this));\n            if (balance < amountMinimum) revert InsufficientToken();\n            if (balance > 0) ERC20(token).safeTransfer(recipient, balance);\n        }\n    }\n    function sweepERC721(address token, address recipient, uint256 id) internal {\n        ERC721(token).safeTransferFrom(address(this), recipient, id);\n    }\n    function sweepERC1155(address token, address recipient, uint256 id, uint256 amountMinimum) internal {\n        uint256 balance = ERC1155(token).balanceOf(address(this), id);\n        if (balance < amountMinimum) revert InsufficientToken();\n        ERC1155(token).safeTransferFrom(address(this), recipient, id, balance, bytes(''));\n    }\n    function wrapETH(address recipient, uint256 amount) internal {\n        if (amount == Constants.CONTRACT_BALANCE) {\n            amount = address(this).balance;\n        } else if (amount > address(this).balance) {\n            revert InsufficientETH();\n        }\n        if (amount > 0) {\n            WETH9.deposit{value: amount}();\n            if (recipient != address(this)) {\n                WETH9.transfer(recipient, amount);\n            }\n        }\n    }\n    function unwrapWETH9(address recipient, uint256 amountMinimum) internal {\n        uint256 value = WETH9.balanceOf(address(this));\n        if (value < amountMinimum) {\n            revert InsufficientETH();\n        }\n        if (value > 0) {\n            WETH9.withdraw(value);\n            if (recipient != address(this)) {\n                recipient.safeTransferETH(value);\n            }\n        }\n    }\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 1762, 'end_line': 1767, 'offset_start': 75153, 'offset_end': 75312, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.uri', 'start_line': 1789, 'end_line': 1789, 'offset_start': 75997, 'offset_end': 76065, 'content': 'function uri(uint256 id) public view virtual returns (string memory);', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.setApprovalForAll', 'start_line': 1790, 'end_line': 1793, 'offset_start': 76071, 'offset_end': 76272, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.safeTransferFrom', 'start_line': 1794, 'end_line': 1812, 'offset_start': 76278, 'offset_end': 76973, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.safeBatchTransferFrom', 'start_line': 1813, 'end_line': 1841, 'offset_start': 76979, 'offset_end': 78009, 'content': 'function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.balanceOfBatch', 'start_line': 1842, 'end_line': 1855, 'offset_start': 78015, 'offset_end': 78464, 'content': 'function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155.supportsInterface', 'start_line': 1856, 'end_line': 1861, 'offset_start': 78470, 'offset_end': 78697, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._mint', 'start_line': 1862, 'end_line': 1877, 'offset_start': 78703, 'offset_end': 79245, 'content': 'function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._batchMint', 'start_line': 1878, 'end_line': 1900, 'offset_start': 79251, 'offset_end': 80065, 'content': 'function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._batchBurn', 'start_line': 1901, 'end_line': 1915, 'offset_start': 80071, 'offset_end': 80551, 'content': 'function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155._burn', 'start_line': 1916, 'end_line': 1923, 'offset_start': 80557, 'offset_end': 80777, 'content': 'function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }', 'contract_name': 'ERC1155', 'contract_code': '{\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    function uri(uint256 id) public view virtual returns (string memory);\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, from, to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, "LENGTH_MISMATCH");\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], "NOT_AUTHORIZED");\n        uint256 id;\n        uint256 amount;\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, "LENGTH_MISMATCH");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || \n            interfaceId == 0xd9b67a26 || \n            interfaceId == 0x0e89341c; \n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            "UNSAFE_RECIPIENT"\n        );\n    }\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; \n        require(idsLength == amounts.length, "LENGTH_MISMATCH");\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155TokenReceiver.onERC1155Received', 'start_line': 1926, 'end_line': 1934, 'offset_start': 80826, 'offset_end': 81055, 'content': 'function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }', 'contract_name': 'ERC1155TokenReceiver', 'contract_code': '{\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1155TokenReceiver.onERC1155BatchReceived', 'start_line': 1935, 'end_line': 1943, 'offset_start': 81061, 'offset_end': 81322, 'content': 'function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }', 'contract_name': 'ERC1155TokenReceiver', 'contract_code': '{\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferETH', 'start_line': 1948, 'end_line': 1954, 'offset_start': 81424, 'offset_end': 81651, 'content': 'function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferFrom', 'start_line': 1955, 'end_line': 1974, 'offset_start': 81657, 'offset_end': 82413, 'content': 'function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransfer', 'start_line': 1975, 'end_line': 1992, 'offset_start': 82419, 'offset_end': 83089, 'content': 'function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeApprove', 'start_line': 1993, 'end_line': 2010, 'offset_start': 83095, 'offset_end': 83763, 'content': 'function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.tor', 'start_line': 2025, 'end_line': 2035, 'offset_start': 84376, 'offset_end': 84666, 'content': 'constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.approve', 'start_line': 2036, 'end_line': 2040, 'offset_start': 84672, 'offset_end': 84880, 'content': 'function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transfer', 'start_line': 2041, 'end_line': 2048, 'offset_start': 84886, 'offset_end': 85144, 'content': 'function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transferFrom', 'start_line': 2049, 'end_line': 2062, 'offset_start': 85150, 'offset_end': 85590, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.permit', 'start_line': 2063, 'end_line': 2101, 'offset_start': 85596, 'offset_end': 86944, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.DOMAIN_SEPARATOR', 'start_line': 2102, 'end_line': 2104, 'offset_start': 86950, 'offset_end': 87126, 'content': 'function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.computeDomainSeparator', 'start_line': 2105, 'end_line': 2116, 'offset_start': 87132, 'offset_end': 87577, 'content': 'function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._mint', 'start_line': 2117, 'end_line': 2123, 'offset_start': 87583, 'offset_end': 87794, 'content': 'function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._burn', 'start_line': 2124, 'end_line': 2130, 'offset_start': 87800, 'offset_end': 88017, 'content': 'function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 2134, 'end_line': 2134, 'offset_start': 88069, 'offset_end': 88144, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.factory', 'start_line': 2154, 'end_line': 2154, 'offset_start': 88710, 'offset_end': 88760, 'content': 'function factory() external view returns (address);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.token0', 'start_line': 2155, 'end_line': 2155, 'offset_start': 88766, 'offset_end': 88815, 'content': 'function token0() external view returns (address);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.token1', 'start_line': 2156, 'end_line': 2156, 'offset_start': 88821, 'offset_end': 88870, 'content': 'function token1() external view returns (address);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.fee', 'start_line': 2157, 'end_line': 2157, 'offset_start': 88876, 'offset_end': 88921, 'content': 'function fee() external view returns (uint24);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.tickSpacing', 'start_line': 2158, 'end_line': 2158, 'offset_start': 88927, 'offset_end': 88979, 'content': 'function tickSpacing() external view returns (int24);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolImmutables.maxLiquidityPerTick', 'start_line': 2159, 'end_line': 2159, 'offset_start': 88985, 'offset_end': 89047, 'content': 'function maxLiquidityPerTick() external view returns (uint128);', 'contract_name': 'IPancakeV3PoolImmutables', 'contract_code': '{\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickSpacing() external view returns (int24);\n    function maxLiquidityPerTick() external view returns (uint128);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IUniversalRouter.execute', 'start_line': 2170, 'end_line': 2170, 'offset_start': 89566, 'offset_end': 89667, 'content': 'function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;', 'contract_name': 'IUniversalRouter', 'contract_code': '{\n    error ExecutionFailed(uint256 commandIndex, bytes message);\n    error ETHNotAccepted();\n    error TransactionDeadlinePassed();\n    error LengthMismatch();\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolOwnerActions.setFeeProtocol', 'start_line': 2174, 'end_line': 2174, 'offset_start': 89739, 'offset_end': 89813, 'content': 'function setFeeProtocol(uint32 feeProtocol0, uint32 feeProtocol1) external;', 'contract_name': 'IPancakeV3PoolOwnerActions', 'contract_code': '{\n    function setFeeProtocol(uint32 feeProtocol0, uint32 feeProtocol1) external;\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function setLmPool(address lmPool) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolOwnerActions.collectProtocol', 'start_line': 2175, 'end_line': 2179, 'offset_start': 89819, 'offset_end': 89996, 'content': 'function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);', 'contract_name': 'IPancakeV3PoolOwnerActions', 'contract_code': '{\n    function setFeeProtocol(uint32 feeProtocol0, uint32 feeProtocol1) external;\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function setLmPool(address lmPool) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolOwnerActions.setLmPool', 'start_line': 2180, 'end_line': 2180, 'offset_start': 90002, 'offset_end': 90045, 'content': 'function setLmPool(address lmPool) external;', 'contract_name': 'IPancakeV3PoolOwnerActions', 'contract_code': '{\n    function setFeeProtocol(uint32 feeProtocol0, uint32 feeProtocol1) external;\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n    function setLmPool(address lmPool) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3SwapCallback.pancakeV3SwapCallback', 'start_line': 2222, 'end_line': 2226, 'offset_start': 91758, 'offset_end': 91890, 'content': 'function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;', 'contract_name': 'IPancakeV3SwapCallback', 'contract_code': '{\n    function pancakeV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolDerivedState.observe', 'start_line': 2230, 'end_line': 2233, 'offset_start': 91962, 'offset_end': 92141, 'content': 'function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);', 'contract_name': 'IPancakeV3PoolDerivedState', 'contract_code': '{\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'IPancakeV3PoolDerivedState.snapshotCumulativesInside', 'start_line': 2234, 'end_line': 2241, 'offset_start': 92147, 'offset_end': 92397, 'content': 'function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );', 'contract_name': 'IPancakeV3PoolDerivedState', 'contract_code': '{\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 2245, 'end_line': 2247, 'offset_start': 92457, 'offset_end': 92552, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 2248, 'end_line': 2250, 'offset_start': 92558, 'offset_end': 92656, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/56/0x1a0a18ac4becddbd6389559687d1a73d8927e416/0x1a0a18ac4becddbd6389559687d1a73d8927e416.sol'}
