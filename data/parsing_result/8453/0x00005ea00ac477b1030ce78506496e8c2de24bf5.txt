{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 14, 'end_line': 14, 'offset_start': 283, 'offset_end': 358, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verify', 'start_line': 117, 'end_line': 123, 'offset_start': 4013, 'offset_end': 4196, 'content': 'function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.verifyCalldata', 'start_line': 124, 'end_line': 130, 'offset_start': 4202, 'offset_end': 4403, 'content': 'function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProof', 'start_line': 131, 'end_line': 137, 'offset_start': 4409, 'offset_end': 4698, 'content': 'function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processProofCalldata', 'start_line': 138, 'end_line': 144, 'offset_start': 4704, 'offset_end': 5003, 'content': 'function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerify', 'start_line': 145, 'end_line': 152, 'offset_start': 5009, 'offset_end': 5266, 'content': 'function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.multiProofVerifyCalldata', 'start_line': 153, 'end_line': 160, 'offset_start': 5272, 'offset_end': 5549, 'content': 'function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProof', 'start_line': 161, 'end_line': 185, 'offset_start': 5555, 'offset_end': 6581, 'content': 'function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof.processMultiProofCalldata', 'start_line': 186, 'end_line': 210, 'offset_start': 6587, 'offset_end': 7625, 'content': 'function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._hashPair', 'start_line': 211, 'end_line': 213, 'offset_start': 7631, 'offset_end': 7777, 'content': 'function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'MerkleProof._efficientHash', 'start_line': 214, 'end_line': 220, 'offset_start': 7783, 'offset_end': 8000, 'content': 'function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }', 'contract_name': 'MerkleProof', 'contract_code': '{\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateAllowedSeaDrop', 'start_line': 238, 'end_line': 238, 'offset_start': 8535, 'offset_end': 8608, 'content': 'function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.mintSeaDrop', 'start_line': 239, 'end_line': 239, 'offset_start': 8614, 'offset_end': 8685, 'content': 'function mintSeaDrop(address minter, uint256 quantity) external payable;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.getMintStats', 'start_line': 240, 'end_line': 247, 'offset_start': 8691, 'offset_end': 8893, 'content': 'function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updatePublicDrop', 'start_line': 248, 'end_line': 251, 'offset_start': 8899, 'offset_end': 9008, 'content': 'function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateAllowList', 'start_line': 252, 'end_line': 255, 'offset_start': 9014, 'offset_end': 9128, 'content': 'function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateTokenGatedDrop', 'start_line': 256, 'end_line': 260, 'offset_start': 9134, 'offset_end': 9288, 'content': 'function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateDropURI', 'start_line': 261, 'end_line': 262, 'offset_start': 9294, 'offset_end': 9379, 'content': 'function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateCreatorPayoutAddress', 'start_line': 263, 'end_line': 266, 'offset_start': 9385, 'offset_end': 9495, 'content': 'function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateAllowedFeeRecipient', 'start_line': 267, 'end_line': 271, 'offset_start': 9501, 'offset_end': 9631, 'content': 'function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updateSignedMintValidationParams', 'start_line': 272, 'end_line': 276, 'offset_start': 9637, 'offset_end': 9816, 'content': 'function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'INonFungibleSeaDropToken.updatePayer', 'start_line': 277, 'end_line': 281, 'offset_start': 9822, 'offset_end': 9931, 'content': 'function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;', 'contract_name': 'INonFungibleSeaDropToken', 'contract_code': '{\n    error OnlyAllowedSeaDrop();\n    event AllowedSeaDropUpdated(address[] allowedSeaDrop);\n    function updateAllowedSeaDrop(address[] calldata allowedSeaDrop) external;\n    function mintSeaDrop(address minter, uint256 quantity) external payable;\n    function getMintStats(address minter)\n        external\n        view\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        );\n    function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external;\n    function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external;\n    function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external;\n    function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external;\n    function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external;\n    function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external;\n    function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.tor', 'start_line': 296, 'end_line': 306, 'offset_start': 10544, 'offset_end': 10834, 'content': 'constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.approve', 'start_line': 307, 'end_line': 311, 'offset_start': 10840, 'offset_end': 11048, 'content': 'function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transfer', 'start_line': 312, 'end_line': 319, 'offset_start': 11054, 'offset_end': 11312, 'content': 'function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transferFrom', 'start_line': 320, 'end_line': 333, 'offset_start': 11318, 'offset_end': 11758, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.permit', 'start_line': 334, 'end_line': 372, 'offset_start': 11764, 'offset_end': 13112, 'content': 'function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.DOMAIN_SEPARATOR', 'start_line': 373, 'end_line': 375, 'offset_start': 13118, 'offset_end': 13294, 'content': 'function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.computeDomainSeparator', 'start_line': 376, 'end_line': 387, 'offset_start': 13300, 'offset_end': 13745, 'content': 'function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._mint', 'start_line': 388, 'end_line': 394, 'offset_start': 13751, 'offset_end': 13962, 'content': 'function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20._burn', 'start_line': 395, 'end_line': 401, 'offset_start': 13968, 'offset_end': 14185, 'content': 'function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }', 'contract_name': 'ERC20', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; \n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        "\\x19\\x01",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n                    keccak256(bytes(name)),\n                    keccak256("1"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(address(0), to, amount);\n    }\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        unchecked {\n            totalSupply -= amount;\n        }\n        emit Transfer(from, address(0), amount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.mintPublic', 'start_line': 414, 'end_line': 419, 'offset_start': 14518, 'offset_end': 14679, 'content': 'function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.mintAllowList', 'start_line': 420, 'end_line': 427, 'offset_start': 14685, 'offset_end': 14923, 'content': 'function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.mintSigned', 'start_line': 428, 'end_line': 436, 'offset_start': 14929, 'offset_end': 15186, 'content': 'function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.mintAllowedTokenHolder', 'start_line': 437, 'end_line': 442, 'offset_start': 15192, 'offset_end': 15389, 'content': 'function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getPublicDrop', 'start_line': 443, 'end_line': 446, 'offset_start': 15395, 'offset_end': 15504, 'content': 'function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getCreatorPayoutAddress', 'start_line': 447, 'end_line': 450, 'offset_start': 15510, 'offset_end': 15619, 'content': 'function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getAllowListMerkleRoot', 'start_line': 451, 'end_line': 454, 'offset_start': 15625, 'offset_end': 15733, 'content': 'function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getFeeRecipientIsAllowed', 'start_line': 455, 'end_line': 458, 'offset_start': 15739, 'offset_end': 15868, 'content': 'function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getAllowedFeeRecipients', 'start_line': 459, 'end_line': 462, 'offset_start': 15874, 'offset_end': 15992, 'content': 'function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getSigners', 'start_line': 463, 'end_line': 466, 'offset_start': 15998, 'offset_end': 16103, 'content': 'function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getSignedMintValidationParams', 'start_line': 467, 'end_line': 470, 'offset_start': 16109, 'offset_end': 16266, 'content': 'function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getPayers', 'start_line': 471, 'end_line': 474, 'offset_start': 16272, 'offset_end': 16376, 'content': 'function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getPayerIsAllowed', 'start_line': 475, 'end_line': 478, 'offset_start': 16382, 'offset_end': 16497, 'content': 'function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getTokenGatedAllowedTokens', 'start_line': 479, 'end_line': 482, 'offset_start': 16503, 'offset_end': 16624, 'content': 'function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getTokenGatedDrop', 'start_line': 483, 'end_line': 486, 'offset_start': 16630, 'offset_end': 16777, 'content': 'function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.getAllowedNftTokenIdIsRedeemed', 'start_line': 487, 'end_line': 491, 'offset_start': 16783, 'offset_end': 16954, 'content': 'function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateDropURI', 'start_line': 492, 'end_line': 492, 'offset_start': 16960, 'offset_end': 17016, 'content': 'function updateDropURI(string calldata dropURI) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updatePublicDrop', 'start_line': 493, 'end_line': 493, 'offset_start': 17022, 'offset_end': 17088, 'content': 'function updatePublicDrop(PublicDrop calldata publicDrop) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateAllowList', 'start_line': 494, 'end_line': 494, 'offset_start': 17094, 'offset_end': 17165, 'content': 'function updateAllowList(AllowListData calldata allowListData) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateTokenGatedDrop', 'start_line': 495, 'end_line': 498, 'offset_start': 17171, 'offset_end': 17296, 'content': 'function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateCreatorPayoutAddress', 'start_line': 499, 'end_line': 499, 'offset_start': 17302, 'offset_end': 17369, 'content': 'function updateCreatorPayoutAddress(address payoutAddress) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateAllowedFeeRecipient', 'start_line': 500, 'end_line': 501, 'offset_start': 17375, 'offset_end': 17462, 'content': 'function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updateSignedMintValidationParams', 'start_line': 502, 'end_line': 505, 'offset_start': 17468, 'offset_end': 17620, 'content': 'function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDrop.updatePayer', 'start_line': 506, 'end_line': 506, 'offset_start': 17626, 'offset_end': 17684, 'content': 'function updatePayer(address payer, bool allowed) external;', 'contract_name': 'ISeaDrop', 'contract_code': '{\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable;\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable;\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable;\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable;\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory);\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address);\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32);\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool);\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory);\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool);\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory);\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory);\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool);\n    function updateDropURI(string calldata dropURI) external;\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n    function updateAllowList(AllowListData calldata allowListData) external;\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external;\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external;\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external;\n    function updatePayer(address payer, bool allowed) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.contractURI', 'start_line': 518, 'end_line': 518, 'offset_start': 18082, 'offset_end': 18142, 'content': 'function contractURI() external view returns (string memory);', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.setContractURI', 'start_line': 519, 'end_line': 519, 'offset_start': 18148, 'offset_end': 18212, 'content': 'function setContractURI(string calldata newContractURI) external;', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.baseURI', 'start_line': 520, 'end_line': 520, 'offset_start': 18218, 'offset_end': 18274, 'content': 'function baseURI() external view returns (string memory);', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.setBaseURI', 'start_line': 521, 'end_line': 521, 'offset_start': 18280, 'offset_end': 18334, 'content': 'function setBaseURI(string calldata tokenURI) external;', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.maxSupply', 'start_line': 522, 'end_line': 522, 'offset_start': 18340, 'offset_end': 18392, 'content': 'function maxSupply() external view returns (uint256);', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.setMaxSupply', 'start_line': 523, 'end_line': 523, 'offset_start': 18398, 'offset_end': 18450, 'content': 'function setMaxSupply(uint256 newMaxSupply) external;', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.provenanceHash', 'start_line': 524, 'end_line': 524, 'offset_start': 18456, 'offset_end': 18513, 'content': 'function provenanceHash() external view returns (bytes32);', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ISeaDropTokenContractMetadata.setProvenanceHash', 'start_line': 525, 'end_line': 525, 'offset_start': 18519, 'offset_end': 18581, 'content': 'function setProvenanceHash(bytes32 newProvenanceHash) external;', 'contract_name': 'ISeaDropTokenContractMetadata', 'contract_code': '{\n    event MaxSupplyUpdated(uint256 newMaxSupply);\n    event ProvenanceHashUpdated(bytes32 previousHash, bytes32 newHash);\n    event ContractURIUpdated(string newContractURI);\n    event TokenURIUpdated(\n        uint256 indexed startTokenId,\n        uint256 indexed endTokenId\n    );\n    event BaseURIUpdated(string baseURI);\n    function contractURI() external view returns (string memory);\n    function setContractURI(string calldata newContractURI) external;\n    function baseURI() external view returns (string memory);\n    function setBaseURI(string calldata tokenURI) external;\n    function maxSupply() external view returns (uint256);\n    function setMaxSupply(uint256 newMaxSupply) external;\n    function provenanceHash() external view returns (bytes32);\n    function setProvenanceHash(bytes32 newProvenanceHash) external;\n    error ProvenanceHashCannotBeSetAfterMintStarted();\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 534, 'end_line': 534, 'offset_start': 19018, 'offset_end': 19091, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 535, 'end_line': 535, 'offset_start': 19097, 'offset_end': 19168, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 536, 'end_line': 541, 'offset_start': 19174, 'offset_end': 19310, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 542, 'end_line': 546, 'offset_start': 19316, 'offset_end': 19423, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 547, 'end_line': 551, 'offset_start': 19429, 'offset_end': 19532, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 552, 'end_line': 552, 'offset_start': 19538, 'offset_end': 19592, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 553, 'end_line': 553, 'offset_start': 19598, 'offset_end': 19667, 'content': 'function setApprovalForAll(address operator, bool _approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 554, 'end_line': 554, 'offset_start': 19673, 'offset_end': 19751, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 555, 'end_line': 555, 'offset_start': 19757, 'offset_end': 19844, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 562, 'end_line': 580, 'offset_start': 20029, 'offset_end': 20626, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 581, 'end_line': 585, 'offset_start': 20632, 'offset_end': 20805, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 586, 'end_line': 596, 'offset_start': 20811, 'offset_end': 21247, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 597, 'end_line': 599, 'offset_start': 21253, 'offset_end': 21401, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 611, 'end_line': 621, 'offset_start': 21633, 'offset_end': 22120, 'content': 'function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 622, 'end_line': 636, 'offset_start': 22126, 'offset_end': 22677, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 637, 'end_line': 641, 'offset_start': 22683, 'offset_end': 22909, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 642, 'end_line': 650, 'offset_start': 22915, 'offset_end': 23250, 'content': 'function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 651, 'end_line': 659, 'offset_start': 23256, 'offset_end': 23507, 'content': 'function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 660, 'end_line': 674, 'offset_start': 23513, 'offset_end': 24046, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 675, 'end_line': 684, 'offset_start': 24052, 'offset_end': 24321, 'content': 'function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 685, 'end_line': 687, 'offset_start': 24327, 'offset_end': 24497, 'content': 'function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 688, 'end_line': 690, 'offset_start': 24503, 'offset_end': 24698, 'content': 'function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toTypedDataHash', 'start_line': 691, 'end_line': 693, 'offset_start': 24704, 'offset_end': 24897, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV \n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert("ECDSA: invalid signature");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert("ECDSA: invalid signature length");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert("ECDSA: invalid signature \'s\' value");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", Strings.toString(s.length), s));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferETH', 'start_line': 698, 'end_line': 704, 'offset_start': 24999, 'offset_end': 25226, 'content': 'function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransferFrom', 'start_line': 705, 'end_line': 724, 'offset_start': 25232, 'offset_end': 25988, 'content': 'function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeTransfer', 'start_line': 725, 'end_line': 742, 'offset_start': 25994, 'offset_end': 26664, 'content': 'function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeTransferLib.safeApprove', 'start_line': 743, 'end_line': 760, 'offset_start': 26670, 'offset_end': 27338, 'content': 'function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }', 'contract_name': 'SafeTransferLib', 'contract_code': '{\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n        assembly {\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) \n            mstore(add(freeMemoryPointer, 36), to) \n            mstore(add(freeMemoryPointer, 68), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FROM_FAILED");\n    }\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "TRANSFER_FAILED");\n    }\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) \n            mstore(add(freeMemoryPointer, 36), amount) \n            success := and(\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n        require(success, "APPROVE_FAILED");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.tor', 'start_line': 866, 'end_line': 868, 'offset_start': 31361, 'offset_end': 31435, 'content': 'constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.mintPublic', 'start_line': 869, 'end_line': 908, 'offset_start': 31441, 'offset_end': 32689, 'content': 'function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.mintAllowList', 'start_line': 909, 'end_line': 958, 'offset_start': 32695, 'offset_end': 34201, 'content': 'function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.mintSigned', 'start_line': 959, 'end_line': 1014, 'offset_start': 34207, 'offset_end': 35951, 'content': 'function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._validateSignerAndParams', 'start_line': 1015, 'end_line': 1078, 'offset_start': 35957, 'offset_end': 38367, 'content': 'function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.mintAllowedTokenHolder', 'start_line': 1079, 'end_line': 1146, 'offset_start': 38373, 'offset_end': 40692, 'content': 'function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._checkActive', 'start_line': 1147, 'end_line': 1151, 'offset_start': 40698, 'offset_end': 40925, 'content': 'function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._checkFeeRecipientIsAllowed', 'start_line': 1152, 'end_line': 1164, 'offset_start': 40931, 'offset_end': 41362, 'content': 'function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._checkMintQuantity', 'start_line': 1165, 'end_line': 1198, 'offset_start': 41368, 'offset_end': 42542, 'content': 'function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._checkCorrectPayment', 'start_line': 1199, 'end_line': 1206, 'offset_start': 42548, 'offset_end': 42784, 'content': 'function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._splitPayout', 'start_line': 1207, 'end_line': 1232, 'offset_start': 42790, 'offset_end': 43688, 'content': 'function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._mintAndPay', 'start_line': 1233, 'end_line': 1256, 'offset_start': 43694, 'offset_end': 44343, 'content': 'function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._domainSeparator', 'start_line': 1257, 'end_line': 1261, 'offset_start': 44349, 'offset_end': 44529, 'content': 'function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._deriveDomainSeparator', 'start_line': 1262, 'end_line': 1272, 'offset_start': 44535, 'offset_end': 44844, 'content': 'function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getPublicDrop', 'start_line': 1273, 'end_line': 1279, 'offset_start': 44850, 'offset_end': 45012, 'content': 'function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getCreatorPayoutAddress', 'start_line': 1280, 'end_line': 1286, 'offset_start': 45018, 'offset_end': 45191, 'content': 'function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getAllowListMerkleRoot', 'start_line': 1287, 'end_line': 1293, 'offset_start': 45197, 'offset_end': 45367, 'content': 'function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getFeeRecipientIsAllowed', 'start_line': 1294, 'end_line': 1300, 'offset_start': 45373, 'offset_end': 45578, 'content': 'function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getAllowedFeeRecipients', 'start_line': 1301, 'end_line': 1307, 'offset_start': 45584, 'offset_end': 45767, 'content': 'function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getSigners', 'start_line': 1308, 'end_line': 1314, 'offset_start': 45773, 'offset_end': 45937, 'content': 'function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getSignedMintValidationParams', 'start_line': 1315, 'end_line': 1321, 'offset_start': 45943, 'offset_end': 46176, 'content': 'function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getPayers', 'start_line': 1322, 'end_line': 1328, 'offset_start': 46182, 'offset_end': 46344, 'content': 'function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getPayerIsAllowed', 'start_line': 1329, 'end_line': 1335, 'offset_start': 46350, 'offset_end': 46527, 'content': 'function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getTokenGatedAllowedTokens', 'start_line': 1336, 'end_line': 1342, 'offset_start': 46533, 'offset_end': 46722, 'content': 'function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getTokenGatedDrop', 'start_line': 1343, 'end_line': 1349, 'offset_start': 46728, 'offset_end': 46949, 'content': 'function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.getAllowedNftTokenIdIsRedeemed', 'start_line': 1350, 'end_line': 1359, 'offset_start': 46955, 'offset_end': 47260, 'content': 'function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateDropURI', 'start_line': 1360, 'end_line': 1365, 'offset_start': 47266, 'offset_end': 47428, 'content': 'function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updatePublicDrop', 'start_line': 1366, 'end_line': 1376, 'offset_start': 47434, 'offset_end': 47781, 'content': 'function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateAllowList', 'start_line': 1377, 'end_line': 1391, 'offset_start': 47787, 'offset_end': 48269, 'content': 'function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateTokenGatedDrop', 'start_line': 1392, 'end_line': 1429, 'offset_start': 48275, 'offset_end': 49830, 'content': 'function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateCreatorPayoutAddress', 'start_line': 1430, 'end_line': 1439, 'offset_start': 49836, 'offset_end': 50208, 'content': 'function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateAllowedFeeRecipient', 'start_line': 1440, 'end_line': 1466, 'offset_start': 50214, 'offset_end': 51258, 'content': 'function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updateSignedMintValidationParams', 'start_line': 1467, 'end_line': 1517, 'offset_start': 51264, 'offset_end': 53286, 'content': 'function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop.updatePayer', 'start_line': 1518, 'end_line': 1541, 'offset_start': 53292, 'offset_end': 54141, 'content': 'function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._removeFromEnumeration', 'start_line': 1542, 'end_line': 1557, 'offset_start': 54147, 'offset_end': 54632, 'content': 'function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'SeaDrop._getDigest', 'start_line': 1558, 'end_line': 1594, 'offset_start': 54638, 'offset_end': 55808, 'content': 'function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }', 'contract_name': 'SeaDrop', 'contract_code': '{\n    using ECDSA for bytes32;\n    mapping(address => PublicDrop) private _publicDrops;\n    mapping(address => address) private _creatorPayoutAddresses;\n    mapping(address => bytes32) private _allowListMerkleRoots;\n    mapping(address => mapping(address => bool)) private _allowedFeeRecipients;\n    mapping(address => address[]) private _enumeratedFeeRecipients;\n    mapping(address => mapping(address => SignedMintValidationParams))\n        private _signedMintValidationParams;\n    mapping(address => address[]) private _enumeratedSigners;\n    mapping(bytes32 => bool) private _usedDigests;\n    mapping(address => mapping(address => bool)) private _allowedPayers;\n    mapping(address => address[]) private _enumeratedPayers;\n    mapping(address => mapping(address => TokenGatedDropStage))\n        private _tokenGatedDrops;\n    mapping(address => address[]) private _enumeratedTokenGatedTokens;\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        private _tokenGatedRedeemed;\n    bytes32 internal constant _SIGNED_MINT_TYPEHASH =\n        keccak256(\n             "SignedMint("\n                "address nftContract,"\n                "address minter,"\n                "address feeRecipient,"\n                "MintParams mintParams,"\n                "uint256 salt"\n            ")"\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _MINT_PARAMS_TYPEHASH =\n        keccak256(\n            "MintParams("\n                "uint256 mintPrice,"\n                "uint256 maxTotalMintableByWallet,"\n                "uint256 startTime,"\n                "uint256 endTime,"\n                "uint256 dropStageIndex,"\n                "uint256 maxTokenSupplyForStage,"\n                "uint256 feeBps,"\n                "bool restrictFeeRecipients"\n            ")"\n        );\n    bytes32 internal constant _EIP_712_DOMAIN_TYPEHASH =\n        keccak256(\n            "EIP712Domain("\n                "string name,"\n                "string version,"\n                "uint256 chainId,"\n                "address verifyingContract"\n            ")"\n        );\n    bytes32 internal constant _NAME_HASH = keccak256("SeaDrop");\n    bytes32 internal constant _VERSION_HASH = keccak256("1.0");\n    uint256 internal immutable _CHAIN_ID = block.chainid;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    uint256 internal constant _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE =\n        type(uint256).max;\n    uint256 internal constant _PUBLIC_DROP_STAGE_INDEX = 0;\n    modifier onlyINonFungibleSeaDropToken() virtual {\n        if (\n            !IERC165(msg.sender).supportsInterface(\n                type(INonFungibleSeaDropToken).interfaceId\n            )\n        ) {\n            revert OnlyINonFungibleSeaDropToken(msg.sender);\n        }\n        _;\n    }\n    constructor() {\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n    }\n    function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n        uint256 mintPrice = publicDrop.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }\n    function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        uint256 mintPrice = mintParams.mintPrice;\n        _checkCorrectPayment(quantity, mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        _checkActive(mintParams.startTime, mintParams.endTime);\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n        {\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n            _usedDigests[digest] = true;\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }\n    function _validateSignerAndParams(\n        address nftContract,\n        MintParams memory mintParams,\n        address signer\n    ) internal view {\n        SignedMintValidationParams\n            memory signedMintValidationParams = _signedMintValidationParams[\n                nftContract\n            ][signer];\n        if (signedMintValidationParams.maxMaxTotalMintableByWallet == 0) {\n            revert InvalidSignature(signer);\n        }\n        if (mintParams.mintPrice < signedMintValidationParams.minMintPrice) {\n            revert InvalidSignedMintPrice(\n                mintParams.mintPrice,\n                signedMintValidationParams.minMintPrice\n            );\n        }\n        if (\n            mintParams.maxTotalMintableByWallet >\n            signedMintValidationParams.maxMaxTotalMintableByWallet\n        ) {\n            revert InvalidSignedMaxTotalMintableByWallet(\n                mintParams.maxTotalMintableByWallet,\n                signedMintValidationParams.maxMaxTotalMintableByWallet\n            );\n        }\n        if (mintParams.startTime < signedMintValidationParams.minStartTime) {\n            revert InvalidSignedStartTime(\n                mintParams.startTime,\n                signedMintValidationParams.minStartTime\n            );\n        }\n        if (mintParams.endTime > signedMintValidationParams.maxEndTime) {\n            revert InvalidSignedEndTime(\n                mintParams.endTime,\n                signedMintValidationParams.maxEndTime\n            );\n        }\n        if (\n            mintParams.maxTokenSupplyForStage >\n            signedMintValidationParams.maxMaxTokenSupplyForStage\n        ) {\n            revert InvalidSignedMaxTokenSupplyForStage(\n                mintParams.maxTokenSupplyForStage,\n                signedMintValidationParams.maxMaxTokenSupplyForStage\n            );\n        }\n        if (mintParams.feeBps > signedMintValidationParams.maxFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.maxFeeBps\n            );\n        }\n        if (mintParams.feeBps < signedMintValidationParams.minFeeBps) {\n            revert InvalidSignedFeeBps(\n                mintParams.feeBps,\n                signedMintValidationParams.minFeeBps\n            );\n        }\n        if (!mintParams.restrictFeeRecipients) {\n            revert SignedMintsMustRestrictFeeRecipients();\n        }\n    }\n    function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n        address allowedNftToken = mintParams.allowedNftToken;\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n        _checkActive(dropStage.startTime, dropStage.endTime);\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n        for (uint256 i = 0; i < mintQuantity; ) {\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n            redeemedTokenIds[tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }\n    function _checkActive(uint256 startTime, uint256 endTime) internal view {\n        if (block.timestamp < startTime || block.timestamp > endTime) {\n            revert NotActive(block.timestamp, startTime, endTime);\n        }\n    }\n    function _checkFeeRecipientIsAllowed(\n        address nftContract,\n        address feeRecipient,\n        bool restrictFeeRecipients\n    ) internal view {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        if (restrictFeeRecipients)\n            if (!_allowedFeeRecipients[nftContract][feeRecipient]) {\n                revert FeeRecipientNotAllowed();\n            }\n    }\n    function _checkMintQuantity(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 maxTotalMintableByWallet,\n        uint256 maxTokenSupplyForStage\n    ) internal view {\n        if (quantity == 0) {\n            revert MintQuantityCannotBeZero();\n        }\n        (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        ) = INonFungibleSeaDropToken(nftContract).getMintStats(minter);\n        if (quantity + minterNumMinted > maxTotalMintableByWallet) {\n            revert MintQuantityExceedsMaxMintedPerWallet(\n                quantity + minterNumMinted,\n                maxTotalMintableByWallet\n            );\n        }\n        if (quantity + currentTotalSupply > maxSupply) {\n            revert MintQuantityExceedsMaxSupply(\n                quantity + currentTotalSupply,\n                maxSupply\n            );\n        }\n        if (quantity + currentTotalSupply > maxTokenSupplyForStage) {\n            revert MintQuantityExceedsMaxTokenSupplyForStage(\n                quantity + currentTotalSupply,\n                maxTokenSupplyForStage\n            );\n        }\n    }\n    function _checkCorrectPayment(uint256 quantity, uint256 mintPrice)\n        internal\n        view\n    {\n        if (msg.value != quantity * mintPrice) {\n            revert IncorrectPayment(msg.value, quantity * mintPrice);\n        }\n    }\n    function _splitPayout(\n        address nftContract,\n        address feeRecipient,\n        uint256 feeBps\n    ) internal {\n        if (feeBps > 10_000) {\n            revert InvalidFeeBps(feeBps);\n        }\n        address creatorPayoutAddress = _creatorPayoutAddresses[nftContract];\n        if (creatorPayoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        if (feeBps == 0) {\n            SafeTransferLib.safeTransferETH(creatorPayoutAddress, msg.value);\n            return;\n        }\n        uint256 feeAmount = (msg.value * feeBps) / 10_000;\n        uint256 payoutAmount;\n        unchecked {\n            payoutAmount = msg.value - feeAmount;\n        }\n        if (feeAmount > 0) {\n            SafeTransferLib.safeTransferETH(feeRecipient, feeAmount);\n        }\n        SafeTransferLib.safeTransferETH(creatorPayoutAddress, payoutAmount);\n    }\n    function _mintAndPay(\n        address nftContract,\n        address minter,\n        uint256 quantity,\n        uint256 mintPrice,\n        uint256 dropStageIndex,\n        uint256 feeBps,\n        address feeRecipient\n    ) internal nonReentrant {\n        INonFungibleSeaDropToken(nftContract).mintSeaDrop(minter, quantity);\n        if (mintPrice != 0) {\n            _splitPayout(nftContract, feeRecipient, feeBps);\n        }\n        emit SeaDropMint(\n            nftContract,\n            minter,\n            feeRecipient,\n            msg.sender,\n            quantity,\n            mintPrice,\n            feeBps,\n            dropStageIndex\n        );\n    }\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n    function _deriveDomainSeparator() internal view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                _EIP_712_DOMAIN_TYPEHASH,\n                _NAME_HASH,\n                _VERSION_HASH,\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }\n    function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }\n    function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }\n    function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }\n    function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }\n    function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }\n    function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }\n    function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }\n    function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }\n    function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }\n    function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }\n    function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }\n    function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        emit DropURIUpdated(msg.sender, dropURI);\n    }\n    function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n        _publicDrops[msg.sender] = publicDrop;\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }\n    function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }\n    function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }\n    function updateCreatorPayoutAddress(address _payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (_payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        _creatorPayoutAddresses[msg.sender] = _payoutAddress;\n        emit CreatorPayoutAddressUpdated(msg.sender, _payoutAddress);\n    }\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }\n    function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }\n    function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }\n    function _removeFromEnumeration(\n        address toRemove,\n        address[] storage enumeration\n    ) internal {\n        uint256 enumerationLength = enumeration.length;\n        for (uint256 i = 0; i < enumerationLength; ) {\n            if (enumeration[i] == toRemove) {\n                enumeration[i] = enumeration[enumerationLength - 1];\n                enumeration.pop();\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getDigest(\n        address nftContract,\n        address minter,\n        address feeRecipient,\n        MintParams memory mintParams,\n        uint256 salt\n    ) internal view returns (bytes32 digest) {\n        bytes32 mintParamsHashStruct = keccak256(\n            abi.encode(\n                _MINT_PARAMS_TYPEHASH,\n                mintParams.mintPrice,\n                mintParams.maxTotalMintableByWallet,\n                mintParams.startTime,\n                mintParams.endTime,\n                mintParams.dropStageIndex,\n                mintParams.maxTokenSupplyForStage,\n                mintParams.feeBps,\n                mintParams.restrictFeeRecipients\n            )\n        );\n        digest = keccak256(\n            bytes.concat(\n                bytes2(0x1901),\n                _domainSeparator(),\n                keccak256(\n                    abi.encode(\n                        _SIGNED_MINT_TYPEHASH,\n                        nftContract,\n                        minter,\n                        feeRecipient,\n                        mintParamsHashStruct,\n                        salt\n                    )\n                )\n            )\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 1603, 'end_line': 1605, 'offset_start': 55923, 'offset_end': 56026, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 1606, 'end_line': 1608, 'offset_start': 56032, 'offset_end': 56135, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 1609, 'end_line': 1611, 'offset_start': 56141, 'offset_end': 56256, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 1612, 'end_line': 1614, 'offset_start': 56262, 'offset_end': 56384, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 1615, 'end_line': 1655, 'offset_start': 56390, 'offset_end': 57856, 'content': 'function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 1656, 'end_line': 1667, 'offset_start': 57862, 'offset_end': 58198, 'content': 'function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1668, 'end_line': 1683, 'offset_start': 58204, 'offset_end': 58784, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 1684, 'end_line': 1689, 'offset_start': 58790, 'offset_end': 59026, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1690, 'end_line': 1726, 'offset_start': 59032, 'offset_end': 60014, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 1727, 'end_line': 1732, 'offset_start': 60020, 'offset_end': 60264, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1733, 'end_line': 1765, 'offset_start': 60270, 'offset_end': 61159, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 1766, 'end_line': 1771, 'offset_start': 61165, 'offset_end': 61410, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1772, 'end_line': 1796, 'offset_start': 61416, 'offset_end': 62078, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 1797, 'end_line': 1802, 'offset_start': 62084, 'offset_end': 62338, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, \n        Up, \n        Zero \n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            require(denominator > prod1);\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/8453/0x00005ea00ac477b1030ce78506496e8c2de24bf5/0x00005ea00ac477b1030ce78506496e8c2de24bf5.sol'}
